<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cookies&amp;Session</title>
      <link href="/2022/07/15/Cookies-Session/"/>
      <url>/2022/07/15/Cookies-Session/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>会话跟踪是一种维护浏览器状态的方法 服务器需要识别多次请求是否来自于同一浏览器 以便在同一次会话的多次请求间共享数据</p></blockquote><span id="more"></span><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><blockquote><p>客户端会话跟踪技术</p></blockquote><h2 id="Cookie-基本使用"><a href="#Cookie-基本使用" class="headerlink" title="Cookie 基本使用"></a>Cookie 基本使用</h2><ul><li>Cookie：客户端会话技术 将数据保存到客户端 以后每次请求都携带Cookie数据进行访问</li><li>Cookie基本使用<ul><li>创建Cookie对象 设置数据<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cookie cookie</span> = new Cookie(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>发送Cookie到客户端 使用response对象<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.add<span class="constructor">Cookie(<span class="params">cookie</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获取客户端携带的所有Cookie 使用request对象<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies <span class="operator">=</span> request.getCookies()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>遍历数组 获取每一个Cookie对象</li><li>使用Cookie对象方法获取数据<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie.getName()<span class="comment">;</span></span><br><span class="line">cookie.getValue()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="Cookie-原理"><a href="#Cookie-原理" class="headerlink" title="Cookie 原理"></a>Cookie 原理</h2></li></ul></li><li>Cookie 的实现是基于HTTP协议的<ul><li>响应头 set-cookie</li><li>请求头 cookie<h2 id="Cookie-使用细节"><a href="#Cookie-使用细节" class="headerlink" title="Cookie 使用细节"></a>Cookie 使用细节</h2></li></ul></li><li>Cookie 存活时间<ul><li>默认情况下，Cookie 存储在浏览器内存中 当浏览器关闭 内存释放 则Cookie被销毁</li><li>setMaxAge(int seconds) 设置Cookie存活时间<ul><li>正数 将Cookie写入浏览器所在电脑的硬盘 持久化存储 到时间自动删除</li><li>负数 默认值 Cookie在当前浏览器内存中 当浏览器关闭 则Cookie被销毁</li><li>零 删除对应Cookie</li></ul></li></ul></li><li>Cookie 存储中文<ul><li>Cookie 不能直接存储中文</li><li>如需要存储 则需要进行转码 URL编码<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><blockquote><p>服务端会话跟踪技术</p></blockquote><h2 id="Session-基本使用"><a href="#Session-基本使用" class="headerlink" title="Session 基本使用"></a>Session 基本使用</h2></li></ul></li><li>服务端会话跟踪技术 将数据保存到服务端</li><li>JavaEE提供HttpSession接口 来实现一次会话的多次请求间数据共享功能</li><li>使用<ul><li>获取Session对象<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session <span class="operator">=</span> request.getSession()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>Session 对象功能<ul><li>void setAttribute(String name,Object o) 存储数据到session域中</li><li>Object getAttribute(String name) 根据key 获取值</li><li>void removeAttribute(String name) 根据key 删除该键值对<h2 id="Session-原理"><a href="#Session-原理" class="headerlink" title="Session 原理"></a>Session 原理</h2></li></ul></li></ul></li><li>用户第一次请求服务器时，服务器端会生成一个sessionid</li><li>服务器端将生成的sessionid返回给客户端，通过set-cookie</li><li>客户端收到sessionid会将它保存在cookie中，当客户端再次访问服务端时会带上这个sessionid</li><li>当服务端再次接收到来自客户端的请求时，会先去检查是否存在sessionid，不存在就新建一个sessionid重复1,2的流程，如果存在就去遍历服务端的session文件，找到与这个sessionid相对应的文件，文件中的键值便是sessionid，值为当前用户的一些信息</li><li>此后的请求都会交换这个 Session ID，进行有状态的会话。<h2 id="Session-使用细节"><a href="#Session-使用细节" class="headerlink" title="Session 使用细节"></a>Session 使用细节</h2></li><li>Session 钝化 活化<ul><li>钝化 在服务器正常关闭后 Tomcat会自动将Session数据写入硬盘的文件中</li><li>活化 再次启动服务器后 从文件中加载数据到Session中</li></ul></li><li>Session 销毁<ul><li>默认情况下 无操作 30分组后自动销毁<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>调用Session对象的invalidate()方法</li></ul></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>Cookie 和 Session 都是来完成一次会话内多次请求间数据共享的</li><li>区别<ul><li>存储位置 Cookie 是将数据存储在客户端 Session将数据存储在服务器端</li><li>安全性 Cookie 不安全 Seesion 安全</li><li>数据大小 Cookie 最大3KB Session 无大小限制</li><li>存储时间 Cookie可以长时间存储 Session默认30分钟</li><li>服务器性能 Cookie不占服务器资源 Session 占用服务器资源</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 会话跟踪 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Request&amp;Response</title>
      <link href="/2022/07/13/Request-Response/"/>
      <url>/2022/07/13/Request-Response/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Request 获取请求数据<br>Response 设置响应数据</p></blockquote><span id="more"></span><h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><h2 id="Request-继承体系"><a href="#Request-继承体系" class="headerlink" title="Request 继承体系"></a>Request 继承体系</h2><p><img src="/2022/07/13/Request-Response/Request%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png" alt="Request 继承体系"></p><ul><li>TomCat 需要解析请求数据 封装为request对象 并且创建request对象传递到service方法中<h2 id="Request-获取请求数据"><a href="#Request-获取请求数据" class="headerlink" title="Request 获取请求数据"></a>Request 获取请求数据</h2><h3 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h3></li><li>请求数据分为3部分<ul><li>请求行 GET&#x2F;request-demo&#x2F;reql?username &#x3D; zhangsan HTTP&#x2F;1.1<ul><li>String getMethod() 获取请求方式  ： GET</li><li>String getContextPath() 获取虚拟目录(目录访问路径) :&#x2F;request-demo</li><li>StringBuffer getRequestURL() 获取URL ： <a href="http://localhost:8080/request-demo/req1">http://localhost:8080/request-demo/req1</a></li><li>String getRequestURL() 获取URI ： &#x2F;request-demo&#x2F;req1</li><li>String getQueryString() 获取请求参数(GET方式) username&#x3D; zhangsan&amp;password &#x3D; 123</li></ul></li><li>请求头 User-Agent:Mozilla&#x2F;5.0 Chrome&#x2F;91.0.4472.106<ul><li>String getHeader(String name) 根据请求头名称 获取值</li></ul></li><li>请求体 username &#x3D; kris&amp;password &#x3D; 111<ul><li>ServletInputStream getInputSatream() 获取字节输入流</li><li>BufferedReader getReader() 获取字符输入流</li></ul></li></ul></li></ul><h3 id="通用方式获取请求参数"><a href="#通用方式获取请求参数" class="headerlink" title="通用方式获取请求参数"></a>通用方式获取请求参数</h3><ul><li>请求参数获取方式<ul><li>GET 方式<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">String</span> <span class="function"><span class="title">getQueryString</span>()</span></span><br></pre></td></tr></table></figure></li><li>POST 方式<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">BufferedReader</span> <span class="function"><span class="title">getReader</span>()</span></span><br></pre></td></tr></table></figure></li></ul></li><li>Request 通用方式获取请求参数<ul><li>Map&lt;String,String[]&gt; getParameterMap(); 获取所有参数Map集合</li><li>String[] getParameterValues(String name) 根据名称获取参数值(数组)</li><li>String getParameter(String name) 根据名称获取参数值(单个值)</li></ul></li></ul><h3 id="请求参数中文乱码处理"><a href="#请求参数中文乱码处理" class="headerlink" title="请求参数中文乱码处理"></a>请求参数中文乱码处理</h3><ul><li><p>请求参数如果存在中文数据，则会乱码</p><ul><li>POST： 设置输入流的编码<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>GET  先编码 再解码<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">String(<span class="params">username</span>.<span class="params">getBytes</span>(<span class="string">&quot;ISO-8859-1&quot;</span>)</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>URL 编码<ul><li>将字符串按照编码方式转为二进制</li><li>每个字节转为2个16进制数并在前边加上%<h2 id="Request-请求转发"><a href="#Request-请求转发" class="headerlink" title="Request 请求转发"></a>Request 请求转发</h2><blockquote><p>一种在服务器内部的资源跳转方式</p></blockquote></li></ul></li></ul></li><li><p>实现方式</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.getRequestDispatcher(<span class="string">&quot;资源B路径&quot;</span>).forward(req.resp)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>请求转发资源间共享数据 使用Requset 对象</p><ul><li>void setAttribute(String name,Object o) 存储数据到request域中</li><li>Object getAttribute(String name) 根据key 获取值</li><li>void removeAttribute(String name)根据key 删除该键值对</li></ul></li><li><p>请求转发特点</p><ul><li>浏览器地址栏路径不发生变化</li><li>只能转发到当前服务器的内部资源</li><li>一次请求 可以在转发的资源间使用request共享数据</li></ul></li></ul><h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><h2 id="Response-设置响应数据功能介绍"><a href="#Response-设置响应数据功能介绍" class="headerlink" title="Response 设置响应数据功能介绍"></a>Response 设置响应数据功能介绍</h2><ul><li><p>响应行 </p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure><ul><li>void setStatus(int sc) 设置响应状态码</li></ul></li><li><p>响应头</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>:<span class="type">text</span>/html</span><br></pre></td></tr></table></figure><ul><li>void setHeader(String name,String value) 设置响应头键值对</li></ul></li><li><p>响应体</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;html&gt;</span><span class="section">&lt;head&gt;</span><span class="section">&lt;/head&gt;</span><span class="section">&lt;body&gt;</span><span class="section">&lt;/body&gt;</span><span class="section">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><ul><li>PrintWrite getWriter() 获取字符输出流</li><li>ServletOutputStream getOutputStream() 获取字节输出流<h2 id="Response-完成重定向"><a href="#Response-完成重定向" class="headerlink" title="Response 完成重定向"></a>Response 完成重定向</h2><blockquote><p>重定向(Redirect) 一种资源跳转方式</p></blockquote></li></ul></li><li><p>实现方式</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp.set<span class="constructor">Status(302)</span>;</span><br><span class="line">resp.set<span class="constructor">Header(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;另一资源的路径&quot;</span>)</span>;</span><br><span class="line"><span class="comment">//简化版</span></span><br><span class="line">resp.send<span class="constructor">Redirect(<span class="string">&quot;另一资源的路径&quot;</span>)</span></span><br></pre></td></tr></table></figure></li><li><p>重定向特点</p><ul><li>浏览器地址栏发生变化</li><li>可以重定向到任意位置的资源(服务器内部，外部均可)</li><li>两次请求，不能在多个资源使用request共享数据<h2 id="Response-响应字符数据"><a href="#Response-响应字符数据" class="headerlink" title="Response 响应字符数据"></a>Response 响应字符数据</h2></li></ul></li><li><p>使用</p><ul><li>通过Response对象获取字符输出流<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter writer <span class="operator">=</span> resp.getWriter()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>写数据<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.write(<span class="string">&quot;kris&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>设置编码<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset = utf-8&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>该流不需要关闭 随着响应结束 response 对象销毁 由服务器关闭<h2 id="Response-响应字节数据"><a href="#Response-响应字节数据" class="headerlink" title="Response 响应字节数据"></a>Response 响应字节数据</h2></li></ul></li><li><p>使用</p><ul><li>通过Response对象获取字符输出流<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletOutputStream outputStream <span class="operator">=</span> resp.getOutputStream()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>写数据<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputStream.write(字节数据)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>IOUtils工具类的使用</p><ul><li>导入坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOUtils.<span class="keyword">copy</span>(输入流,输出流);</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="/2022/07/12/Servlet/"/>
      <url>/2022/07/12/Servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Servlet 是JavaEE规范之一，就是一个接口 我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</p></blockquote><span id="more"></span><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><ul><li>创建web项目 导入Servlet依赖坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>创建 定义一个类 实现Servlet接口 并重写接口中的所有方法 并在service方法中输入一句话<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ServletDemo</span> <span class="symbol">implements</span> <span class="symbol">Servlet</span></span><br></pre></td></tr></table></figure></li><li>配置 在类上使用@WebServlet 注解 配置Servlet的访问路径<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(<span class="string">&quot;/demo1&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ServletDemo</span> <span class="symbol">implements</span> <span class="symbol">Servlet</span></span><br></pre></td></tr></table></figure><ul><li>注解中的loadOnStartip参数<ul><li>若为负整数(默认-1) 第一次被访问时创建Servlet对象</li><li>0或正整数 服务器启动时创建Servlet对象，数字越小优先级越高</li></ul></li></ul></li><li>访问 启动TomCat 浏览器输入URL访问该Servlet<h1 id="Servlet-执行流程"><a href="#Servlet-执行流程" class="headerlink" title="Servlet 执行流程"></a>Servlet 执行流程</h1></li><li>当Servlet第一次被调用的时候会触发init函数，该函数会把servlet实例加载到内存。该函数只会被调用一次</li><li>web服务器把接收到的http请求封装成一个Request对象，作为service函数的参数传递进去。</li><li>service函数会被调用多次，每访问一次Servlet，它的service函数就会被调用一次</li><li>返回的结果封装在response对象，web服务器先将response的信息拆解出来<br>形成http响应格式。然后将这个结果返回给浏览器。</li><li>浏览器得到结果之后会自己能识别的格式进行解析<h1 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h1></li><li>对象的生命周期指一个对象从被创建到销毁的整个过程</li><li>Servlet 运行在Servlet容器(web服务器)中，其生命周期由容器来管理 分为4个阶段<ul><li>加载和实例化 默认情况下 当Servlet第一次被访问时，由容器创建Servlet对象</li><li>初始化 在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象 完成一些如加载配置文件 创建连接等初始化的工作 该方法只调用一次</li><li>请求处理 每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理</li><li>服务终止 当需要释放内存或者容器关闭时 容器就会调用Servlet实例的destroy()方法完成资源的释放，在destroy()方法调用之后 容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</li></ul></li></ul><h1 id="Servlet-体系结构"><a href="#Servlet-体系结构" class="headerlink" title="Servlet 体系结构"></a>Servlet 体系结构</h1><blockquote><p>开发B&#x2F;S架构的web项目，都是针对HTTP协议 所以自定义的Servlet 会继承HttpServlet</p></blockquote><p><img src="/2022/07/12/Servlet/Servlet%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="Servlet体系结构"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@WebServlet</span>(<span class="string">&quot;/demo2&quot;</span>)</span><br><span class="line">    public <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doGet(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doPost(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Servlet-urlPattern配置"><a href="#Servlet-urlPattern配置" class="headerlink" title="Servlet urlPattern配置"></a>Servlet urlPattern配置</h1><ul><li>Servlet 要想被访问 必须配置其访问路径(urlPattern)<ul><li>一个Servlet 可以配置多个urlPattern<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPattern = &#123;<span class="string">&quot;/demo1&quot;</span>,<span class="string">&quot;/demo2&quot;</span>&#125;)</span></span><br></pre></td></tr></table></figure></li><li>urlPattern 配置规则<ul><li>精确匹配  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">配置路径  <span class="variable">@WebServlet</span>(&quot;/user/select&quot;)</span><br><span class="line">访问路径 localhost:<span class="number">8080</span><span class="operator">/</span>web<span class="operator">-</span>demo<span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span><span class="keyword">select</span></span><br></pre></td></tr></table></figure></li><li>目录匹配  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置路径  @WebServlet(<span class="string">&quot;/user/*&quot;</span>)</span><br><span class="line">访问路径 localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/aaa</span><br><span class="line">         localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/bbb</span><br></pre></td></tr></table></figure></li><li>扩展名匹配  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置路径  @WebServlet(<span class="string">&quot;*.do&quot;</span>)</span><br><span class="line">访问路径 localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/aaa.<span class="keyword">do</span></span><br><span class="line">         localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/bbb.<span class="keyword">do</span></span><br></pre></td></tr></table></figure></li><li>任意匹配  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置路径  <span class="variable">@WebServlet</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">          <span class="variable">@WebServlet</span>(<span class="string">&quot;/*&quot;</span>)</span><br><span class="line">访问路径 <span class="attribute">localhost</span>:<span class="number">8080</span>/web-demo/haha</span><br></pre></td></tr></table></figure></li><li>优先级<br>  精确&gt;目录&gt;扩展名&gt;&#x2F;*&gt;&#x2F;<h1 id="XML-配置方式编写-Servlet"><a href="#XML-配置方式编写-Servlet" class="headerlink" title="XML 配置方式编写 Servlet"></a>XML 配置方式编写 Servlet</h1></li></ul></li></ul></li><li>Servlet 从3.0版本后开始支持使用注解配置 3.0之前只支持XML配置文件的配置方式</li><li>步骤<ul><li>编写Servlet类</li><li>在web.xml中配置Servelt<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;demo&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.kris.servletDemo&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;demo&lt;/servlet&gt;</span><br><span class="line">    &lt;url-pattern&gt;/demo&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TomCat</title>
      <link href="/2022/07/12/TomCat/"/>
      <url>/2022/07/12/TomCat/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Web 服务器是一个应用程序 对HTTP协议的操作进行封装，使的程序员不必直接对协议进行操作，让Web开发更加便捷 </p></blockquote><span id="more"></span><h1 id="TomCat-目录结构"><a href="#TomCat-目录结构" class="headerlink" title="TomCat 目录结构"></a>TomCat 目录结构</h1><ul><li>bin 可执行文件存放目录</li><li>conf 配置文件存放目录</li><li>lib tomcat依赖的jar包</li><li>logs 日志文件</li><li>temp 临时文件</li><li>webapps 应用发布目录</li><li>work 工作目录<h1 id="TomCat-基本使用"><a href="#TomCat-基本使用" class="headerlink" title="TomCat 基本使用"></a>TomCat 基本使用</h1></li><li>配置<ul><li>修改启动端口号: conf&#x2F;server.xml<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port<span class="operator">=</span><span class="string">&quot;8080&quot;</span> protocol<span class="operator">=</span><span class="string">&quot;HTTP/1.1&quot;</span></span><br><span class="line">  connectionTimeout<span class="operator">=</span><span class="string">&quot;20000&quot;</span></span><br><span class="line">  redirectPort<span class="operator">=</span><span class="string">&quot;8443&quot;</span> /&gt;</span><br><span class="line">  //默认为 <span class="number">8080</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>HTTP协议默认端口号为80，如果将TomCat端口号改为80，则将来访问时将不用输入端口号</strong></p><ul><li>启动时可能出现的问题<ul><li>端口号冲突 找到对应程序 将其关闭</li><li>闪退 检查JAVA_HOME 环境变量是否正确配置</li></ul></li><li>TonCat 部署项目<ul><li>将项目放置到webapps 目录下，即部署完成</li></ul></li><li>一般JavaWeb项目会被打成war包 然后将war包放到webapps目录下,TomCat会自动解压缩war文件</li></ul><h1 id="IDEA中创建Maven-Web-项目"><a href="#IDEA中创建Maven-Web-项目" class="headerlink" title="IDEA中创建Maven Web 项目"></a>IDEA中创建Maven Web 项目</h1><ul><li>使用骨架(项目模板)<ul><li>选择web项目骨架，创建项目</li><li>删除pom.xml中多余的坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">以下到<span class="tag">&lt;/<span class="name">project</span>&gt;</span>以上的部分都可删除</span><br></pre></td></tr></table></figure></li><li>补齐缺失的目录结构<ul><li>java</li><li>resources</li></ul></li></ul></li><li>不使用<ul><li>新建maven模板  </li><li>将打包方式改为war</li><li>补齐缺失的目录结构<ul><li>webapp 以及其子目录</li></ul></li></ul></li></ul><h1 id="IDEA中使用TomCat"><a href="#IDEA中使用TomCat" class="headerlink" title="IDEA中使用TomCat"></a>IDEA中使用TomCat</h1><ul><li>pom.xml 添加TomCat插件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用Maven Helper 插件启动项目 选中项目 右键-&gt; Run Maven –&gt; tomcat7:run</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2022/07/11/JS-1/"/>
      <url>/2022/07/11/JS-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>JavaScript 是一门跨平台，面向对象的脚本语言，来控制网页行为的，它能使网页可交互</p></blockquote><span id="more"></span><h1 id="JS-引入方式"><a href="#JS-引入方式" class="headerlink" title="JS 引入方式"></a>JS 引入方式</h1><ul><li>内部脚本 将JS代码定义在HTML页面中<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  JS代码</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在HTML文档中可以在任意地方，放置任意数量的&lt;script&gt;</li><li>一般把脚本置于&lt;body&gt;元素的底部，可以改善显示速度，因为脚本执行会拖慢显示</li></ul></li><li>外部脚本 将JS代码定义在外部JS文件中，然后引入到HTML页面中<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">script</span> src = <span class="string">&quot;xxx.js&quot;</span>&gt;&lt;\<span class="keyword">script</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>外部脚本不能包含&lt;script&gt;标签</li><li>&lt;script&gt; 标签不能自闭合<h1 id="JS-基础语法"><a href="#JS-基础语法" class="headerlink" title="JS 基础语法"></a>JS 基础语法</h1><h2 id="书写语法"><a href="#书写语法" class="headerlink" title="书写语法"></a>书写语法</h2></li></ul></li><li>区分大小写 与Java一样 变量名 函数名 以及其他一切东西都是区分大小写的</li><li>每行结尾的分号可有可无</li><li>注释<ul><li>单行  &#x2F;&#x2F;</li><li>多行  &#x2F;**&#x2F;</li></ul></li><li>大括号表示代码块<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  代码</span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h2></li><li>使用 window.alert()写入警告框</li><li>使用document.write()写入HTML输出</li><li>使用console.log()写入浏览器控制台<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li><li>JS 中用var关键字来声明变量 相当于全局变量 并且可以重复定义</li><li>JS是一门弱类型语言，变量可以存放不同类型的值<ul><li>组成字符可以是任何字母 数字 下划线 或者美元符号($)</li><li>数字不能开头</li><li>建议使用驼峰命名</li></ul></li><li>ECMAScript 6 新增let关键字来定义变量，用法类似var 但是所声明的变量只在let关键字所在的代码块内有效，且不允许重复声明</li><li>ECMAScript 6 新增了const 关键字 用来声明一个只读的常量，一旦声明，常量的值就不能改变<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2></li><li>原始类型<ul><li>number 数字(整数 小数 NaN(Not a Number))</li><li>string 字符 字符串 单双引皆可</li><li>boolean 布尔 </li><li>null 对象为空</li><li>undefined 当声明的变量未初始化时 该变量的默认值时undefined</li></ul></li></ul><p><strong>使用typeof运算符可以获取数据类型</strong></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>&#x3D;&#x3D; 会先判断数据类型 然后进行转换，在比较值，如 整数20会&#x3D;&#x3D; 字符串20</li><li>&#x3D;&#x3D;&#x3D; 不会进行类型转换，类型不一样返回false</li><li>类型转换<ul><li>字符串的字面值转成整数，如果字符串字母值时字符，会转换成NaN，布尔类型 true 1 false 0</li><li>0或者NaN会转成false 其他则为 true</li><li>空字符串转成false 其他为true</li><li>null 和 undefined都转为false<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2></li></ul></li><li>JS 函数通过function关键词进行定义 语法为<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">定义方式一</span><br><span class="line"><span class="keyword">function</span> 函数名(<span class="params">参数<span class="number">1</span>，参数<span class="number">2</span>，...</span>)&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br><span class="line">定义方式二</span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="keyword">function</span>(<span class="params">参数列表</span>)&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>形参不需要类型 因为JS时弱类型语言</li><li>返回值也不需要定义类型 可以在函数内部直接使用return返回即可</li><li>JS 中，函数调用可以传递任意个数参数<h1 id="JS-常用对象"><a href="#JS-常用对象" class="headerlink" title="JS 常用对象"></a>JS 常用对象</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2></li><li>定义<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="built_in">Array</span>（元素列表）;<span class="comment">//方式 一</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = [元素列表];<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure></li><li>访问<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[索引] <span class="operator">=</span> 值</span><br></pre></td></tr></table></figure></li></ul><p><strong>JS类似于Java集合 长度和类型都可变</strong></p><ul><li>push()  添加元素</li><li>splice() 删除<ul><li>参数一 从哪开始山</li><li>参数二 删几个</li></ul></li></ul><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_array.asp">JS Array</a></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>定义<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="built_in">String</span>(s);<span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = s；<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure></li><li>属性<ul><li>length  字符串长度</li><li>…</li></ul></li><li>方法<ul><li>charAt()  返回指定位置的字符</li><li>indexOf()   检索字符串</li><li>trim() 去除首位的空格</li><li>…</li></ul></li></ul><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_string.asp">JS String</a></p><h2 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h2><ul><li>格式<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名称 <span class="operator">=</span> &#123;</span><br><span class="line">  属性名称<span class="number">1</span>:属性值<span class="number">1</span>，</span><br><span class="line">  属性名称<span class="number">2</span>:属性值<span class="number">2</span>，</span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">  函数名称:<span class="title function_">function</span>(形参列表)&#123;&#125;</span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1></li><li>Brower Object Model 浏览器对象模型</li><li>JavaScript 将浏览器的各个组成部分封装为对象</li></ul><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><ul><li><p>Window 浏览器窗口对象</p></li><li><p>获取 直接使用window 其中window. 可以省略</p></li><li><p>属性 获取其他BOM对象</p><ul><li>history  对History 对象的只读引用</li><li>Navigator  对<a href="https://www.w3school.com.cn/jsref/obj_navigator.asp">Navigator</a>对象的只读引用</li><li>Screen  对<a href="https://www.w3school.com.cn/jsref/obj_screen.asp">Screen</a>对象的只读引用</li><li>location 用于窗口或框架的Location对象</li></ul></li><li><p>方法</p><ul><li>alert() 显示带有一段信息和一个确认按钮的警告框</li><li>confirm() 显示带有一段信息以及确认按钮和取消按钮的对话框 <ul><li>返回flag 确认为true 取消 false</li></ul></li><li>setInterval() 按照指定的周期(以毫秒计)来调用函数或计算表达式 <ul><li>参数一 function</li><li>参数二 毫秒值</li></ul></li><li>setTimeout() 在指定的毫秒数后调用函数或者计算表达式<ul><li>参数一 function</li><li>参数二 毫秒值<h2 id="History-历史记录对象"><a href="#History-历史记录对象" class="headerlink" title="History 历史记录对象"></a>History 历史记录对象</h2></li></ul></li></ul></li><li><p>History 历史记录</p></li><li><p>获取 使用window.history获取 </p></li><li><p>方法</p><ul><li>back()  加载history列表中的前一个URL</li><li>forward()  加载history列表中的下一个URL <h2 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h2></li></ul></li><li><p>Location 地址栏对象</p></li><li><p>获取 使用window.location获取</p></li><li><p>属性</p><ul><li>href  设置或返回完整的URL<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1></li></ul></li><li><p>Document Object Model 文档对象模型</p></li><li><p>将标记语言的各个组成部分封装为对象</p><ul><li>Document 整个文档对象</li><li>Element  元素对象</li><li>Attribute   属性对象</li><li>Text   文本对象</li><li>Comment   注释对象</li></ul></li><li><p>JS 通过 DOM 能对HTML进行操作</p><ul><li>改变HTML元素的内容</li><li>改变HTML元素的样式</li><li>对HTML DOM 事件做出反应</li><li>添加和删除HTML元素<h2 id="获取Element对象"><a href="#获取Element对象" class="headerlink" title="获取Element对象"></a>获取Element对象</h2></li></ul></li><li><p>获取 使用Document 对象的方法来获取</p><ul><li>getElementById 根据id值获取 返回一个Element对象</li><li>getElementByName  根据name属性值获取 返回Element对象数组</li><li>getElementByTagName 根据标签名获取 返回Element对象数组</li><li>getElementByClassName 根据class属性值获取 返回Element对象数组</li></ul></li></ul><h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><ul><li><p>事件 HTML事件是发生在HTML元素上的“事情” 例如</p><ul><li>按钮被点击</li><li>鼠标移动到元素上</li></ul></li><li><p>事件监听 JS可以在事件被侦测到时执行代码</p></li></ul><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><ul><li>方式一 通过HTML标签中的事件属性进行绑定<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">&quot;button&quot;</span> onclick = <span class="string">&#x27;on()&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">on</span><span class="params">()</span></span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;点击&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方式二 通过DOM元素属性绑定<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type<span class="operator">=</span><span class="string">&quot;button&quot;</span> id <span class="operator">=</span> <span class="string">&quot;btn&quot;</span>&gt;</span><br><span class="line">document.getElementById(<span class="string">&quot;btn&quot;</span>).onclick <span class="operator">=</span> function()&#123;</span><br><span class="line">  alert(<span class="string">&quot;点击&quot;</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h2><table><thead><tr><th>事件名</th><th>说明</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标点击事件</td></tr><tr><td>onblur</td><td>元素失去焦点</td></tr><tr><td>onfocus</td><td>元素获得焦点</td></tr><tr><td>onload</td><td>某个页面或图像被完成加载</td></tr><tr><td>onsubmit</td><td>当表单提交时触发该事件</td></tr><tr><td>onkeydown</td><td>某个键盘的键被按下</td></tr><tr><td>onmouseover</td><td>鼠标被移到某元素上</td></tr><tr><td>onmouseout</td><td>鼠标从某元素移开</td></tr></tbody></table><p><a href="https://www.w3school.com.cn/jsref/dom_obj_event.asp">DOM 事件</a></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2022/07/11/CSS/"/>
      <url>/2022/07/11/CSS/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>CSS(Cascading Style Sheet) 层叠样式表 用于控制网页表现</p></blockquote><span id="more"></span><h1 id="CSS-导入方式"><a href="#CSS-导入方式" class="headerlink" title="CSS 导入方式"></a>CSS 导入方式</h1><ul><li>内联样式 在标签内部使用style属性 属性值是css属性键值对<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> style = <span class="string">&quot;color:red&quot;</span>&gt; Hello World&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></li><li>内部样式 使用&lt;style&gt;标签 在标签内部定义css样式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span> = <span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  &lt;\style&gt;</span></span><br></pre></td></tr></table></figure></li><li>外部样式 定义link标签 引入外部的css文件<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel <span class="operator">=</span> <span class="string">&quot;stylesheet&quot;</span> href <span class="operator">=</span> <span class="string">&quot;demo.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h1></li><li>概念 选择器是选取需设置样式的元素（标签）</li><li>分类<ul><li>元素选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素名称&#123;<span class="attribute">color</span> : red;&#125;</span><br></pre></td></tr></table></figure></li><li>id 选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span>属性值&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></li><li>类选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span>属性值&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><h1 id="CSS-属性"><a href="#CSS-属性" class="headerlink" title="CSS 属性"></a>CSS 属性</h1><a href="https://www.w3school.com.cn/cssref/index.asp">CSS参考手册</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2022/07/10/HTML/"/>
      <url>/2022/07/10/HTML/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>HTML(HyperText Markup Language) 超文本标记语言，除了文字信息还可以定义图片 音频 视频等内容，HTML 运行在浏览器上，其标签由浏览器来解析</p></blockquote><span id="more"></span><h1 id="HTML-快速入门"><a href="#HTML-快速入门" class="headerlink" title="HTML 快速入门"></a>HTML 快速入门</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        页面内容</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>HTML 文件以.html 或者 .htm为扩展名</li><li>HTML标签不区分大小写</li><li>HTML 标签属性值 单双引皆可</li><li>HTML 语法松散<h1 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;h1&gt; &lt;h6&gt;</td><td>定义标题，h1最大，h2最小</td></tr><tr><td>&lt;font&gt;</td><td>定义文本的字体 字体尺寸 字体颜色</td></tr><tr><td>&lt;b&gt;</td><td>定义粗体文本</td></tr><tr><td>&lt;i&gt;</td><td>定义斜体文本</td></tr><tr><td>&lt;u&gt;</td><td>定义文本下划线</td></tr><tr><td>&lt;center&gt;</td><td>定义文本居中</td></tr><tr><td>&lt;p&gt;</td><td>定义段落</td></tr><tr><td>&lt;br&gt;</td><td>定义折行</td></tr><tr><td>&lt;hr&gt;</td><td>定义水平线</td></tr></tbody></table></li></ul><h1 id="图片-视频-音频-标签"><a href="#图片-视频-音频-标签" class="headerlink" title="图片 视频 音频 标签"></a>图片 视频 音频 标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;img&gt;</td><td>定义图片</td></tr><tr><td>&lt;audio&gt;</td><td>定义音频</td></tr><tr><td>&lt;video&gt;</td><td>定义视频</td></tr></tbody></table><ul><li><p>img 定义图片</p><ul><li>src 规定显示图片的URL(统一资源定位符)</li><li>height 定义图像的高度 尺寸单位 px 和 %</li><li>width 定义图像的宽度 尺寸单位 px 和 %</li></ul></li><li><p>audio 定义音频 支持 MP3 WAV OGG</p><ul><li>src 规定音频的URL</li><li>controls 显示播放控件</li></ul></li><li><p>video 定义视频 支持 MP4 WebM OGG</p><ul><li>src 规定视频的URL</li><li>controls 显示播放控件<h1 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;a&gt;</td><td>定义超标签，用于链接到另一个资源</td></tr></tbody></table></li></ul></li><li><p>href 指定访问资源的URL</p></li><li><p>target 指定打开资源的方式</p><ul><li>_self 默认值  在当前也页面打开</li><li>_blank 在空白页打开<h1 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;ol&gt;</td><td>定义有序列表</td></tr><tr><td>&lt;ul&gt;</td><td>定义无序列表</td></tr><tr><td>&lt;li&gt;</td><td>定义列表项</td></tr></tbody></table></li></ul></li><li><p>type 设置项目符号 <strong>不建议使用 一般在css中设置</strong></p></li><li><p>有序列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.内容    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">2.内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容 <span class="tag">&lt;/<span class="name">li</span>&gt;</span>   </span><br><span class="line">3.内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span>          </span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;/<span class="name">ol</span>&gt;</span>       </span><br></pre></td></tr></table></figure></li><li><p>无序列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">· 内容    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">· 内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容 <span class="tag">&lt;/<span class="name">li</span>&gt;</span>   </span><br><span class="line">· 内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span>          </span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">ol</span>&gt;</span>     </span><br></pre></td></tr></table></figure><h1 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;table&gt;</td><td>定义表格</td></tr><tr><td>&lt;tr&gt;</td><td>定义行</td></tr><tr><td>&lt;td&gt;</td><td>定义单元格</td></tr><tr><td>&lt;th&gt;</td><td>定义表头单元格</td></tr></tbody></table></li><li><p>table 定义表格</p><ul><li>border 规定表格边框的宽度</li><li>width 规定表格的宽度</li><li>cellspacing 规定单元格之间的空白</li></ul></li><li><p>tr 定义行</p><ul><li>align 定义表格行的内容对齐方式</li></ul></li><li><p>td 定义单元格</p><ul><li>rowspan 规定单元格可横跨的行数</li><li>colspan 规定单元格可横跨的列数</li></ul></li></ul><h1 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;div&gt;</td><td>定义HTML文档中的一个区域部分，经常与css一起使用，用来布局网页</td></tr><tr><td>&lt;span&gt;</td><td>用于组合行内元素</td></tr></tbody></table><p><strong>与CSS一起使用</strong></p><h1 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;form&gt;</td><td>定义表单</td></tr><tr><td>&lt;input&gt;</td><td>定义表单项，通过type属性控制输入形式</td></tr><tr><td>&lt;label&gt;</td><td>为表单项定义标注</td></tr><tr><td>&lt;select&gt;</td><td>定义下拉列表</td></tr><tr><td>&lt;option&gt;</td><td>定义下拉列表的列表项</td></tr><tr><td>&lt;textarea&gt;</td><td>定义文本域</td></tr></tbody></table><ul><li>表单 在网页中只要负责数据采集功能 使用&lt;form&gt;标签定义表单</li><li>表单项(元素)：不同类型的input元素，下拉列表，文本域等</li><li>form 定义表单<ul><li>action 规定当提交表单时向何处发送表单数据 URL</li><li>method 规定发送表单数据的方式<ul><li>get 浏览器会将数据直接附在表单的action URL之后，大小会有限制</li><li>post 浏览器会将数据放到http请求信息体中。大小无限制</li></ul></li></ul></li></ul><table><thead><tr><th>type取值</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>默认值 定义单行的输入字段</td></tr><tr><td>password</td><td>定义密码字段</td></tr><tr><td>radio</td><td>定义单选按钮</td></tr><tr><td>checkbox</td><td>定义复选框</td></tr><tr><td>file</td><td>定义文件上传按钮</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段</td></tr><tr><td>submit</td><td>定义提交按钮 提交按钮会把表单数据发送到服务器</td></tr><tr><td>reset</td><td>定义重置按钮 该按钮会清除表达中的所有数据</td></tr><tr><td>button</td><td>定义可点击按钮</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2022/07/09/MyBatis/"/>
      <url>/2022/07/09/MyBatis/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>MyBatis 是一款优秀的持久层框架，用于简化JDBC开发</p></blockquote><span id="more"></span><ul><li><p>持久层</p><ul><li>负责将数据保存到数据库的那一层代码</li><li>JavaEE三层架构：表现层，业务层，持久层</li></ul></li><li><p>框架</p><ul><li>框架就是一个半成品软件，是一套可重用的，通用的 软件基础代码模型</li><li>在框架的基础之上构建软件编写更加高效 规范 通用 可扩展</li></ul></li></ul><h1 id="JDBC-缺点"><a href="#JDBC-缺点" class="headerlink" title="JDBC 缺点"></a>JDBC 缺点</h1><ul><li>硬编码        <ul><li>注册驱动，获取连接</li><li>SQL语句</li></ul></li><li>操作繁琐<ul><li>手动设置参数</li><li>手动封装结果集</li></ul></li></ul><p><strong>MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作，硬编码可通过配置文件的方式完成</strong></p><h1 id="MyBatis-快速入门"><a href="#MyBatis-快速入门" class="headerlink" title="MyBatis 快速入门"></a>MyBatis 快速入门</h1><h2 id="查询表中所有数据"><a href="#查询表中所有数据" class="headerlink" title="查询表中所有数据"></a>查询表中所有数据</h2><ul><li>创建表  添加数据</li><li>创建模块 导入坐标</li><li>编写MyBatis 核心配置文件 –&gt; 替换连接信息 解决硬编码问题</li><li>编写SQL映射文件 –&gt; 统一管理sql语句 解决硬编码问题</li><li>编码<ul><li>定义POJO类</li><li>加载核心配置文件，获取SqlSessionFactory 对象</li><li>获取SqlSession 对象，执行SQL语句</li><li>释放资源<h2 id="解决SQL映射文件的警告提示"><a href="#解决SQL映射文件的警告提示" class="headerlink" title="解决SQL映射文件的警告提示"></a>解决SQL映射文件的警告提示</h2></li></ul></li><li>产生原因：Idea和数据库没有建立连接 不识别表信息</li><li>解决方式；在Idea中配置MySQL数据库连接 <h1 id="Mapper-代理开发"><a href="#Mapper-代理开发" class="headerlink" title="Mapper 代理开发"></a>Mapper 代理开发</h1></li><li>目的<ul><li>解决原生方式的硬编码</li><li>简化后期执行SQL<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2></li></ul></li><li>定义与SQL映射文件同名的Mapper接口，并将Mapper接口的SQL映射文件放置在同一目录下</li><li>设置SQL映射文件的namespace属性为Mapper接口全限定名</li><li>在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致</li><li>编码<ul><li>通过SqlSession的getMapper方法获取Mapper接口的代理对象</li><li>通过对应方法完成sql的执行</li></ul></li></ul><p><strong>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载</strong></p><h1 id="Mybatis-核心配置文件"><a href="#Mybatis-核心配置文件" class="headerlink" title="Mybatis 核心配置文件"></a>Mybatis 核心配置文件</h1><p><a href="https://mybatis.net.cn/configuration.html">MyBatis官方文档</a></p><h1 id="配置文件完成增删改查"><a href="#配置文件完成增删改查" class="headerlink" title="配置文件完成增删改查"></a>配置文件完成增删改查</h1><h2 id="查询映射"><a href="#查询映射" class="headerlink" title="查询映射"></a>查询映射</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>resultMap id<span class="operator">=</span>&quot;无要求&quot; type<span class="operator">=</span>&quot;封装类名&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="comment">-- id 是主键字段的映射</span></span><br><span class="line">    <span class="comment">-- result 是其他字段的映射</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">result</span> <span class="keyword">column</span><span class="operator">=</span>&quot;列名&quot; property<span class="operator">=</span>&quot;别名&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">result</span> <span class="keyword">column</span><span class="operator">=</span>&quot;列名&quot; property<span class="operator">=</span>&quot;别名&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>resultMap<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;selectOne&quot; resultMap<span class="operator">=</span>&quot;无要求&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h2 id="MyBatisX插件"><a href="#MyBatisX插件" class="headerlink" title="MyBatisX插件"></a>MyBatisX插件</h2><blockquote><p>MyBatisX 是一款基于IDEA的快速开发插件 为效率而生</p></blockquote><ul><li>功能<ul><li>XML 和接口方法相互跳转</li><li>根据接口方法生成statement</li><li>安装<blockquote><p>在IDEA中的Plugin中搜索即可</p></blockquote></li></ul></li></ul><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ul><li>在定义的Mapper接口中写出需要实现的接口映射</li><li>利用插件的快捷方式在xml文件中编写对应的sql语句</li><li>id 需要与 接口名字相同</li><li>参数接收<ul><li>#{}   会将其替换为？，防止SQL注入</li><li>${}  拼sql 会有SQL注入问题</li></ul></li><li>转义<ul><li>CDATA 区  会将区域内的当作纯文本处理    CD提示</li><li>查询对应字符在xml的转义</li></ul></li><li>多个参数的接受<ul><li>散装参数：使用@Param(“SQL参数占位符名称”)</li><li>对象参数 对象的属性名称要和参数占位符名称一致</li><li>map map的key值要与参数占位符名称一致</li></ul></li><li>使用where 标签 并且 条件前都得加上and</li><li>默认开启事务 需要手动提交</li><li>获取主键id  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">useGeneratedKeys</span> <span class="operator">=</span> </span><br><span class="line">true<span class="string">&quot; keyProperty = &quot;</span>id<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li><li>删除 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delete <span class="keyword">from</span> 表名 <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (</span><br><span class="line">    &lt;foreach collection = <span class="string">&quot;arrays(或者用Param注解改变名称)&quot;</span> <span class="built_in">item</span> = <span class="string">&quot;id&quot;</span> separator=<span class="string">&quot;,&quot;</span>(分隔符)&gt;</span><br><span class="line">    <span class="comment">#&#123;id&#125;</span></span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h1 id="注解完成增删改查"><a href="#注解完成增删改查" class="headerlink" title="注解完成增删改查"></a>注解完成增删改查</h1><blockquote><p>注解用来完成简单的工作  配置文件用来完成复杂的工作</p></blockquote><ul><li>查询 @Select</li><li>添加 @Insert</li><li>修改 @Update</li><li>删除 @Delete<h1 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h1><a href="https://mybatis.net.cn/dynamic-sql.html">MyBatis官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2022/07/08/Maven/"/>
      <url>/2022/07/08/Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Apache Maven 是一个项目管理和构建工具，基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建，报告和文档</p></blockquote><span id="more"></span><ul><li>提供了一套标准的项目结构<blockquote><p>在不同的IDE中的项目结构并不相同，Maven提供了一套标准化的项目，以便在不同的IDE中通用</p></blockquote></li><li>提供了一套标准化的构建流程(编译，测试，打包，发布…)</li><li>提供了一套依赖管理机制<blockquote><p>依赖管理就是管理你项目所依赖的第三方资源(jar包。插件…)</p></blockquote></li></ul><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><ul><li>解压 apache-maven-3.6.1.rar 即安装完成</li><li>配置环境变量 MAVEN_HOME 为安装路径的bin目录</li><li>配置本地仓库：修改conf&#x2F;settings.xml中的&lt;localRepository&gt;为一个指定目录</li><li>配置阿里云私服，修改conf&#x2F;settings.xml中的&lt;mirrors&gt;标签，为其添加如下子标签<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>compile 编译</li><li>clean 清理</li><li>test 测试</li><li>package 打包</li><li>install 安装<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2></li><li>Maven 构建项目生命周期描述是一次构建过程经历经历了多少个事件</li><li>Maven 对项目构建的生命周期划分为3套<ul><li>clean 清理工作</li><li>default 核心工作 例如编译 测试 打包 安装等</li><li>site 产生报告 发布站点</li></ul></li></ul><p><strong>同一生命周期内，执行后边的命令，前边的所有命令会自动执行</strong></p><h1 id="IDEA-配置Maven"><a href="#IDEA-配置Maven" class="headerlink" title="IDEA 配置Maven"></a>IDEA 配置Maven</h1><h2 id="IDEA-配置Maven-环境"><a href="#IDEA-配置Maven-环境" class="headerlink" title="IDEA 配置Maven 环境"></a>IDEA 配置Maven 环境</h2><ul><li>选择 IDEA 中 File –&gt; Settings</li><li>搜索 maven</li><li>设置 IDEA 使用本地安装的Maven，并修改配置文件路径<h2 id="Maven-坐标详解"><a href="#Maven-坐标详解" class="headerlink" title="Maven 坐标详解"></a>Maven 坐标详解</h2></li><li>什么是坐标<ul><li>Maven 中的坐标是资源的唯一标识</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul></li><li>Maven 坐标主要组成<ul><li>groupId 定义当前Maven项目隶属组织名称(通常是域名反写 如: com.itheima)</li><li>artifactId 定义当前Maven项目名称(通常是模块名称 如 order-service goods-service)</li><li>version 定义当前项目版本号</li></ul></li></ul><h2 id="IDEA-创建-Maven-项目"><a href="#IDEA-创建-Maven-项目" class="headerlink" title="IDEA 创建 Maven 项目"></a>IDEA 创建 Maven 项目</h2><ul><li>创建模块 选择Maven 点击Next</li><li>填写模块名称 坐标信息 点击finish 创建完成</li><li>编写程序<h2 id="IDEA-导入-Maven-项目"><a href="#IDEA-导入-Maven-项目" class="headerlink" title="IDEA 导入 Maven 项目"></a>IDEA 导入 Maven 项目</h2></li><li>选择右侧Maven面板 点击 + 号</li><li>选中对应项目的pom.xml文件，双击即可</li><li>如果没有Maven面板 选择View -&gt; Appearance -&gt; Tool Window Bars</li></ul><h2 id="配置Maven-Helper-插件"><a href="#配置Maven-Helper-插件" class="headerlink" title="配置Maven-Helper 插件"></a>配置Maven-Helper 插件</h2><ul><li>选择IDEA 中 File -&gt; Settings</li><li>选择 Plugins</li><li>搜索 Maven</li><li>安装 Maven Helper </li><li>重启IDEA</li></ul><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><h2 id="使用坐标导入jar包"><a href="#使用坐标导入jar包" class="headerlink" title="使用坐标导入jar包"></a>使用坐标导入jar包</h2><ul><li>在pom.xml 中编写&lt;dependencies&gt;标签</li><li>在&lt;dependencies&gt; 标签中使用&lt;dependency&gt;引入坐标</li><li>定义坐标的 groupId artifactId version</li><li>点击刷新按钮 使坐标生效<h2 id="使用坐标导入jar包-快捷方式"><a href="#使用坐标导入jar包-快捷方式" class="headerlink" title="使用坐标导入jar包 -快捷方式"></a>使用坐标导入jar包 -快捷方式</h2></li><li>在pom.xml 中按alt + insert，选择Dependency</li><li>在弹出的面板中搜索对应坐标，双击选中</li><li>点击刷新按钮 使坐标生效</li></ul><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><ul><li><p>通过设置坐标的依赖范围(scope)，可以设置对jar包的作用范围：编译环境 测试环境 运行环境</p><table><thead><tr><th>依赖范围</th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例子</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td>system</td><td>Y</td><td>Y</td><td>-</td><td>存储在本地的jar包</td></tr></tbody></table></li><li><p>&lt;scope&gt; 默认值  compile</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2022/07/07/JDBC-1/"/>
      <url>/2022/07/07/JDBC-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>JDBC (Java DataBase Connectivity) 就是使用Java语言操作数据库的一套API</p></blockquote><span id="more"></span><h1 id="JDBC-快速入门"><a href="#JDBC-快速入门" class="headerlink" title="JDBC 快速入门"></a>JDBC 快速入门</h1><ul><li>创建工程，导入jar包</li><li>注册驱动<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获取连接<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = <span class="module-access"><span class="module"><span class="identifier">DriverManager</span>.</span></span>get<span class="constructor">Connection(<span class="params">url</span>,<span class="params">usename</span>,<span class="params">password</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>定义SQL语句<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql <span class="operator">=</span> <span class="string">&quot;update...&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>获取执行SQL对象<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt conn.createStatement()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>执行SQL<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt.execute<span class="constructor">Update(<span class="params">sql</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>处理返回结果</li><li>释放资源</li></ul><h1 id="API-详解"><a href="#API-详解" class="headerlink" title="API 详解"></a>API 详解</h1><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><ul><li>作用<ul><li>注册驱动<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">-- Driver 类源码</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="type">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>MYSQL 5之后的驱动包，可以省略注册驱动的步骤，会自动加载jar包中META-INF&#x2F;services&#x2F;java.sql.Driver文件中的驱动类</strong></li><li>获取数据库连接<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Connection   <span class="title">getConnection</span><span class="params">(<span class="type">String</span> url,<span class="type">String</span> user,<span class="type">String</span> password)</span></span></span><br></pre></td></tr></table></figure><ul><li>url : 连接路径<blockquote><p>语法：jdba:mysql:&#x2F;&#x2F;ip地址（域名）:端口号&#x2F;数据库名称？参数键值对1&amp;参数键值对2…<br><br>示例:jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;kris<br><br>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称？键值对<br>配置useSSL &#x3D; false 参数，禁用安全连接方式，解决警告提示</p></blockquote></li><li>user ：用户名</li><li>password ：密码</li></ul></li></ul></li></ul><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ul><li>作用<ul><li>获取执行SQL的对象<ul><li>执行普通SQL对象  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Statement</span> <span class="function"><span class="title">createStatement</span>()</span></span><br></pre></td></tr></table></figure></li><li>预编译SQL的执行SQL对象：防治SQL注入  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">PreparedStatement</span> <span class="function"><span class="title">prepareStatement</span>(<span class="variable">sql</span>)</span></span><br></pre></td></tr></table></figure></li><li>执行存储过程的对象  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">CallableStatement</span> <span class="function"><span class="title">prepareCall</span>(<span class="variable">sql</span>)</span></span><br></pre></td></tr></table></figure></li></ul></li><li>管理事务<ul><li>MYSQL 事务管理  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启事务：begin<span class="comment">;</span></span><br><span class="line">提交事务：commit<span class="comment">;</span></span><br><span class="line">回滚事务：rollback<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">MYSQL自动提交事务</span><br></pre></td></tr></table></figure></li><li>JDBC 事务管理  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启事务：<span class="function"><span class="title">setAutoCommit</span>(<span class="variable">boolean</span> <span class="variable">autoCommit</span>):<span class="variable"><span class="literal">true</span></span>为自动提交，<span class="variable"><span class="literal">false</span></span>为手动提交，即为开始事务</span></span><br><span class="line"><span class="function">提交事务：<span class="title">commit</span>()</span></span><br><span class="line">回滚事务：<span class="function"><span class="title">rollback</span>()</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><ul><li>作用<ul><li>执行SQL语句<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> execute<span class="constructor">Update(<span class="params">sql</span>)</span>; <span class="comment">//执行DML DDL语句</span></span><br><span class="line">返回值：<span class="number">1</span> DML语句影响的行数 <span class="number">2</span> DDL语句执行后，执行成功也可能返回<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ResultSet</span> executeQuery(sql): 执行DQL语句</span><br><span class="line">返回值：<span class="keyword">ResultSet</span> 结果集对象</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><ul><li>作用<ul><li>封装了DQL查询语句的结果<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet stmt.execute<span class="constructor">Query(<span class="params">sql</span>)</span>; <span class="comment">//执行DQL语句，返回ResultSet对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li>获取查询结果<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">boolean</span> <span class="keyword">next</span>(): <span class="number">1</span> 将光标从当前位置向前移动一行 <span class="number">2</span> 判断当前行是否为有效行</span><br><span class="line">返回值</span><br><span class="line">  <span class="literal">true</span> ：有效行，当前行有数据</span><br><span class="line">  <span class="literal">false</span> ： 无效行，当前行没有数据</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xxx getXxx(参数)  <span class="comment">//获取数据</span></span><br><span class="line">  xxx 数据类型 如<span class="built_in">int</span> getInt（参数）</span><br><span class="line">  参数  </span><br><span class="line">      <span class="built_in">int</span> 列的编号 从<span class="number">1</span>开始</span><br><span class="line">      <span class="built_in">String</span> 列的名称</span><br></pre></td></tr></table></figure></li></ul><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><ul><li><p>作用</p><ul><li>预编译SQL语句并执行：预防SQL注入问题</li></ul></li><li><p>SQL注入</p><ul><li>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</li></ul></li><li><p>获取 PreparedStatement 对象</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">SQL</span> 语句中的参数值，使用？占位符替代</span><br><span class="line">String <span class="keyword">sql</span> = &quot;select * from username = ? and password = ?&quot;;</span><br><span class="line"></span><br><span class="line">//通过<span class="keyword">Connection</span> 对象获取，并传入对应的<span class="keyword">SQL</span>语句</span><br><span class="line">PreparedStatement pstmt = conn.prepareStatement(<span class="keyword">sql</span>);</span><br></pre></td></tr></table></figure></li><li><p>设置参数值</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement对象：<span class="keyword">set</span>Xxx（参数1，参数2）：给 ？ 赋值</span><br><span class="line">Xxx：数据类型</span><br><span class="line">参数：</span><br><span class="line">  参数1：？的位置编号，从1开始</span><br><span class="line">  参数2：？的值</span><br></pre></td></tr></table></figure></li><li><p>执行SQL</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executeUpdate<span class="comment">()</span>;/executeQuery<span class="comment">()</span>; : 不需要再传递SQL</span><br></pre></td></tr></table></figure></li><li><p>好处</p><ul><li>预编译SQL 性能更高</li><li>防止SQL注入，将敏感字符转义</li></ul></li><li><p>原理</p><ul><li>在获取PreparedStatement对象时，将SQL语句发送给MYSQL服务器进行检查，编译</li><li>执行时就不用再进行这些步骤，速度更快</li><li>如果SQL模板一样，则只需要进行一次检查，编译</li></ul></li></ul><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul><li>数据库连接池是个容器，负责分配，管理数据库连接</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</li><li>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</li><li>好处<ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li></ul><h2 id="数据库连接池实现"><a href="#数据库连接池实现" class="headerlink" title="数据库连接池实现"></a>数据库连接池实现</h2><ul><li>标准接口 ：DataSource<ul><li>官方(SUN)提供的数据库连接池标准接口，由第三方组织实现此接口。</li><li>功能： 获取连接<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Connection</span> <span class="function"><span class="title">getConnection</span>()</span></span><br></pre></td></tr></table></figure></li></ul></li><li>常见的数据库连接池：<ul><li>D8CP</li><li>C3P0</li><li>Druid</li></ul></li><li>Druid(德鲁伊)<ul><li>Druid连接池是阿里巴巴开源的数据库连接池项目</li><li>功能强大，性能优秀，是Java语言最好的数据库连接池之一</li></ul></li></ul><h2 id="Druid-使用步骤"><a href="#Druid-使用步骤" class="headerlink" title="Druid 使用步骤"></a>Druid 使用步骤</h2><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//druid.properties</span><br><span class="line"><span class="attribute">driverClassName</span> <span class="operator">=</span> com.mysql.jdbc.Driver</span><br><span class="line"><span class="attribute">url</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="attribute">username</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="attribute">password</span> <span class="operator">=</span> ...</span><br><span class="line">//初始话连接数量</span><br><span class="line"><span class="attribute">initialSize</span> <span class="operator">=</span> ...</span><br><span class="line">//最大连接数量</span><br><span class="line"><span class="attribute">maxActive</span> <span class="operator">=</span> ...</span><br><span class="line">// 最大等待时间</span><br><span class="line"><span class="attribute">maxWait</span> <span class="operator">=</span> ...</span><br></pre></td></tr></table></figure></li><li>加载配置文件<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>));</span><br></pre></td></tr></table></figure></li><li>获取数据库连接池对象<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = <span class="module-access"><span class="module"><span class="identifier">DruidDataSourceFactory</span>.</span></span>create<span class="constructor">DataSource(<span class="params">prop</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获取连接<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection <span class="operator">=</span> dataSource.getConnection()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL---(3)</title>
      <link href="/2022/07/06/MYSQL-3/"/>
      <url>/2022/07/06/MYSQL-3/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>  SQL（Structured Query Language）,结构化查询语言，一门操作关系型数据库的编程语言，定义操作所有<a href="https://cn.bing.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&qs=SC&pq=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&sk=SC1&sc=8-6&cvid=959A8ABF9CB1416DB320362EC1B3BA5A&FORM=QBRE&sp=2">关系型数据库</a>的统一标准。不同数据库操作的方式可能存在一些不一样的地方</p><span id="more"></span><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>约束是作用于表中列上的规则，用于限制加入表的数据</li><li>约束的存在保证了数据库中数据的正确性，有效性和完整性</li></ul><h2 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h2><table><thead><tr><th>约束名称</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>保证列中数据不能有null值</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证列中所有数据各不相同</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>检查约束</td><td>保证列中的值满足某一条件</td><td>CHECK</td></tr><tr><td>默认约束</td><td>保存数据时，未指定值则采用默认值</td><td>DEFAULT</td></tr><tr><td>外键约束</td><td>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>MYSQL不支持检查约束</li><li>多个约束并排写中间空格</li><li>auto_increment 自增长 (当列是数字并且唯一约束)</li></ul><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3></li><li>添加约束  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加外键约束</span></span><br><span class="line">creat <span class="keyword">table</span> 表名(</span><br><span class="line">列名 数据类型;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key(外键列名) refereinces 主表(主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表后添加外键约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key （外键字段名称） <span class="keyword">references</span> 主表名称（主表列名称）;</span><br></pre></td></tr></table></figure></li><li>删除约束  <figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> 外键名称;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h3><ul><li>先建主表后建从表才能添加外键</li><li>外键名称一般为fk开头链接两关联主表的字段名称</li></ul><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ul><li>根据业务系统的具体需求，结合所选用的DBMS，为这个业务系统构造出最优的数据存储模型。</li><li>建立数据库中的表结构以及表与表之间的关联关系的过程。</li></ul><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><ul><li>需求分析 </li><li>逻辑分析</li><li>物理设计</li><li>维护设计</li></ul><h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h2><ul><li>一对一<ul><li>用户和用户详情</li><li>用于表拆分和提升查询性能</li><li><strong>实现方式</strong>：唯一外键</li></ul></li><li>一对多<ul><li>部门和员工</li><li><strong>实现方式</strong> ： 在多的一方建立外键，指向一的一方的主键</li></ul></li><li>多对多<ul><li>商品和订单</li><li><strong>实现方式</strong> ： 建立第三张中间表，中间表至少包含两个外键，分别对应两方主键</li></ul></li></ul><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><pre><code>相当于查询A B表交集数据</code></pre><ul><li><p>语法</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式内连接</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>，表<span class="number">2.</span>.. <span class="keyword">where</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示外连接</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> [<span class="keyword">inner</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3></li><li><p>语法</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 左外连接</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件;</span><br><span class="line"></span><br><span class="line">-- 右外连接</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure></li><li><p>左外连接</p><blockquote><p>相当于查询A表所有数据和交集部分数据</p></blockquote></li><li><p>右外连接</p><blockquote><p>相当于查询B表所有数据和交集部分数据</p></blockquote><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2></li><li><p>概念</p><blockquote><p>查询中嵌套查询 称为子查询</p></blockquote></li><li><p>根据查询结果不同，作用不同</p><ul><li>单行单列  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表 <span class="keyword">where</span> 字段名 = （子查询）;</span><br></pre></td></tr></table></figure></li><li>多行单列  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表 <span class="keyword">where</span> 字段名 <span class="keyword">in</span> （子查询）;</span><br></pre></td></tr></table></figure></li><li>多行多列 ： 作为虚拟表  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> （子查询） <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>数据库的事务(Transaction) 是一种机制 一个操作序列，包含了一组数据库操作命令</li><li>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败</li><li>事务是一个不可分割的工作逻辑单元</li></ul><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 回滚事务 </span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h2 id="事务的四大特征"><a href="#事务的四大特征" class="headerlink" title="事务的四大特征"></a>事务的四大特征</h2><ul><li>原子性(Atomictity): 事务是不可分割的最小操作单位，要么同时成功，要么同时失败</li><li>一致性(Consistency): 事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性(Isolation): 多个事务之间，操作的可见性</li><li>持久性(Durability): 事务一但提交或回滚，它对数据库中的数据的该表就是永久的</li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL---(2)</title>
      <link href="/2022/07/05/MYSQL-2/"/>
      <url>/2022/07/05/MYSQL-2/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>  SQL（Structured Query Language）,结构化查询语言，一门操作关系型数据库的编程语言，定义操作所有<a href="https://cn.bing.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&qs=SC&pq=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&sk=SC1&sc=8-6&cvid=959A8ABF9CB1416DB320362EC1B3BA5A&FORM=QBRE&sp=2">关系型数据库</a>的统一标准。不同数据库操作的方式可能存在一些不一样的地方</p><span id="more"></span><h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><blockquote><p>Data Query Language 数据查询语言，用于查询数据库中表的数据</p></blockquote><h2 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  字段列表</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  表名列表</span><br><span class="line"><span class="keyword">where</span>      <span class="comment">-- 条件查询 </span></span><br><span class="line">  条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>   <span class="comment">--分组查询</span></span><br><span class="line">  分组字段</span><br><span class="line"><span class="keyword">having</span> </span><br><span class="line">  分组后条件</span><br><span class="line">orded <span class="keyword">by</span>   <span class="comment">--排序查询</span></span><br><span class="line">  排序字段</span><br><span class="line"><span class="keyword">limit</span>      <span class="comment">--分页查询</span></span><br><span class="line">  分页限定</span><br></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><ul><li>去除重复记录<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> distinct <span class="params">...</span> from <span class="params">...</span></span><br></pre></td></tr></table></figure></li><li>起别名<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 <span class="keyword">as</span> （可省略用空格隔开） 别名</span><br></pre></td></tr></table></figure></li></ul><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ul><li><p>语法</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span>条件列表;</span><br></pre></td></tr></table></figure></li><li><p>条件</p><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>between…and…</td><td>在某个范围之间</td></tr><tr><td>in(…)</td><td>多选一</td></tr><tr><td>like 占位符</td><td>模糊查询，_表示任意单个字符，%表示多个任意字符</td></tr><tr><td>is NULL</td><td>是NULL</td></tr><tr><td>is not NULL</td><td>不是NULL</td></tr><tr><td>and</td><td>并且</td></tr><tr><td>or</td><td>或者</td></tr><tr><td>nor</td><td>非</td></tr></tbody></table></li></ul><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><ul><li><p>语法</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 排序字段名<span class="number">1</span> 排序方式<span class="number">1</span>，...;</span><br></pre></td></tr></table></figure></li><li><p>排序方式</p><ul><li>ASC : 升序排列 （默认）</li><li>DESC : 降序排列</li></ul><p><em><strong>如果有多个排序条件，当前边条件值一样时，才根据第二条件进行排序</strong></em></p></li></ul><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ul><li>语法<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 分组前条件限定] <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名 [<span class="keyword">having</span> 分组后条件过滤];</span><br></pre></td></tr></table></figure><strong>分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</strong></li></ul><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><blockquote><p>将一列数据作为一个整体，进行纵向计算</p></blockquote><ul><li><p>分类</p><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>count(列名)</td><td>统计数量(一般选用不为null的列)</td></tr><tr><td>max(列名)</td><td>最大值</td></tr><tr><td>min(列名)</td><td>最小值</td></tr><tr><td>sum(列名)</td><td>求和</td></tr><tr><td>avg(列名)</td><td>平均值</td></tr></tbody></table></li><li><p>语法</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 聚合函数名（列名） <span class="keyword">from</span> 表;</span><br></pre></td></tr></table></figure></li></ul><p><em><strong>null值不参与所有聚合函数运算</strong></em></p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ul><li>语法<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">limit</span> 起始索引，查询条目数;</span><br></pre></td></tr></table></figure><strong>起始索引从0开始</strong><br><strong>计算公式：起始索引 &#x3D; （当前页码-1）* 每页显示的条数</strong></li><li>tips<ul><li>分页查询limit是MYSQL数据库特有</li><li>Oracle 分页查询使用 rownumber</li><li>SQL Sever 使用top</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL---(1)</title>
      <link href="/2022/07/04/MYSQL-1/"/>
      <url>/2022/07/04/MYSQL-1/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>  SQL（Structured Query Language）,结构化查询语言，一门操作关系型数据库的编程语言，定义操作所有<a href="https://cn.bing.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&qs=SC&pq=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&sk=SC1&sc=8-6&cvid=959A8ABF9CB1416DB320362EC1B3BA5A&FORM=QBRE&sp=2">关系型数据库</a>的统一标准。不同数据库操作的方式可能存在一些不一样的地方</p><span id="more"></span><h1 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h1><ul><li><p>SQL语句可以多行或者单行书写，以分号结尾。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">database</span>;   </span><br></pre></td></tr></table></figure></li><li><p>MySQL 数据库的SQL语句不区分大小写，关键字建议大写</p></li><li><p>注释</p><ul><li>单行注释： – 注释内容 或者 #注释内容（MYSQL特有）</li><li>多行注释：&#x2F;* 注释 *&#x2F;</li></ul></li></ul><h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><blockquote><p>Data Definition Language  数据定义语言，用来定义数据库对象；数据库，表，列等</p></blockquote><h2 id="操作库"><a href="#操作库" class="headerlink" title="操作库"></a>操作库</h2><ul><li><p>查询</p>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据库</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>创建数据库（判断，如果不存在则创建）</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>删除数据库</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>查看当前使用的数据库</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">database</span>()</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用数据库</p>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名称<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><ul><li>查询表<ul><li>查询当前数据库下所有表名称  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure></li><li>查询表结构  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名称</span><br></pre></td></tr></table></figure></li></ul></li><li>创建表  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    字段名<span class="number">1</span> 数据类型<span class="number">1</span>，</span><br><span class="line">    字段名<span class="number">2</span> 数据类型<span class="number">2</span>，</span><br><span class="line">    <span class="comment">----</span></span><br><span class="line">    字段名n 数据类型n  <span class="comment">/*最后不加逗号*/</span></span><br><span class="line">)；</span><br></pre></td></tr></table></figure></li><li>删除表  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> 表名称;</span><br></pre></td></tr></table></figure></li><li>修改表<ul><li>修改表名  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">rename</span> <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure></li><li>添加一列  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 数据类型;</span><br></pre></td></tr></table></figure></li><li>修改数据类型  <figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 列名 新数据类型;</span><br></pre></td></tr></table></figure></li><li>修改列名和数据类型  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter <span class="keyword">table</span> 表名 change 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure></li><li>删除列  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><blockquote><p>Data Manipulation Language 数据操作语言，是指在SQL语言中，负责对数据库对象运行数据访问工作的指令集。</p></blockquote><ul><li>添加数据<ul><li>给指定列表添加数据  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">insert</span> into 表名（列名<span class="number">1</span>，列名<span class="number">2</span>，...） values(值<span class="number">1</span>，值<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li>给全部列添加数据  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span> ...);<span class="comment">-- 按照列的顺序添加值;</span></span><br></pre></td></tr></table></figure></li><li>批量添加数据  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">insert</span> into 表名(列<span class="number">1</span>，列<span class="number">2</span>，...) values(值<span class="number">1</span>，值<span class="number">2</span>，...),(值<span class="number">1</span>，值<span class="number">2</span>，...)...;</span><br><span class="line"></span><br><span class="line"><span class="attribute">insert</span> into 表名 values(值<span class="number">1</span>，值<span class="number">2</span>...),(值<span class="number">1</span>，值<span class="number">2</span>...);</span><br></pre></td></tr></table></figure></li></ul></li><li>修改数据  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 <span class="keyword">set</span> 列名<span class="number">1</span> = 值<span class="number">1</span>，列名<span class="number">2</span> = 值<span class="number">2</span>，...[<span class="keyword">where</span> 条件]<span class="punctuation">;</span><span class="comment">(***不加条件，所有数据都会修改！***)</span></span><br></pre></td></tr></table></figure></li><li>删除数据  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]<span class="punctuation">;</span><span class="comment">(***不加则所有数据都会被删除***)</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 注解</title>
      <link href="/2022/05/07/Java-%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/05/07/Java-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是注解-Annotation"><a href="#什么是注解-Annotation" class="headerlink" title="什么是注解(Annotation)"></a>什么是注解(Annotation)</h1><blockquote><p>代码的特殊标识，可以在编译，类加载，运行时被读取，并执行相对应的处理，以便于其他工具补充信息或者进行部署</p></blockquote><span id="more"></span><h1 id="内注解"><a href="#内注解" class="headerlink" title="内注解"></a>内注解</h1><ul><li><p>@Override - 检查该方法是否是重写方法，如果发现其父类，或者是应用的接口中并没有该方法时，会报编译错误</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//将会报编译错误</span></span><br><span class="line">    void say()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Deprecated - 标记过时方法。如果使用该方法，将会报编译警告</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">     son s = <span class="keyword">new</span> <span class="title function_">son</span>();</span><br><span class="line">     <span class="comment">//使用时会显示已废弃 </span></span><br><span class="line">     s.<span class="title function_">say</span>();</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@SuppressWarnings - 指示编译器忽略注解中声明的警告 该注解需要传入参数</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">    deprecation:</span> 使用了不赞成使用的类或方法时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    unchecked:</span> 执行了未检查的转换时的警告，例如当使用了集合时没有用泛型(Generics)来指定集合保存的类型</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    fallthrough:</span> 当switch程序块直接通往下一种情况而没有使用break时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    path:</span> 在类路径 源文件路径等中有不存在的路径时的警告</span><br><span class="line"><span class="symbol">   </span></span><br><span class="line"><span class="symbol">    serial:</span> 当在可序列化的类上缺少serialVersionUID定义时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    finally:</span> 任何finally子句不能正常完成时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    all:</span> 关于以上所有情况的警告</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">// 消除了age没有使用的警告</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">son</span>();</span><br><span class="line">    s.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><blockquote><p>作用在其他注解的注解</p></blockquote><ul><li><p>@Retention - 标识这个注解如何保存，是在代码中，还是编译进class中，或者实在运行时可以通过反射访问</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation</span><br><span class="line"><span class="keyword">public</span> enum RetentionPolicy &#123;</span><br><span class="line">   <span class="comment">//Annotation信息仅存在于编译器处理期间</span></span><br><span class="line">   <span class="comment">//编译器处理完之后就没有该Annotation信息</span></span><br><span class="line">    <span class="keyword">SOURCE</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Annotation信息存储于类对应的class文件之中 (默认)</span></span><br><span class="line">    <span class="keyword">CLASS</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Annotation信息存储于class文件中，并且可由JVM读入</span></span><br><span class="line">    <span class="keyword">RUNTIME</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Documented - 标记这个注解是否包含在用户文档中</p></li><li><p>Target - 标记这个注解一个是哪种java成员</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package java.lang.annotation</span><br><span class="line">public enum ElementType &#123;</span><br><span class="line">      <span class="regexp">//</span>类，接口(包括注释类型) 枚举 </span><br><span class="line">      TYPE,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>字段声明(包括枚举变量)</span><br><span class="line">      FIELD,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>方法声明</span><br><span class="line">      METHOD,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>参数声明</span><br><span class="line">      PARAMETER,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>构造方法声明</span><br><span class="line">      CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>局部变量声明</span><br><span class="line">      LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>注释类型声明</span><br><span class="line">      ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>包声明</span><br><span class="line">      PACKAGE,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>@Inherited - 标记这个注解是继承于哪个注解类(默认注解并没有继承于任何子类)</p></li></ul><h1 id="Annotation的通用定义"><a href="#Annotation的通用定义" class="headerlink" title="Annotation的通用定义"></a>Annotation的通用定义</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Target</span>(ElementType TYPE)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> MyAnnotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@interface 使用@interface 定义注解时，意味着它实现了java.lang.annotation.Annotation 接口，即该注解就是一个Anonotation<br></li><li>定义注解时，@interface 时必须的</li><li>Annotation 接口的实现细节都由编译器完成 通过@interface 定义注解后，该注解不能继承其他注解或接口</li></ul><h1 id="新增接口-java-7-后"><a href="#新增接口-java-7-后" class="headerlink" title="新增接口(java 7 后)"></a>新增接口(java 7 后)</h1><ul><li>SafeVarargs - 忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告</li><li>FunctionalInterface - 标识一个匿名函数或者函数式接口</li><li>Repeatable - 标识某注解可以在同一个声明上使用多次</li></ul><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://www.runoob.com/w3cnote/java-annotation.html">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射</title>
      <link href="/2022/05/04/Java-%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/05/04/Java-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射概述（Reflection）"><a href="#反射概述（Reflection）" class="headerlink" title="反射概述（Reflection）"></a>反射概述（Reflection）</h1><blockquote><p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。</p></blockquote><span id="more"></span><h1 id="反射机制的作用"><a href="#反射机制的作用" class="headerlink" title="反射机制的作用"></a>反射机制的作用</h1><blockquote><ul><li>在运行程序时构造任意一个已知类名称的对象</li><li>在运行时获取或调用类的属性和方法</li><li>生成动态代理</li></ul></blockquote><h2 id="获取类名的三种方式"><a href="#获取类名的三种方式" class="headerlink" title="获取类名的三种方式"></a>获取类名的三种方式</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">package</span> test01;</span><br><span class="line">    <span class="keyword">class</span> test&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">//第一种 通过对象的getClass()方法        Person p1 = new Person();</span></span><br><span class="line">        <span class="keyword">Class</span> c1 = p1.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种 通过类名.class的方式得到，最安全，性能最高，说明每个类都有一个隐藏的静态成员变量class</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">Class</span> c2 = Person.<span class="keyword">class</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种 通过Class对象的forName()静态方法获取，最常用，需要抛出ClassNotFound 异常</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">Class</span> c3 = <span class="keyword">Class</span>.forName(<span class="string">&quot;test01.Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>注意</strong></em>：一个类在JVM中只存在一个Class实例，所以以上c1&#x3D;c2&#x3D;c3</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//共有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    Person()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Person(String name,<span class="built_in">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class中的各种方法"><a href="#Class中的各种方法" class="headerlink" title="Class中的各种方法"></a>Class中的各种方法</h2><p><img src="/../../themes/next/source/images/ClassFunction.png"><br></p><ul><li>getName()：获得类的完整名字。</li><li>getFields()：获得类的public类型的属性。</li><li>getDeclaredFields()：获得类的所有属性。包括private 声明的和继承类</li><li>getMethods()：获得类的public类型的方法。</li><li>getDeclaredMethods()：获得类的所有方法。包括private 声明的和继承类</li><li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。</li><li>getConstructors()：获得类的public类型的构造方法。</li><li>getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。</li><li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</li></ul><h2 id="所获取的方法激活以及属性的修改"><a href="#所获取的方法激活以及属性的修改" class="headerlink" title="所获取的方法激活以及属性的修改"></a>所获取的方法激活以及属性的修改</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Class c1 = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;Person&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">//通过构造方法实例化对象</span></span><br><span class="line">    Person p1 = (Person)(c1.get<span class="constructor">Constructor()</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取方法 第二个参数为形参的类 比如String.class</span></span><br><span class="line">    Method <span class="keyword">method</span> = c1.get<span class="constructor">Method(<span class="string">&quot;say&quot;</span>, <span class="params">null</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数激活，第一个参数为对象，第二个参数为传入的形参</span></span><br><span class="line">    <span class="keyword">method</span>.invoke(p1, null);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//通过构造方法实例化对象</span></span><br><span class="line">    Person p2 = (Person)(c1.get<span class="constructor">Constructor()</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取属性</span></span><br><span class="line">    Field name = c1.get<span class="constructor">DeclaredField(<span class="string">&quot;name&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置是否自检 true为取消访问检查 私有类型的修改不关闭检查则会报错</span></span><br><span class="line">    name.set<span class="constructor">Accessible(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置属性 第一个参数为对象，第二个参数为值</span></span><br><span class="line">    name.set(p2,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h1><pre><code>待续</code></pre><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://www.cnblogs.com/mikechenshare/p/15796381.html">mikechen</a><br><br><a href="https://www.w3cschool.cn/java/java-reflex.html">W3Cschool</a><br><br><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">敬业小码哥</a><br><br><a href="https://www.cnblogs.com/ysocean/p/6516248.html">IT可乐</a><br><br><a href="https://www.bilibili.com/video/BV1p4411P7V3?p=17">狂神说Java(视频)</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java I/O</title>
      <link href="/2022/05/02/Java-I-O/"/>
      <url>/2022/05/02/Java-I-O/</url>
      
        <content type="html"><![CDATA[<h1 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h1><p>流：代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象</p><p>流的本质:数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p><p>作用：为数据源和目的地建立一个输送通道</p><span id="more"></span><h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ul><li><p>流向不同 分为输入输出流<br></p><ul><li><p><strong>输出</strong>：把程序(内存)中的内容输出到磁盘、光盘等存储设备中</p></li><li><p><strong>输入</strong>：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中</p></li></ul></li><li><p>处理的数据类型不同 分为字节流和字符流<br></p><ul><li><strong>字节流</strong>： 可以用于读写二进制文件及任意类型文件（如图片 等），读取时一字节为单位（8 bit），同时字节流在操作时不会将数据读取到缓冲区，而是对文件本身进行直接操作，通常情况下采取这种方式</li><li><strong>字符流</strong>： 可以用于读取文本文件。在java中，字符采取Unicode标准，一个字符为16位，所以字符流通常用于处理字符类型的数据，字符流操作时会将数据先读取到缓冲区，只有在流关闭时或者使用flush才能对文件进行操作，一般只在处理纯文本数据时使用。</li></ul></li><li><p>根据功能不同 分为节点流和处理流<br></p><ul><li><strong>节点流</strong>： 可以从或向一个特定的地方(节点)读写数据。如FileInputStream，FileReader，节点流是直接作用在文件上的流，可以理解为一个管道，文件在管道中传输。</li><li><strong>处理流</strong>：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接，处理流是作用在已有的节点流基础上，是包在节点流的外面的管道(可多层)，其目的是让管道内的流可以更快的传输</li></ul></li></ul><h1 id="IO流的五类一接口"><a href="#IO流的五类一接口" class="headerlink" title="IO流的五类一接口"></a>IO流的五类一接口</h1><ul><li>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等</li><li>InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征</li><li>OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征</li><li>Reader（文件格式操作）：抽象类，基于字符的输入操作</li><li>Writer（文件格式操作）：抽象类，基于字符的输出操作</li><li>RandomAccessFile（p随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作</li><li>Serializable： 一个空接口，为对象提供标准的序列化与反序列化操作</li></ul><h1 id="IO流整体框架"><a href="#IO流整体框架" class="headerlink" title="IO流整体框架"></a>IO流整体框架</h1><p><a href="https://img-blog.csdnimg.cn/img_convert/ff708c54547127a831997b01789f07ea.png">javaIO</a><br><br><a href="https://img-blog.csdnimg.cn/img_convert/9092b53635a76155b8189d96e2f866be.png">javaIO</a></p><h1 id="Java-IO流对象介绍"><a href="#Java-IO流对象介绍" class="headerlink" title="Java IO流对象介绍"></a>Java IO流对象介绍</h1><h2 id="字节输入流InputStream"><a href="#字节输入流InputStream" class="headerlink" title="字节输入流InputStream"></a>字节输入流InputStream</h2><ul><li><p>InputStream：字节输入流基类，是所有的字节输入流的父类，它是一个抽象类。</p></li><li><p>FileInputSream：文件输入流。它通常用于对文件进行读取操作。</p></li><li><p>FilterInputStream ：过滤流。作用是为基础流提供一些额外的功能。装饰者模式中处于装饰者，具体的装饰者都要继承它，所以在该类的子类下都是用来装饰别的流的，也就是处理类。</p></li><li><p>BufferedInputStream：缓冲流。对处理流进行装饰，增强，内部会有一个缓存区，用来存放字节，每次都是将缓存区存满然后发送，而不是一个字节或两个字节这样发送。效率更高。</p></li><li><p>DataInputStream：数据输入流。它是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。</p></li><li><p>PushbakInputStream：回退输入流。java中读取数据的方式是顺序读取,如果某个数据不需要读取，需要程序处理。PushBackInputStream就可以将某些不需要的数据回退到缓冲中。</p></li><li><p>ObjectInputStream：对象输入流。用来提供对“基本数据或对象”的持久存储。通俗点讲，也就是能直接传输对象(反序列化中使用)。</p></li><li><p>PipedInputStream：管道字节输入流。它和PipedOutputStream一起使用，能实现多线程间的管道通信。</p></li><li><p>SequenceInputStream:合并输入流。依次将多个源合并成一个源。</p></li><li><p>StringBufferInputStream:字符相关流。已经过时。</p></li><li><p>ByteArrayInputStream：字节数组输入流，该类的功能就是从字节数组(byte[])中进行以字节为单位的读取，也就是将资源文件都以字节的形式存入到该类中的字节数组中去，我们拿也是从这个字节数组中拿。</p></li></ul><h2 id="字节输出流OutputStream"><a href="#字节输出流OutputStream" class="headerlink" title="字节输出流OutputStream"></a>字节输出流OutputStream</h2><ul><li><p>OutputStream：字节输出流基类，是所有的字节输出流的父类，它是一个抽象类。</p></li><li><p>FileOutputStream：文件输出流。该类实现了一个输出流，将数据输出到文件。</p></li><li><p>FilterOutputStream ：过滤流。用来封装其它的输出流，并为它们提供额外的功能(序列化中使用)。它主要包括BufferedOutputStream, DataOutputStream和PrintStream。</p></li><li><p>BufferedOutputStream：缓冲输出流。给输出流提供缓冲功能。</p></li><li><p>DataOutputStream：是用来装饰其它输出流，将DataOutputStream和DataInputStream输入流配合使用，“允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型”。</p></li><li><p>PrintStream：是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p></li><li><p>ObjectOutputStream：对象输出流。该类将实现了序列化的对象序列化后写入指定地方。</p></li><li><p>PipedOutputStream：管道字节输出流。它和PipedInputStream一起使用，能实现多线程间的管道通信，是管道的发送端。</p></li><li><p>ByteArrayOutputStream：字节数组输出流。该类实现了一个输出流，其数据被写入由byte数组充当的缓冲区，缓冲区会随着数据的不断写入而自动增长</p></li></ul><h2 id="字符输入流Reader"><a href="#字符输入流Reader" class="headerlink" title="字符输入流Reader"></a>字符输入流Reader</h2><ul><li><p>Reader：是所有的输入字符流的父类，它是一个抽象类。</p></li><li><p>CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。</p></li><li><p>PipedReader 是从与其它线程共用的管道中读取数据。</p></li><li><p>BufferedReader是一个装饰器，它和其子类LineNumberReader负责装饰其它Reader对象。</p></li><li><p>InputStreamReader：是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。</p></li><li><p>FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader对象进行装饰，会增加一个行号</p></li></ul><h2 id="字符输出流Writer"><a href="#字符输出流Writer" class="headerlink" title="字符输出流Writer"></a>字符输出流Writer</h2><ul><li><p>Writer：是所有的输出字符流的父类，它是一个抽象类。</p></li><li><p>CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据，</p></li><li><p>BufferedWriter 是一个装饰器为Writer 提供缓冲功能。</p></li><li><p>PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。</p></li><li><p>OutputStreamWriter：是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类(具体可以研究一SourceCode)。功能和使用和OutputStream 极其类似。</p></li></ul><h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><p><a href="https://blog.csdn.net/weixin_33602738/article/details/114146995">塔塔君Minkun</a><br><br><a href="https://blog.csdn.net/i6223671/article/details/89041879">Junieson</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的ArrayList</title>
      <link href="/2022/04/15/java%E4%B8%AD%E7%9A%84ArrayList/"/>
      <url>/2022/04/15/java%E4%B8%AD%E7%9A%84ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的ArrayList"><a href="#Java中的ArrayList" class="headerlink" title="Java中的ArrayList"></a>Java中的ArrayList</h1><blockquote><p>ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。<br>ArrayList 继承了 AbstractList ，并实现了 List 接口。</p></blockquote><span id="more"></span><h2 id="引入以及初始化"><a href="#引入以及初始化" class="headerlink" title="引入以及初始化"></a>引入以及初始化</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">ArrayList</span>; <span class="comment">//引入</span></span><br><span class="line">    <span class="built_in">ArrayList</span>&lt;E&gt; objectName = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;&gt;(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">ArrayList</span>&lt;E&gt; objectName = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;&gt;(<span class="type">int</span> initalCapacity); <span class="comment">// 初始化容量</span></span><br><span class="line">    <span class="built_in">ArrayList</span>&lt;E&gt; objectName = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;&gt;(Collection c);</span><br><span class="line">    <span class="comment">//使用集合类的对象进行初始化（set, list,map）等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-ArrayList常用方法"><a href="#Java-ArrayList常用方法" class="headerlink" title="Java  ArrayList常用方法"></a>Java  ArrayList常用方法</h2><ul><li><p>add(int index, E element)<br></p><blockquote><p>将指定元素插入到指定位置,如果无参则默认从末尾插入</p></blockquote><hr></li><li><p>addAll(int index,Collection<E> c)</E></p><blockquote><p>将集合类对象全部插入到指定位置，如果无参则默认从末尾插入</p></blockquote><hr></li><li><p>clear()</p><blockquote><p>清空链表</p></blockquote><hr></li><li><p>clone()</p><blockquote><p>克隆链表 用链表接收返回值</p></blockquote><hr></li><li><p>contains(Object o)</p><blockquote><p>判断链表中是否包含某一元素 返回一个boolean 类型的值</p></blockquote><hr></li><li><p>containsAll(Collection&lt;&gt; o)</p><blockquote><p>判断是否全部包含Collection中的元素</p></blockquote><hr></li><li><p>get(int index)</p><blockquote><p>获得该下标的元素</p></blockquote><hr></li><li><p>indexOf(Object o)</p><blockquote><p>获得在链表中该元素的下标位置</p></blockquote><hr></li><li><p>remove(int index || Object o)</p><blockquote><p>去除链表中该下标位置的元素或与o相同的元素</p></blockquote></li><li><p>subList(int fromIndex,int toIndex)</p><blockquote><p>截取从fromIndex到toIndex的元素 返回值为list</p></blockquote><hr></li><li><p>set(int index,Object element)</p><blockquote><p>替换 arraylist 中指定索引的元素</p></blockquote><hr></li><li><p>sort(Comparator c)</p><blockquote><p>对 arraylist 元素进行排序<br><br>  Comparator 顺序方式 <br><br>  Comparator.naturalOrder() 升序<br>  Comparator.reverseOrder() 降序</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://www.runoob.com/java/java-arraylist.html">菜鸟教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql语句的执行顺序以及流程</title>
      <link href="/2022/04/02/sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/04/02/sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="sql语句的执行顺序以及流程"><a href="#sql语句的执行顺序以及流程" class="headerlink" title="sql语句的执行顺序以及流程"></a>sql语句的执行顺序以及流程</h1><blockquote><p>程序员对sql语句的执行顺序的透彻掌握，是避免编程中各种bug和错误，歧义语句的不二法则。</p></blockquote><span id="more"></span><h1 id="SQL-Select-语句完整的执行顺序："><a href="#SQL-Select-语句完整的执行顺序：" class="headerlink" title="SQL Select 语句完整的执行顺序："></a>SQL Select 语句完整的执行顺序：</h1><p>1、from 子句组装来自不同数据源的数据；<br><br>2、where 子句基于指定的条件对记录行进行筛选； <br><br>3、group by 子句将数据划分为多个分组； <br><br>4、使用聚集函数进行计算； <br><br>5、使用 having 子句筛选分组；<br><br>6、计算所有的表达式；<br>7、select 的字段；<br><br>8、使用 order by 对结果集进行排序。<br></p><p>SQL 语言不同于其他编程语言的最明显特征是处理代码的顺序。 在大多数据库语言中，代码按编码顺序被处理。但在 SQL 语句中，第一个被处理的子句式 FROM，而不是第一出现的 SELECT。</p><h1 id="SQL-查询处理的步骤序号："><a href="#SQL-查询处理的步骤序号：" class="headerlink" title="SQL 查询处理的步骤序号："></a>SQL 查询处理的步骤序号：</h1><p>(1) FROM <left_table> <br><br>(2) <join_type> JOIN <right_table> <br><br>(3) ON <join_condition> <br><br>(4) WHERE <where_condition> <br><br>(5) GROUP BY <group_by_list><br><br>(6) WITH {CUBE | ROLLUP} <br><br>(7) HAVING <having_condition> <br><br>(8) SELECT (9) DISTINCT <br><br>(9) ORDER BY <order_by_list> <br><br>(10) <TOP_specification> <select_list><br></select_list></TOP_specification></order_by_list></having_condition></group_by_list></where_condition></join_condition></right_table></join_type></left_table></p><p>以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者(客户端应 用程序或者外部查询)不可用。只有最后一步生成的表才会会给调用者。如果没有在查询中指定某一个子句， 将跳过相应的步骤。</p><h1 id="逻辑查询处理阶段简介："><a href="#逻辑查询处理阶段简介：" class="headerlink" title="逻辑查询处理阶段简介："></a>逻辑查询处理阶段简介：</h1><p>1、 FROM：对 FROM 子句中的前两个表执行笛卡尔积(交叉联接)，生成虚拟表 VT1。</p><p>2、 ON：对 VT1 应用 ON 筛选器，只有那些使为真才被插入到 TV2。 </p><p>3、 OUTER (JOIN):如果指定了 OUTER JOIN(相对于 CROSS JOIN 或 INNER JOIN)，保留表中未找到 匹配的行将作为外部行添加到 VT2，生成 TV3。如果 FROM 子句包含两个以上的表，则对上一个联接生成的 结果表和下一个表重复执行步骤 1 到步骤 3，直到处理完所有的表位置。</p><p>4、 WHERE：对 TV3 应用 WHERE 筛选器，只有使为 true 的行才插入 TV4。 </p><p>5、 GROUP BY：按 GROUP BY 子句中的列列表对 TV4 中的行进行分组，生成 TV5。 </p><p>6、 CUTE|ROLLUP：把超组插入 VT5，生成 VT6。 </p><p>7、 HAVING：对 VT6 应用 HAVING 筛选器，只有使为 true 的组插入到 VT7。 </p><p>8、 SELECT：处理 SELECT 列表，产生 VT8。 </p><p>9、 DISTINCT：将重复的行从 VT8 中删除，产品 VT9。</p><p>10、 ORDER BY：将 VT9 中的行按 ORDER BY 子句中的列列表顺序，生成一个游标(VC10)。 </p><p>11、 TOP：从 VC10 的开始处选择指定数量或比例的行，生成表 TV11，并返回给调用者。 where 子句中的条件书写顺序</p><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="https://cloud.tencent.com/developer/article/1600323">小马哥</a></p><p>侵权联系删除 email：<a href="mailto:&#x32;&#x36;&#54;&#x38;&#x33;&#x38;&#x30;&#48;&#x36;&#x34;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109;">&#x32;&#x36;&#54;&#x38;&#x33;&#x38;&#x30;&#48;&#x36;&#x34;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109;</a></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Morris 中序遍历 -- 树</title>
      <link href="/2022/04/01/Morris-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2022/04/01/Morris-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote><p>morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，morris遍历可以将非递归遍历中的空间复杂度降为O(1),并且避免了对栈的依赖。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。</p></blockquote><span id="more"></span><h1 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h1><p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 x）：</p><ul><li>如果 x 无左孩子，先将 x 的值加入答案数组，再访问 x 的右孩子，即 x &#x3D; x..right。</li><li>如果 x 有左孩子，则找到 x 左子树上最右的节点（即左子树中序遍历的最后一个节点，x 在中序遍历中的前驱节点），我们记为 predecessor。根据 predecessor 的右孩子是否为空，进行如下操作。</li><li>如果 predecessor 的右孩子为空，则将其右孩子指向 x，然后访问 x 的左孩子，即 x &#x3D; x.left。</li><li>如果 predecessor 的右孩子不为空，则此时其右孩子指向 x，说明我们已经遍历完 x 的左子树，我们将predecessor 的右孩子置空，将 x 的值加入答案数组，然后访问 x 的右孩子，即 x &#x3D; x.right。</li><li>重复上述操作，直至访问完整棵树。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        TreeNode *predecessor = nullptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != nullptr) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (root-&gt;</span>left != nullptr) &#123;</span><br><span class="line">                <span class="comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                <span class="function"><span class="title">predecessor</span> = root-&gt;</span>left;</span><br><span class="line">                <span class="function"><span class="title">while</span> (predecessor-&gt;</span><span class="function"><span class="title">right</span> != nullptr &amp;&amp; predecessor-&gt;</span>right != root) &#123;</span><br><span class="line">                    <span class="function"><span class="title">predecessor</span> = predecessor-&gt;</span>right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="function"><span class="title">if</span> (predecessor-&gt;</span>right == nullptr) &#123;</span><br><span class="line">                    <span class="function"><span class="title">predecessor</span>-&gt;</span>right = root;</span><br><span class="line">                    <span class="function"><span class="title">root</span> = root-&gt;</span>left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="function"><span class="title">res</span>.push_back(root-&gt;</span>val);</span><br><span class="line">                    <span class="function"><span class="title">predecessor</span>-&gt;</span>right = nullptr;</span><br><span class="line">                    <span class="function"><span class="title">root</span> = root-&gt;</span>right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">res</span>.push_back(root-&gt;</span>val);</span><br><span class="line">                <span class="function"><span class="title">root</span> = root-&gt;</span>right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">LeetCode-Solution</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析hexo的原理</title>
      <link href="/2022/03/30/%E6%B5%85%E6%9E%90hexo%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/30/%E6%B5%85%E6%9E%90hexo%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析hexo的原理"><a href="#浅析hexo的原理" class="headerlink" title="浅析hexo的原理"></a>浅析hexo的原理</h1><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><span id="more"></span><h2 id="github的pages服务"><a href="#github的pages服务" class="headerlink" title="github的pages服务"></a>github的pages服务</h2><ul><li><p>github pages 支持静态页面的解析</p></li><li><p>Hexo 用来生成HTML，生成的HTML上传到服务器进行解析</p></li></ul><h2 id="如何用-hexo-生成HTML"><a href="#如何用-hexo-生成HTML" class="headerlink" title="如何用 hexo 生成HTML"></a>如何用 hexo 生成HTML</h2><h3 id="Hexo的工作原理"><a href="#Hexo的工作原理" class="headerlink" title="Hexo的工作原理"></a>Hexo的工作原理</h3><ul><li><p>hexo g : 生成静态文件。将我们的数据和界面相结合生成静态文件的过程。会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 publid 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。</p></li><li><p>hexo d：部署文件。部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 public 文件上传至 github 或者 coding 中。然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 public 文件上传至你自己的服务器上。</p></li></ul><h3 id="hexo的模板引擎"><a href="#hexo的模板引擎" class="headerlink" title="hexo的模板引擎"></a>hexo的模板引擎</h3><ul><li>source 文件夹理解为数据库，而主题文件夹相当于 界面。然后我们 hexo g 就将我们的数据和界面相结合生成静态文件 public。</li></ul><br><ul><li><p>Hexo 的模板引擎是默认使用 ejs 编写的。hexo首先会解析 md 文件，然后根据 layout 判断布局类型，再调用其他的文件，这样每一块的内容都是独立的，提高代码的复用性。最终会生成一个 html 页面。</p></li><li><p>hexo new [layout] &lt;title&gt;就会使用对应的模板。</p><br>其中 _layout.swig 是通用模板，里面引入了 head、footer 等公共组件，然后在其他的模板中会引入这个 _layout.swig 通用模板，比如 post.swig 模板</li></ul><h3 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h3><ul><li>数据填充主要是 hexo -g 的时候将数据传递给swig 模板，然后由swig模板填充到HTML中</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><br>    非要说 Hexo 是什么的话，我觉得就是生成静态页面的工具，可以将我们使用 markdown 编写的内容与主题模板相结合，生成 HTML 静态文件。并且可以和 github 的 pages 或者其他可以将静态页面展现出来的服务（例如 coding 的 pages 服务）相结合，一键部署。<p>再深入一点讲 Hexo 的原理的话，那就应该是使用 yaml 语言 做配置文件，使用 ejs 或者 swig 作为主题模板，与使用 markdown 书写的内容结合，生成静态 HTML 文件。</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><h3 id="如何使用git工具对hexo文章进行版本控制"><a href="#如何使用git工具对hexo文章进行版本控制" class="headerlink" title="如何使用git工具对hexo文章进行版本控制"></a>如何使用git工具对hexo文章进行版本控制</h3><blockquote><p>1.在github或gitee上创建一个私有仓<br><br>2.在hexo文件夹下执行git init <br><br>3.添加远程仓库地址，git remote add github repository_path(github是远程仓库别名，可以另取，repository_path是远程仓库地址)<br><br>4.先拉一下远程仓库的代码，git fetch github<br><br>5.将自己主题的配置复制一份，重命名放到hexo&#x2F;下<br><br>6.填写.gitignore忽略一些不需要进行管理的文件或文件夹，下面是我的配置<br><br>7.将自己的代码提交并push到github上即可<br></p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="meta">    .DS_Store</span></span><br><span class="line">    Thumbs<span class="number">.</span><span class="built_in">db</span></span><br><span class="line">    <span class="built_in">db</span><span class="number">.</span>json</span><br><span class="line">    *.log</span><br><span class="line">    node_modules/</span><br><span class="line">    <span class="meta">public</span>/</span><br><span class="line"><span class="meta">    .deploy</span>*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考  ：<br><br> <a href="https://juejin.cn/post/6844903490930622471">sunshine小小倩</a><br><br> <a href="https://blog.wangx.me/2019/01/12/git-upload-subfolder/">Wangx</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2022/03/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/03/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><strong>正则表达式</strong>：又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</p><span id="more"></span><hr><h2 id="常用字符"><a href="#常用字符" class="headerlink" title="常用字符"></a>常用字符</h2><ul><li><p>\</p><p>  将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</p></li></ul><hr><ul><li><p>^</p><p>  匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</p></li></ul><hr><ul><li><p>$    </p><p>  匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</p></li></ul><hr><ul><li><p>*    </p><p>  匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</p></li></ul><hr><ul><li><p>+</p><p>  匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</p></li></ul><hr><ul><li><p>?</p><p>  匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</p></li></ul><hr><ul><li><p>{n}</p><p>  n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</p></li></ul><hr><ul><li><p>{n,}    </p><p>  n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</p></li></ul><hr><ul><li><p>{n,m}    </p><p>  m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</p></li></ul><hr><ul><li><p>?    </p><p>  当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</p></li></ul><hr><ul><li><p>.    </p><p>  匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.|\n)”的模式。</p></li></ul><hr><ul><li><p>[xyz]    </p><p>  字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</p></li></ul><hr><ul><li><p>[^xyz]</p><p>  负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</p></li></ul><hr><ul><li><p>[a-z]    </p><p>  字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</p></li></ul><hr><ul><li><p>[^a-z]</p><p>  负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</p></li></ul><hr><ul><li><p>\b    </p><p>  匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</p></li></ul><hr><ul><li><p>\B    </p><p>  匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</p></li></ul><hr><ul><li><p>\d</p><p>  匹配一个数字字符。等价于 [0-9]。</p></li></ul><hr><ul><li><p>\D</p><p>  匹配一个非数字字符。等价于 [^0-9]。</p></li></ul><hr><ul><li><p>\r</p><p>  匹配一个回车符。等价于 \x0d 和 \cM。</p></li></ul><hr><ul><li><p>\s</p><p>  匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</p></li></ul><hr><ul><li><p>\S    </p><p>  匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</p></li></ul><hr><ul><li><p>\w    </p><p>  匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</p></li></ul><hr><ul><li><p>\W    </p><p>  匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</p></li></ul><hr><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul><li><p>i</p><p>不区分大小写</p></li><li><p>g</p><p>全局匹配  查找所有的匹配项</p></li><li><p>m</p><p>多行匹配</p></li></ul><br><p>参考   <a href="https://www.runoob.com/regexp/regexp-flags.html">菜鸟教程-正则表达式</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2022/03/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/"/>
      <url>/2022/03/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87blog/</url>
      
        <content type="html"><![CDATA[<h2 id="动态算法的核心"><a href="#动态算法的核心" class="headerlink" title="动态算法的核心"></a>动态算法的核心</h2><p><strong>Those who cannot remember the past are condemn to repeat it.</strong></p><span id="more"></span><hr><h2 id="动态规划算法的两种形式"><a href="#动态规划算法的两种形式" class="headerlink" title="动态规划算法的两种形式"></a>动态规划算法的两种形式</h2><h5 id="一-自顶向下的备忘录法"><a href="#一-自顶向下的备忘录法" class="headerlink" title="一  自顶向下的备忘录法"></a>一  自顶向下的备忘录法</h5><pre><code>由给定的数据开始，将获得既定数据之间的数据进行存储备份</code></pre><p><strong>以斐波拉数列为例</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">int</span> []Memo=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">Memo[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">fib</span><span class="params">(n, Memo)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> []Memo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Memo[n]!=<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> Memo[n];</span><br><span class="line"><span class="comment">//如果已经求出了fib（n）的值直接返回，否则将求出的值保存在Memo备忘录中。</span></span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">Memo[n]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> Memo[n]=fib( n<span class="number">-1</span>,Memo)+fib(n<span class="number">-2</span>,Memo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Memo[n];</span><br><span class="line">&#125;<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><h5 id="二-自底向上的动态规划"><a href="#二-自底向上的动态规划" class="headerlink" title="二  自底向上的动态规划"></a>二  自底向上的动态规划</h5><pre><code> 先计算子问题，在计算父问题，由根至峰</code></pre><p><strong>同样以斐波拉数列为例</strong></p><pre><code>自底向上方法也是利用数组保存了先计算的值，为后面的调用服务。观察参与循环的只有 i，i-1 , i-2三项，因此该方法的空间可以进一步的压缩如下</code></pre><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int fib(int n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=1)</span><br><span class="line">return n;</span><br><span class="line"></span><br><span class="line">int <span class="attribute">Memo_i_2</span>=0;</span><br><span class="line">int <span class="attribute">Memo_i_1</span>=1;</span><br><span class="line">int <span class="attribute">Memo_i</span>=1;</span><br><span class="line"><span class="keyword">for</span>(int <span class="attribute">i</span>=2;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">Memo_i</span>=Memo_i_2+Memo_i_1;</span><br><span class="line"><span class="attribute">Memo_i_2</span>=Memo_i_1;</span><br><span class="line"><span class="attribute">Memo_i_1</span>=Memo_i;</span><br><span class="line">&#125;</span><br><span class="line">return Memo_i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/u013309870/article/details/75193592">CSDN-算法-动态规划</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/08/hello-world/"/>
      <url>/2022/03/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂类 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
