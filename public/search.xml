<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计链表</title>
      <link href="/2023/02/28/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/02/28/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ul><span id="more"></span><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//链表的长度</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//指向第一个结点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size &lt;= index || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">phead</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= index;i++)&#123;</span><br><span class="line">            phead = phead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phead.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        index = Math.max(<span class="number">0</span>,index);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">phead</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            phead = phead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = phead.next;</span><br><span class="line">        phead.next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">phead</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            phead = phead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        phead.next = phead.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移除链表元素</title>
      <link href="/2023/02/28/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2023/02/28/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</p><span id="more"></span><h1 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//当头结点为空时  直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当找到目标节点时  将前一个节点的next指向目标节点的next 完成删除</span></span><br><span class="line">        <span class="comment">//创建一个哨兵节点  next指向head  防止头节点被删除的情况</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">phead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        phead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> phead;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当使用next的时候请确保next不为空  </span></span><br><span class="line">            <span class="keyword">while</span>(node.next!=<span class="literal">null</span> &amp;&amp; node.next.val == val)&#123;</span><br><span class="line">                node.next = node.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> phead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>59.螺旋矩阵II(模拟)</title>
      <link href="/2023/02/27/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
      <url>/2023/02/27/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><span id="more"></span><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//规定上下左右的界限</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//循环次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> n /<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//填充的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//所需数组</span></span><br><span class="line">        <span class="type">int</span> ans[][] = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">while</span>(loop &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//对上层进行填充</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;i &lt; right;i++)&#123;</span><br><span class="line">                ans[top][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对右侧进行填充</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top;i &lt; bottom;i++)&#123;</span><br><span class="line">                ans[i][right] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对下侧进行填充</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right;i &gt; left;i--)&#123;</span><br><span class="line">                ans[bottom][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对左侧进行填充</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom;i &gt; top;i--)&#123;</span><br><span class="line">                ans[i][left] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">            loop--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有当n为奇数时 中间的位置才不会被赋值</span></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            ans[top][left] = num; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>76.最小覆盖子串</title>
      <link href="/2023/02/25/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/02/25/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><span id="more"></span><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//当s的长度小于t时  直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  两个指针 分别指向起始端和包含t中字母的另一下标</span></span><br><span class="line">        <span class="comment">//  当右指针移动到包含t中所有字母时  比较此时两指针之间字串的长度是否是最小的</span></span><br><span class="line">        <span class="comment">//  为此我们需要记录t中字母种类和数量</span></span><br><span class="line">        <span class="type">int</span> need[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用于存储已有字母的数组</span></span><br><span class="line">        <span class="type">int</span> have[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于记录一出现字母的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最后的位置以及最小长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> s.length()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//不是所需要的字符 直接移动右指针  继续循环</span></span><br><span class="line">            <span class="keyword">if</span>(need[s.charAt(right)] == <span class="number">0</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是所需要的元素    次数加一</span></span><br><span class="line">            <span class="keyword">if</span>(have[s.charAt(right)] &lt; need[s.charAt(right)])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            have[s.charAt(right)]++;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当已有字符串包含了所有目标字符串的字符</span></span><br><span class="line">            <span class="keyword">while</span>(count == t.length())&#123;</span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; min)&#123;</span><br><span class="line">                    min = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当左边要去除的字符不是所需要的字符 左指针向左移动</span></span><br><span class="line">                <span class="keyword">if</span>(need[s.charAt(left)] == <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当左边要去除的字符是所需字符  且除去后不满足覆盖子串的条件 跳出循环</span></span><br><span class="line">                <span class="keyword">if</span>(have[s.charAt(left)] == need[s.charAt(left)])&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                have[s.charAt(left)]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最小值没有变化  则返回空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(min == s.length()+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start+min);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>904.水果成篮</title>
      <link href="/2023/02/24/%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/"/>
      <url>/2023/02/24/%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p><span id="more"></span><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="comment">// 用于存储水果的种类</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        map.getOrDefault(fruits[left], <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 遍历数组 对每个位置进行开始采摘的水果最大数目进行计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fruits.length; i++) &#123;</span><br><span class="line">            map.put(fruits[i], map.getOrDefault(fruits[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 当map中的数据大于2是退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//将左指针指向的元素出现次数减一</span></span><br><span class="line">                map.put(fruits[left], map.get(fruits[left] )- <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//当出现次数为0时去除这个数</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(fruits[left]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i - left + <span class="number">1</span>;</span><br><span class="line">            ans = n &gt; ans ? n : ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="巧用swap-没理解"><a href="#巧用swap-没理解" class="headerlink" title="巧用swap(没理解)"></a>巧用swap(没理解)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;fruits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = fruits.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = fruits[i];</span><br><span class="line">        <span class="type">int</span> st = j;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; (fruits[i] == a || fruits[i] == b))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fruits[i] == b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a, b);</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(i - st, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>209.长度最小的子数组(滑动窗口)</title>
      <link href="/2023/02/24/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2023/02/24/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><span id="more"></span><h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><ul><li><strong>LeetCode 会超时</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 最终的结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子序列的数值之和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123; <span class="comment">// 设置子序列起点为i</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123; <span class="comment">// 设置子序列终止位置为j</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= target) &#123; <span class="comment">// 一旦发现子序列和超过了s，更新result</span></span><br><span class="line">                    subLength = j - i + <span class="number">1</span>; <span class="comment">// 取子序列的长度</span></span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">result</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//创建两个指针 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录 最小的差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//记录累加值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一个指针从零开始 </span></span><br><span class="line">        <span class="comment">//第二个指针从零开始 一直向前移动 将所经过的元素都相加</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            sum += nums[fast];</span><br><span class="line">            <span class="comment">//当所累加值大于等于目标值时  记录下当前两个指针之前的插值 并将第一个指针向前移动</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                <span class="comment">//记录最小差值</span></span><br><span class="line">                <span class="keyword">if</span>(fast - slow &lt; index)&#123;</span><br><span class="line">                    index = fast - slow + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//累加值需要减去第一个指针指向的值 再将该指针前移</span></span><br><span class="line">                sum-=nums[slow];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">index</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="number">0</span> : index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h1><a href="/2023/02/22/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" title="26.删除排序数组中的重复项">26.删除排序数组中的重复项</a> <p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">leetcode地址</a><br></p><a href="/2023/02/24/%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/" title="904.水果成篮">904.水果成篮</a> <p><a href="https://leetcode.cn/problems/fruit-into-baskets/">leetcode地址</a><br></p><a href="/2023/02/25/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/" title="76.最小覆盖子串">76.最小覆盖子串</a> <p><a href="https://leetcode.cn/problems/minimum-window-substring/">leetcode地址</a><br></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>977.有序数组的平方</title>
      <link href="/2023/02/23/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>/2023/02/23/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><span id="more"></span><h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//将数组中的数全部平方在排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//找到第一个大于0的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                right = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建两个指针 分别向左向右遍历 比较两个数的大小</span></span><br><span class="line">        <span class="comment">//将其平方放入数组中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> right-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span>|| right &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; nums.length)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t1</span> <span class="operator">=</span> nums[left] * nums[left];</span><br><span class="line">                <span class="type">int</span> <span class="variable">t2</span> <span class="operator">=</span> nums[right] * nums[right];</span><br><span class="line">                <span class="comment">//左边大于右边  将其存入数组  指针向左移动</span></span><br><span class="line">                <span class="keyword">if</span>(t1 &lt; t2)&#123;</span><br><span class="line">                    res[index++] = t1;</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[index++] = t2;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &gt;= <span class="number">0</span>)&#123;  <span class="comment">//用完右边用左边</span></span><br><span class="line">                res[index++] = nums[left] * nums[left];</span><br><span class="line">                left--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right &lt; nums.length)&#123;<span class="comment">//用完左边用右边</span></span><br><span class="line">                res[index++] = nums[right] * nums[right];</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>844.比较含退格的字符串</title>
      <link href="/2023/02/23/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/02/23/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</p><p>注意：如果对空文本输入退格字符，文本继续为空。</p><span id="more"></span><h1 id="重构字符串"><a href="#重构字符串" class="headerlink" title="重构字符串"></a>重构字符串</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//将字符串重构  将结果相比较</span></span><br><span class="line">        <span class="keyword">return</span> build(s).equals(build(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">build</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sb.length() &gt; <span class="number">0</span>) </span><br><span class="line">                sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//创建两个指针  分别指向两个字符串尾部</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t1</span> <span class="operator">=</span> t.length()-<span class="number">1</span>; </span><br><span class="line">        <span class="comment">//创建两个变量 skip  计算需要跳过的字符个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">skipA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">skipB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若遇到 # 且 skip 不为0时不进行比较</span></span><br><span class="line">        <span class="keyword">while</span>(s1 &gt;= <span class="number">0</span> || t1 &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找到第一个需要比较的s的字母</span></span><br><span class="line">            <span class="keyword">while</span>(s1 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(s1) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipA++;</span><br><span class="line">                    s1--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(skipA &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        s1--;</span><br><span class="line">                        skipA--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到第二个需要比较的t的字母</span></span><br><span class="line">            <span class="keyword">while</span>(t1 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(t1) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    t1--;</span><br><span class="line">                    skipB++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(skipB &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        t1--;</span><br><span class="line">                        skipB--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//进行比较</span></span><br><span class="line">            <span class="comment">//经过前面的循环后 指针指向的位置可能已经在-1的位置了</span></span><br><span class="line">            <span class="keyword">if</span>(s1 &gt;= <span class="number">0</span>&amp;&amp;t1 &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(s1) != t.charAt(t1))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果两个指针有一个还在字符串中 还一个index=-1 表示不匹配</span></span><br><span class="line">                <span class="keyword">if</span>(s1 &gt;=<span class="number">0</span> || t1 &gt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s1--;</span><br><span class="line">            t1--;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>283.移动零</title>
      <link href="/2023/02/23/%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/2023/02/23/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作</p><span id="more"></span><h1 id="覆盖法"><a href="#覆盖法" class="headerlink" title="覆盖法"></a>覆盖法</h1><ul><li>这种写法对于[0,0,0,0,1]这类数组会造成多余的循环赋值</li><li>对此交换法的效率会更高<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个指针 指向初始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历数组  将不等于0的元素填充到指针指向的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num != <span class="number">0</span>)</span><br><span class="line">                nums[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将剩下的元素填充为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="交换法"><a href="#交换法" class="headerlink" title="交换法"></a>交换法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//创建两个指针  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当快指针指向不为0的数时  将其与慢指针所指向的元素交换</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, slow, fast);</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> slow,<span class="type">int</span> fast)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[slow];</span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        nums[fast] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>26.删除排序数组中的重复项</title>
      <link href="/2023/02/22/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2023/02/22/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><span id="more"></span><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//将相同的项跳过 获得结果数组</span></span><br><span class="line">        <span class="comment">//从第二位开始获取与之前不同的元素位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果条件成立 表示出现了新的元素  将其赋值到慢指针所指的位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[index++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>27.移除元素(双指针)</title>
      <link href="/2023/02/22/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2023/02/22/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><span id="more"></span><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fastIndex] != val) &#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="头尾指针"><a href="#头尾指针" class="headerlink" title="头尾指针"></a>头尾指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//声明一个左指针 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//声明一个右指针  指向右边第一个不需要移出的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//在每次操作之后 left 或者 right 可能已经相遇了  所以每次操作需要条件进行限制</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="comment">//指向第一个需要移出的元素</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right&amp;&amp;nums[left] != val) left++;</span><br><span class="line">            <span class="comment">//指向右边第一个不需要移出的元素</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right&amp;&amp;nums[right] == val) right--;</span><br><span class="line">            <span class="comment">//将需要移除的元素覆盖</span></span><br><span class="line">            <span class="comment">//覆盖之后指针往前移</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h1><a href="/2023/02/22/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" title="26.删除排序数组中的重复项">26.删除排序数组中的重复项</a> <p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">leetcode地址</a><br></p><a href="/2023/02/23/%E7%A7%BB%E5%8A%A8%E9%9B%B6/" title="283.移动零">283.移动零</a> <p><a href="https://leetcode.cn/problems/move-zeroes/">leetcode地址</a><br></p><a href="/2023/02/23/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="844.比较含退格的字符串">844.比较含退格的字符串</a> <p><a href="https://leetcode.cn/problems/backspace-string-compare/">leetcode地址</a><br></p><a href="/2023/02/23/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/" title="977.有序数组的平方">977.有序数组的平方</a> <p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">leetcode地址</a><br></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>367.有效的完全平方根</title>
      <link href="/2023/02/22/%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
      <url>/2023/02/22/%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p><p>完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。</p><p>不能使用任何内置的库函数，如  sqrt 。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt;= num)&#123;</span><br><span class="line">                ans = mid ;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * ans == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>69.x的平方根</title>
      <link href="/2023/02/22/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
      <url>/2023/02/22/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 </p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//如果mid * mid &gt; x 则ans 会在达到平方数时或之前停止更新</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt;= x)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">else</span></span><br><span class="line">                <span class="variable">r</span> <span class="operator">=</span> mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>34.在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="/2023/02/21/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
      <url>/2023/02/21/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> search(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> search(nums, target+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//第一个判断条件用于判断target大于该数组中的所有数时 退出循环时left会等于数组长度</span></span><br><span class="line">        <span class="comment">//第二个条件判断target不存在时且在数组中的情况  这是nums[l]！=target</span></span><br><span class="line">        <span class="keyword">if</span>(l == nums.length || nums[l] != target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l,r-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left +  (right - left) /<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//不加等号时最终查询的结果会等于左边第一个目标值的下标</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>35.搜索插入位置</title>
      <link href="/2023/02/21/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2023/02/21/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>  <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> ; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>704.二分查找</title>
      <link href="/2023/02/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/02/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length ;    </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;        </span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="type">else</span> </span><br><span class="line">                <span class="variable">right</span> <span class="operator">=</span> mid;       </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/2022/11/26/SpringSecurity/"/>
      <url>/2022/11/26/SpringSecurity/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>SpringSecurity</strong>  是Spring家族中的一个安全管理框架  相比另一个安全框架Shiro  它提供了更多丰富的功能 社区资源也比Shiro丰富<br><br>一般来说中大型的项目都是使用SpringSecurity来做安全框架  小项目用Shiro的比较多 因为相比于SpringSecurity  Shiro的上手更加的简单<br>一般的Web应用需要进行认证和授权<br> 认证: 验证当前访问系统的是不是本系统的用户  并且确认具体是哪个用户<br> 授权:经过认证后判断当前用户是都有权限进行某个操作</p><span id="more"></span><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>创建一个SpringBoot工程</li><li>引入依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>引入依赖之后我们尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面 默认用户名是user 密码会输出在控制台  必须登录后才能对接口进行访问</li></ul><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><h2 id="登陆校验流程"><a href="#登陆校验流程" class="headerlink" title="登陆校验流程"></a>登陆校验流程</h2><p><a href="%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%B5%81%E7%A8%8B.png">登录校验流程</a></p><h2 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h2><h3 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h3><p>SpringSecurity的原理其实就是一个过滤器链  内部包含了提供各种功能的过滤器<br><a href="SpringSecurity%E6%B5%81%E7%A8%8B.drawio.png">SpringSecurity流程.drawio</a><br>图中只展示了核心过滤器 其他的非核心过滤器并没有在图中展示</p><ul><li><p><strong>UsernamePasswordAuthenticationFilter</strong>  负责处理我们在登录页面填写了用户名密码后的登录请求 </p></li><li><p><strong>ExceptionTranslationFilter</strong>  处理过滤链中抛出的任何AccessDeniedException和AuthenticationException</p></li><li><p><strong>FilterSecurityInterceptor</strong> 负责权限校验的过滤器</p></li><li><p>通过IDEA debug我们可以知道一共有那些过滤器  以及他们的顺序<br><a href="FilterChain.png">FilterChain</a></p></li><li><p>DefaultLoginPageGeneratingFilter：默认登录页就是这个过滤器显示出来的，如果不想要默认登录页，就去掉这个过滤器就可以了。</p></li><li><p>DefaultLogoutPageGeneratingFilter：用来显示默认注销的页面</p></li></ul><h3 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h3><p><a href="SpringSecurity%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png">SpringSecurity认证流程</a><br>当前端提交用户名和密码过来时，进入了UsernamePasswordAuthenticationFilter过滤器。</p><ul><li><p>在UsernamePasswordAuthenticationFilter过滤器里，将传进来的用户名和密码被封装成了<strong>Authentication</strong>对象【这时候最多只有用户名和密码，权限还没有】，<strong>Authentication</strong>对象通过<strong>ProviderManager</strong>的<strong>authenticate</strong>方法进行认证。</p><ul><li><p>在<strong>ProviderManager</strong>里面，通过调用DaoAuthenticationProvider的authenticate方法进行认证。</p><ul><li><p>在DaoAuthenticationProvider里，调用<strong>InMemoryUserDetailsManager</strong>的<strong>loadUserByUsername</strong>方法查询用户。【传入的参数只有用户名字符串】</p><ul><li>在<strong>InMemoryUserDetailsManager</strong>的<strong>loadUserByUsername</strong>方法里执行了以下操作<ul><li>根据用户名查询对于用户以及这个用户的权限信息【在内存里查】</li><li>把对应的用户信息包括权限信息封装成UserDetails对象。</li><li>返回UserDetails对象。</li></ul></li></ul></li><li><p>返回给了DaoAuthenticationProvider，在这个对象里执行了以下操作</p><ul><li>通过<strong>PasswordEncoder</strong>对比<strong>UserDetails</strong>中的密码和<strong>Authentication</strong>密码是否正确。【校验密码（经过加密的）】</li><li>如果正确就把<strong>UserDetails</strong>的权限信息设置到<strong>Authentication</strong>对象中。</li><li>返回<strong>Authentication</strong>对象。</li></ul></li></ul></li></ul></li><li><p>又回到了过滤器里面UsernamePasswordAuthenticationFilter。</p><ul><li>如果上一步返回了Authentication对象<br>就使用**SecurityContextHolder.getContext().setAuthentication()**方法存储对象。<br>其他过滤器会通过SecurityContextHolder来获取当前用户信息。【当前过滤器认证完了，后面的过滤器还需要获取用户信息，比如授权过滤器】</li></ul></li></ul><p><strong>加粗字体的类均是比较重要的接口，在实现认证的过程中均需要自定义一个类来重新实现或者变更为Spring中其他实现类。</strong></p><ul><li>Authentication接口  它的实现类  表示当前访问系统的用户 封装了用户相关信息</li><li>AuthenticationManager接口 定义了认证Authentication的方法</li><li>UserDetailsService接口  加载用户特定数据的核心接口  里面定义了一个根据用户名查询用户信息的方法</li><li>UserDetails接口  提供核心用户信息 通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回 然后将这些信息封装到Authentication对象中<br><a href="SpringSecurity%E6%B5%81%E7%A8%8B2.png">SpringSecurity流程2</a></li></ul><p>在初次登录中 如果认证通过  可以将生成的jwt和用户对象存入redis中  等下次用户再次携带token进行访问时 解析jwt后不用每次去数据库进行查询，造成数据库的负担  而可以在redis中更快的获取所需要的内容</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ul><li>登录<ul><li>自定义登录接口<blockquote><p>调用ProviderManager的方法进行认证 如果认证通过生成jwt 把用户信息存入redis中</p></blockquote></li><li>自定义UserDetailsService<blockquote><p>在这个实现中去查询数据库</p></blockquote></li></ul></li><li>校验<ul><li>定义jwt认证过滤器<ul><li>获取token</li><li>解析token获取其中的userid</li><li>从redis中胡哦去用户信息</li><li>存入SecurityContextHolder</li></ul></li></ul></li></ul><h1 id="核心代码实现"><a href="#核心代码实现" class="headerlink" title="核心代码实现"></a>核心代码实现</h1><h2 id="数据库校验数据"><a href="#数据库校验数据" class="headerlink" title="数据库校验数据"></a>数据库校验数据</h2><ul><li><p>首先你要写好UserMapper接口，来实现用户查询。</p></li><li><p>我们要创建一个类UserDetailsServiceImpl来实现<strong>UserDetailsService</strong>接口，来让它实现在数据库里面查询，因为它原本的实现类是查询内存的。【在Service包中】</p></li><li><p>这个接口要使用@Service注解，注入到Spring容器中。</p></li><li><p>重写<strong>loadUserByUsername</strong>方法，传入了Username参数</p><ul><li><p>首先要根据传入的Username参数，查询数据库</p></li><li><p>如果没有这个用户Objects.isNull(user)，就抛出异常</p></li><li><p>根据用户查询权限信息</p></li><li><p>添加到<strong>UserDetails接口的实现类</strong>中</p><ul><li>在domain包中创建类LoginUser，实现UserDetails接口。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;<span class="keyword">return</span> user.getPassword();&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;<span class="keyword">return</span> user.getUserName();&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UserDetailsServiceImpl 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserService service;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">//根据传入了Passward查询用户</span></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(User::getUserName,username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> service.getOne(queryWrapper);</span><br><span class="line">        <span class="comment">//如果没有查询到用户就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 查询对应的权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。</strong></p><h2 id="密码加密存储"><a href="#密码加密存储" class="headerlink" title="密码加密存储"></a>密码加密存储</h2><ul><li>默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。</li></ul><p>​- 我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。</p><p>​- 我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。</p><p>​- 我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h2><p>自定义登陆接口</p><ul><li>登录接口需要让SpringSecurity对这个接口放行【不通过过滤器链】,让用户访问这个接口的时候不用登录也能访问。</li></ul><p><strong>配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...注入BCryptPasswordEncoder....</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()<span class="comment">//允许匿名用户访问,不允许已登入用户访问</span></span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>接口中的认证</p><ul><li>在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证</li><li>所以需要在SecurityConfig中配置把AuthenticationManager注入容器。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span>&#123;</span><br><span class="line">   <span class="comment">//...注入BCryptPasswordEncoder....</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//配置放行....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>再Service中调用 AuthenticationManager 的 authenticate 方法来进行用户认证 返回Authentication</p><ul><li>使用使用authenticate方法，需要传入Authentication，但Authentication是接口，因此需要去找它的实现类。这里我们使用它的实现类是UsernamePasswordAuthenticationToke<blockquote><p>传入的Authentication只有用户名和密码：<br><br>principal 属性为用户名<br><br>credentials 属性为密码</p></blockquote></li><li>使用authenticate方法 返回Authentication<blockquote><p>如果不为空的话，传出的Authentication：<br><br>Principal属性是Userdetails<br><br>credentials 属性为null</p></blockquote></li></ul></li><li><p>如果Authentication为NULL，说明认证没通过，要么没查询到这个用户，要么密码比对不通过。然后就抛出异常。</p></li><li><p>如果认证通过，获取UserId，JwtUtil要将UserId加密成一个toekn。</p></li><li><p>将用户信息Authentication 存入redis</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LoginService</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ResponseResult&lt;Map&lt;String,String&gt;&gt; <span class="title function_">login</span><span class="params">(String userName, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//调用`AuthenticationManager`的方法进行认证</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(<span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(userName, password));</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(authenticate))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果认证通过生成token</span></span><br><span class="line">            <span class="comment">//获取userid</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getId().toString();</span><br><span class="line">            <span class="comment">//生成token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createJWT(userId);</span><br><span class="line">        <span class="comment">//authenticate存入redis</span></span><br><span class="line">        redisCache.setCacheObject(<span class="string">&quot;login:&quot;</span>+userId,loginUser);</span><br><span class="line">        <span class="comment">//把token响应给前端</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>,token);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>&lt;Map&lt;String,String&gt;&gt;(<span class="number">200</span>,<span class="string">&quot;登陆成功&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="认证过滤器"><a href="#认证过滤器" class="headerlink" title="认证过滤器"></a>认证过滤器</h2><p>SpringSecurity自带的过滤器中是用来认证用户名和密码的 但我们并没有使用它  再配置的时候就去掉了 之前的登录接口我们生成了一个token  当前端访问后端的时候需要携带这个token  二这个过滤器就是认证token的</p><ul><li><p>自定义一个过滤器</p><ul><li><p>获取请求头中的token</p><ul><li>如果获取的token字符串为空，说明前端访问后端就没有携带token。然后放行，return<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么是放行而不是抛异常呢？</span><br><span class="line">因为没有携带<span class="built_in">token</span>，有可能前端是想要登录，因此不能抛异常。</span><br><span class="line">就算是要访问其他资源，我们直接放行，Authentication对象没有用户任何信息，后面的过滤器也会抛出异常。后面也不会进行认证。</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>使用JwtUtil对token进行解析取出其中的userid。</p><p>如果token解析失败，说明前端携带的token不合法，就会抛出异常。</p></li><li><p>使用userid去redis中获取对应的LoginUser对象。</p></li><li><p>然后封装Authentication对象存入SecurityContextHolder。<br>在封装Authentication时，使用的实现类是UsernamePasswordAuthenticationToken，使用的构造方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernamePasswordAuthenticationToken</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationToken</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">530L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object principal;</span><br><span class="line">    <span class="keyword">private</span> Object credentials;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(authorities);</span><br><span class="line">        <span class="built_in">this</span>.principal = principal;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">        <span class="built_in">super</span>.setAuthenticated(<span class="literal">true</span>);<span class="comment">//标志为已认证状态，这样就不用再让`UsernamePasswordAuthenticationFilter`过滤器再进行认证了。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//首先需要获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> httpServletRequest.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">//判断token是否为Null</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasText(token)) &#123;</span><br><span class="line">            filterChain.doFilter(httpServletRequest, httpServletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如何不为空，解析token，获得了UserId</span></span><br><span class="line">        String userId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(token);</span><br><span class="line">            userId = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;toen非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据UserId查redis获取用户数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;login:&quot;</span>+userId;</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">LoginUser</span> <span class="operator">=</span> redisCache.getCacheObject(key);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(LoginUser))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后封装Authentication对象存入SecurityContextHolder</span></span><br><span class="line">        <span class="comment">//TODO 获取权限信息封装到Authentication中</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(LoginUser,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(httpServletRequest,httpServletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>该过滤器实现的接口并不是之前的Filter，而是去继承OncePerRequestFilter。</p><p>OncePerRequestFilter是Spring Boot里面的一个过滤器抽象类，这个过滤器抽象类通常被用于继承实现并在每次请求时只执行一次过滤。他能够确保在一次请求只通过一次filter，而不需要重复执行</p><p>而Servlet的Filter可能会执行多次。</p><p>然后我们将过滤器加到UsernamePasswordAuthenticationFilter的前面，在配置类中进行配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>是不是感觉有点乱，让我们缕一缕。先说一下我们对哪些接口进行了实现，或者是更改</p><ul><li><p>我们自定义了UserDetailsService接口，来实现数据库查询。当中用到了<strong>UserDetails接口的实现类——LoginUser</strong>。</p></li><li><p>在UserDetailsService接口是上一层面，我们需要对密码进行解密解析并对比。因为我们使用了<strong>PasswordEncoder接口的其他实现类BCryptPasswordEncoder</strong>。</p></li><li><p>在实现登录接口的时候</p><ul><li><p>需要AuthenticationManager的authenticate方法进行认证。</p></li><li><p>传入Authentication接口的实现类是UsernamePasswordAuthenticationToken。构造方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span></span><br></pre></td></tr></table></figure></li><li><p>这表示该Authentication是未认证的。之后会通过UsernamePasswordAuthenticationFilter过滤器来认证。</p></li></ul></li><li><p>在实现认证过滤器时，</p><ul><li><p>需要使用SecurityContextHolder.getContext().setAuthentication()方法，将用户信息Authentication存进去。方便其他Filter使用。</p></li><li><p>传入Authentication接口的实现类是UsernamePasswordAuthenticationToken。构造方法是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities)</span></span><br></pre></td></tr></table></figure></li><li><p>这表示该Authentication是认证的。之后就不会通过UsernamePasswordAuthenticationFilter过滤器来认证。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/11/18/RabbitMQ/"/>
      <url>/2022/11/18/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MQ(message queue) 从字面意思上看  本质是个队列  FIFO先入先出  只不过队列中存放的内容是message而已  还是一种跨进程的通信机制 用于上下游传递消息  在互联网架构中 MQ是一种非常常见的上下游”逻辑解耦+物理解耦”的信息通信服务  使用MQ之后 信息发送上游只需要依赖MQ 不用依赖其他服务</p><span id="more"></span><h1 id="MQ-相关概念"><a href="#MQ-相关概念" class="headerlink" title="MQ 相关概念"></a>MQ 相关概念</h1><h2 id="流量消峰"><a href="#流量消峰" class="headerlink" title="流量消峰"></a>流量消峰</h2><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><h2 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h2><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。<br><a href="%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6.png">应用解耦</a></p><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>有些服务间调用是异步的，例如A调用B，B需要花费很长时间执行，但是A需要知道B什么时候可以执行完，以前一般有两种方式，A过一段时间去调用B的查询api查询。或者A提供一个callback api,B执行完之后调用api通知A服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题,A调用B服务后，只需要监听B处理完成的消息，当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务。这样A服务既不用循环调用B的查询api，也不用提供callback api。同样B服务也不用做这些操作。A服务还能及时的得到异步处理成功的消息。<br><a href="%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.png">异步处理</a></p><h1 id="MQ-的分类"><a href="#MQ-的分类" class="headerlink" title="MQ 的分类"></a>MQ 的分类</h1><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><ul><li>优点:单机吞吐量万级 时效级ms级  可用性高 基于主从架构实现高可用性 消息可靠性较低的概率丢失数据</li><li>缺点 官方社区现在对ActiveMQ 5.x 维护越来越少 高吞吐量场景较少使用。</li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>大数据的杀手锏  谈到大数据领域内的消息传输 则绕不开Kafka 这款为大数据而生的消息中间件 以其百万级TPS的吞吐量名声大震  迅速成为大数据领域的宠儿 在数据采集 传输 存储的过程中发挥着举足轻重的作用 </p><ul><li>优点  性能卓越 单机写入TPS约在百万条&#x2F;秒 最大的优点 就是吞吐量高  时效性ms级可用性非常高 kafka是分布式的 一个数据多个副本 少数机器宕机 不会丢失数据  不会导致不可用 消费者采用Pull方式获取信息  信息有序 通过控制能够保证所有信息被消费且仅被消费一次 有优秀的第三方Kafka Web管理界面Kafaka-Manager 在日志领域比较成熟 被多家公司和多个开源项目使用  功能较为简单，主要支持简单的MQ功能  在大数据领域的实时计算以及日志采集被大规模使用</li><li>缺点  Kafaka 单机超过64个队列&#x2F;分区  Load会发生明显的飙高现象 队列越多 load越高 发送信息响应时间变长 使用短轮询方式 实时性取决与轮询间隔时间  消费失败不支持重试  支持消息顺序  但是一代代理宕机后  就会产生消息乱序  社区更新较慢</li></ul><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>RocketMQ出自阿里巴巴的开源产品 用java语言实现  在设计时参考了Kafka 并做出了自己的一些改进  被阿里巴巴广泛应用在订单 交易 充值  流计算  信息推送 日志流式处理  binglog分发等场景</p><ul><li>优点 单机吞吐量十万级 可用性非常高  分布式架构 消息可以做到0丢失 MQ功能较为完善 还是分布式的 拓展性好 支持10亿级别的消息堆积 不会因为堆积导致性能下降 </li><li>缺点  支持的客户端语言不多  目前是java及c++ 其中c++不成熟 社区活跃度一般 没有在MQ核心中去实现JMS等接口  有些系统要迁移需要修改大量代码</li></ul><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>07年发布 是一个在AMQP(高级消息队列协议)基础上完成的 可复用的企业消息系统 时当前最主流的消息中间件之一</p><ul><li>优点 由于erlang语言的高并发特性  性能较好 吞吐量到万级 MQ功能比较完备 健壮 稳定 易用 跨平台 支持多种语言 支持AJAX 文档齐全 开源提供的管理界面非常棒  社区活跃度高 更新频率高</li><li>缺点 商业版需要付费 学习成本较高</li></ul><p><a href="https://www.rabbitmq.com/">官网</a></p><h1 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><ul><li><p>生产者：产生数据发送消息的程序</p></li><li><p>交换机：是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p></li><li><p>队列：是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p></li><li><p>消费者：消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p></li></ul><h2 id="RabbitMQ特性"><a href="#RabbitMQ特性" class="headerlink" title="RabbitMQ特性"></a>RabbitMQ特性</h2><p><a href="RabbitMQ%E7%89%B9%E6%80%A7.png">RabbitMQ特性</a></p><h2 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h2><p><a href="RabbitMQ%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png">RabbitMQ工作原理</a></p><ul><li><p>Broker：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p></li><li><p>Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p></li><li><p>Connection：publisher／consumer 和 broker 之间的 TCP 连接</p></li><li><p>Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</p></li><li><p>Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point)，topic (publish-subscribe) and fanout (multicast)</p></li><li><p>Queue：消息最终被送到这里等待 consumer 取走</p></li><li><p>Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据</p></li></ul><h2 id="消费生产者"><a href="#消费生产者" class="headerlink" title="消费生产者"></a>消费生产者</h2><p>创建一个类作为生产者，最终生产消息到 RabbitMQ 的队列里</p><ul><li><p>创建 RabbitMQ 连接工厂</p></li><li><p>进行 RabbitMQ 工厂配置信息</p></li><li><p>创建 RabbitMQ 连接</p></li><li><p>创建 RabbitMQ 信道</p></li><li><p>生成一个队列</p></li><li><p>发送一个消息到交换机，交换机发送到队列。”” 代表默认交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//工厂IP 连接RabbitMQ对列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生产一个对列</span></span><br><span class="line"><span class="comment">         * 1.对列名称</span></span><br><span class="line"><span class="comment">         * 2.对列里面的消息是否持久化，默认情况下，消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者进行消费，是否进行消息共享，true可以多个消费者消费 false：只能一个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除，最后一个消费者端开链接以后，该队列是否自动删除，true表示自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//发消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello,world&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消息</span></span><br><span class="line"><span class="comment">         * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">         * 2.路由的key值是哪个本次是队列的名称</span></span><br><span class="line"><span class="comment">         * 3.其他参数信息</span></span><br><span class="line"><span class="comment">         * 4.发送消息的消息体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明队列</p><blockquote><p>channel.queueDeclare(队列名&#x2F;String, 持久化&#x2F;boolean, 共享消费&#x2F;boolean, 自动删除&#x2F;boolean, 配置参数&#x2F;Map);</p></blockquote></li><li><p>配置参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">// 设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br></pre></td></tr></table></figure></li><li><p>发布消息</p><blockquote><p>channel.basicPublish(交换机名&#x2F;String, 队列名&#x2F;String, 配置参数&#x2F;Map, 消息&#x2F;String);</p></blockquote></li><li><p>发布的消息标识符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给消息赋予 优先级 ID 属性</span></span><br><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">10</span>).messageId(<span class="string">&quot;1&quot;</span>)build();</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br></pre></td></tr></table></figure></li></ul><h2 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//接受消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.91.200&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消息时的回调</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> consumerTag -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费消息</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2.消费成功之后是否要自动应答true：代表自动应答false:代表手动应答</span></span><br><span class="line"><span class="comment">         * 3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">         * 4.消费者取消消费的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Woke-Queues"><a href="#Woke-Queues" class="headerlink" title="Woke Queues"></a>Woke Queues</h2><p>Work Queues 是工作队列（又称任务队列）的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p><h2 id="轮询消费"><a href="#轮询消费" class="headerlink" title="轮询消费"></a>轮询消费</h2><p>轮询消费消息指的是轮流消费消息，即每个工作队列都会获取一个消息进行消费，并且获取的次数按照顺序依次往下轮流。</p><p>案例中生产者叫做 Task，一个消费者就是一个工作队列，启动两个工作队列消费消息，这个两个工作队列会以轮询的方式消费消息。</p><h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费者的消息，因为它无法接收到。</p><p>为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></p><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。</p><h3 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h3><ul><li><p>Channer.basicAck(肯定确认应答)<br>第一个参数时消息的标记 第二个参数表示是否应用于多消息，RabbitMQ已知道该消息并且成功的处理消息 可以将其丢弃了</p><blockquote><p>basicAck(long deliveryTag, boolean multiple);</p></blockquote></li><li><p>Channel.basicReject (否定确认应答) 第一个参数表示拒绝 deliveryTag 对应的消息，第二个参数表示是否 requeue：true 则重新入队列，false 则丢弃或者进入死信队列。该方法 reject 后，该消费者还是会消费到该条被 reject 的消息。</p><blockquote><p>basicReject(long deliveryTag, boolean requeue);</p></blockquote></li><li><p>Channel.basicNack (用于否定确认)：示己拒绝处理该消息，可以将其丢弃</p><blockquote><p>basicNack(long deliveryTag, boolean multiple, boolean requeue);</p></blockquote><p>  第一个参数表示拒绝 deliveryTag 对应的消息，第二个参数是表示否应用于多消息，第三个参数表示是否 requeue，与 basicReject 区别就是同时支持多个消息，可以 拒绝签收 该消费者先前接收未 ack 的所有消息。拒绝签收后的消息也会被自己消费到。</p></li><li><p>Channel.basicRecover</p><blockquote><p>basicRecover(boolean requeue);</p></blockquote><p>  是否恢复消息到队列，参数是是否 requeue，true 则重新入队列，并且尽可能的将之前 recover 的消息投递给其他消费者消费，而不是自己再次消费。false 则消息会重新被投递给自己</p></li><li><p>Multiple  手动应答的好处是可以批量应答并且减少网络拥堵</p><ul><li>true 代表批量应答channel上未应答的消息</li><li>false  只有当前消息会进行应答<h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3></li></ul></li></ul><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><h2 id="RabbitMQ持久化"><a href="#RabbitMQ持久化" class="headerlink" title="RabbitMQ持久化"></a>RabbitMQ持久化</h2><p>当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久化。</p><h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p>之前我们创建的队列都是非持久化的，RabbitMQ 如果重启的化，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为true，代表开启持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启持久化</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//声明队列</span></span><br><span class="line">channel.queueDeclare(TASK_QUEUE_NAME,durable,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>需要在消息生产者发布消息的时候，开启消息的持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置生产者发送消息为持久化消息(要求保存到磁盘上)</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p><h2 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮询分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><p>为了避免这种情况，在消费者中消费消息之前，设置参数 channel.basicQos(1);</p><h3 id="不公平分发思想"><a href="#不公平分发思想" class="headerlink" title="不公平分发思想"></a>不公平分发思想</h3><p>不公平分发思想：如果一个工作队列还没有处理完或者没有应答签收一个消息，则不拒绝 RabbitMQ 分配新的消息到该工作队列。此时 RabbitMQ 会优先分配给其他已经处理完消息或者空闲的工作队列。如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker (工作队列)或者改变其他存储任务的策略</p><h3 id="预取值分发"><a href="#预取值分发" class="headerlink" title="预取值分发"></a>预取值分发</h3><p>默认消息的发送是异步发送的，所以在任何时候，channel 上不止只有一个消息来自消费者的手动确认，所以本质上是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。这个时候就可以通过使用 basic.qos 方法设置「预取计数」值来完成的。</p><p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p><p>通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p><p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><p>生产者发布消息到 RabbitMQ 后，需要 RabbitMQ 返回「ACK（已收到）」给生产者，这样生产者才知道自己生产的消息成功发布出去</p><h3 id="发布确认逻辑"><a href="#发布确认逻辑" class="headerlink" title="发布确认逻辑"></a>发布确认逻辑</h3><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>confirm 模式最大的好处在于是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><h3 id="开启发布确认"><a href="#开启发布确认" class="headerlink" title="开启发布确认"></a>开启发布确认</h3><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure><h3 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h3><p>这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，waitForConfirmsOrDie(long) 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>这种确认方式有一个最大的缺点就是：发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了<br><strong>确认发布是指成功发送到了队列 并不是消费者消费了消息</strong></p><h3 id="批量发布确认"><a href="#批量发布确认" class="headerlink" title="批量发布确认"></a>批量发布确认</h3><p>单个确认发布方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断达到100条消息的时候，批量确认一次</span></span><br><span class="line"><span class="keyword">if</span>((i+<span class="number">1</span>)%batchSize==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//发布确认</span></span><br><span class="line">channel.waitForConfirms();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步发布确认"><a href="#异步发布确认" class="headerlink" title="异步发布确认"></a>异步发布确认</h3><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都很好，利用了回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息确认回调的函数</span></span><br><span class="line"><span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag,multiple) -&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;确认的消息:&quot;</span>+deliveryTag);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1.消息的标记</span></span><br><span class="line"><span class="comment">    * 2.是否为批量确认</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//消息确认失败回调函数</span></span><br><span class="line">ConfirmCallback nackCallback= (deliveryTag,multiple) -&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未确认的消息:&quot;</span>+deliveryTag);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备消息的监听器 监听那些消息成功了，哪些消息失败了</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1.监听哪些消息成功了</span></span><br><span class="line"><span class="comment">    * 2.监听哪些消息失败了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">channel.addConfirmListener(ackCallback,nackCallback);<span class="comment">//异步通知</span></span><br></pre></td></tr></table></figure><p>实际案例里，将发布的消息存入 Map 里，方便获取。headMap 方法用于将已确认的消息存入新的 Map 缓存区里，然后清除该新缓存区的内容。因为 headMap 方法是浅拷贝，所以清除了缓存区，相当于清除了内容的地址，也就清除了队列的确认的消息。</p><h4 id="处理异步未确认消息"><a href="#处理异步未确认消息" class="headerlink" title="处理异步未确认消息"></a>处理异步未确认消息</h4><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程安全有序的一个哈希表，适用于高并发的情况下</span></span><br><span class="line"><span class="comment">* 1.轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">* 2.轻松批量删除条目 只要给到序号</span></span><br><span class="line"><span class="comment">* 3.支持高并发(多线程)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ConcurrentSkipListMap&lt;Long,String&gt; outstandingConfirms=</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//消息确认回调的函数</span></span><br><span class="line"><span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag,multiple) -&gt;&#123;</span><br><span class="line"><span class="keyword">if</span>(multiple) &#123;</span><br><span class="line">    <span class="comment">//2.删除掉已经确认的消息 剩下的就是未确认的消息</span></span><br><span class="line">    ConcurrentNavigableMap&lt;Long, String&gt; confirmed =</span><br><span class="line">            outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">    confirmed.clear();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    outstandingConfirms.remove(deliveryTag);</span><br><span class="line">&#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;确认的消息:&quot;</span> + deliveryTag);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ-交换机"><a href="#RabbitMQ-交换机" class="headerlink" title="RabbitMQ 交换机"></a>RabbitMQ 交换机</h2><p>RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><h3 id="交换机的类型"><a href="#交换机的类型" class="headerlink" title="交换机的类型"></a>交换机的类型</h3><ul><li><p><strong>直接</strong>(direct)：处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 abc ，则只有被标记为 abc 的消息才被转发，不会转发 abc.def，也不会转发 dog.ghi，只会转发 abc。</p></li><li><p><strong>主题</strong>(topic)：将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号 * 匹配不多不少一个词。因此 abc.# 能够匹配到 abc.def.ghi，但是 abc.* 只会匹配到 abc.def。</p></li><li><p><strong>标题</strong>(headers)：不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到RabbitMQ 时会取到该消息的 headers 与 Exchange 绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 属性是一个键值对，可以是 Hashtable，键值对的值可以是任何类型。而 fanout，direct，topic 的路由键都需要要字符串形式的。</p><p>  匹配规则 x-match 有下列两种类型：</p><p>  x-match &#x3D; all ：表示所有的键值对都匹配才能接受到消息</p><p>  x-match &#x3D; any ：表示只要有键值对匹配就能接受到消息</p></li><li><p><strong>扇出</strong>(fanout)：不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout 交换机转发消息是最快的。</p></li><li><p>默认交换机   空字符串 表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey) 绑定指定的 key</p></li></ul><h3 id="绑定bindings"><a href="#绑定bindings" class="headerlink" title="绑定bindings"></a>绑定bindings</h3><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p><h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p><h3 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h3><ul><li>消息ttl过期</li><li>队列达到最大长度</li><li>消息被拒绝</li></ul><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要在某个事件发生之后或者之前的指定时间点完成某一项任务</p><ul><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ul><h2 id="TTL的两种设置"><a href="#TTL的两种设置" class="headerlink" title="TTL的两种设置"></a>TTL的两种设置</h2><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。</p><p>换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为「死信」。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p><h3 id="队列设置TTL"><a href="#队列设置TTL" class="headerlink" title="队列设置TTL"></a>队列设置TTL</h3><p>在创建队列的时候设置队列的 x-message-ttl 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">params.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">5000</span>);</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;QA&quot;</span>).withArguments(args).build(); <span class="comment">// QA 队列的最大存活时间位 5000 毫秒</span></span><br></pre></td></tr></table></figure><h3 id="消息设置TTL"><a href="#消息设置TTL" class="headerlink" title="消息设置TTL"></a>消息设置TTL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.converAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XC&quot;</span>,message,correlationData -&gt; &#123;</span><br><span class="line">    correlationData.getMessageProperties().setExpiration(<span class="string">&quot;5000&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间，具体看下方案例。</p><p>另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis6</title>
      <link href="/2022/11/07/Redis6/"/>
      <url>/2022/11/07/Redis6/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。</p><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。</p><p>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。</p><span id="more"></span><h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>NoSQL(NoSQL &#x3D; Not Only SQL) 意为 “不仅仅只是SQL” 泛指非关系型的数据库 NoSQL不依赖业务逻辑方式存储 而以简单的key-value模式存储 因此大大增加了数据库的拓展能力</p><ul><li>不遵循SQL标准</li><li>不支持ACID(原子性 一致性 隔离性 持久性)</li><li>远超于SQL的性能</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>对数据高并发的读写</li><li>海量数据的读写</li><li>对数据高可扩展性的</li></ul><h2 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h2><ul><li>需要事务支持</li><li>基于sql的结构化查询存储  处理复杂的关系 需要即时查询</li><li><strong>用不着sql的和用了sql也不行的情况  可以考虑使用NoSql</strong></li></ul><h2 id="常见NoSQL"><a href="#常见NoSQL" class="headerlink" title="常见NoSQL"></a>常见NoSQL</h2><h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><ul><li>很早出现的NoSql数据库</li><li>数据都在内存中  一般不持久化</li><li>支持简单的key-value模式  支持类型单一(字符串)</li><li>一般是作为缓存数据库辅助持久化的数据库</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>几乎覆盖了Memcached的绝大部分功能</li><li>数据都在内存中  支持持久化  主要作备份恢复</li><li>除了支持简单的key-value 模式 还支持多种数据结构的存储  比如 list set hash  zset(有序集合)等</li><li>一般是作为缓存数据库辅助持久化的数据库</li></ul><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><ul><li>高性能 开源 模式自由(schema free)的文档型数据库</li><li>数据都在内存中 如果内存不足 把不常用的数据保存到硬盘</li><li>虽然是key-value 模式 但是对value(尤其是 json)提供了丰富的查询功能</li><li>支持二进制数据及大型对象</li><li>可以根据数据的特点替代 <a href="http://c.biancheng.net/sql/rdbms.html">RDBMS</a> 成为独立的数据库 或者配合<a href="http://c.biancheng.net/sql/rdbms.html">RDBMS</a> 存储特定的数据</li></ul><h1 id="Redis概念与安装"><a href="#Redis概念与安装" class="headerlink" title="Redis概念与安装"></a>Redis概念与安装</h1><ul><li>Redis 是一个开源的key-value存储系统</li><li>和Memcached类似 它支持存储value类型相对更多 包括string list set zset hash</li><li>这些数据类型都支持push&#x2F;pop  add&#x2F;remove 及取交集并集和差集及更丰富的操作  而且这些操作都是原子性的</li><li>在此基础上  Redis支持各种不同方式的排序</li><li>数据都是缓存在内存中</li><li>Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件</li><li>并在此基础上实现了master-slave(主从)同步</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>配合关系型数据库做高速缓存</li><li>高频次 热门访问的数据 降低数据库IO</li><li>分布式架构 做session共享</li></ul><p><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE.png">数据结构存储持久化数据</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p><strong>安装必须在linux环境下安装</strong></p></blockquote><ul><li><p>安装gcc环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc-c++   pcre pcre-devel zlib zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure></li><li><p>下载安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-6.2.1.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf redis-6.2.1.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>进入redis目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.1</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make </span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li></ul><p><strong>安装后的默认目录是&#x2F;usr&#x2F;local&#x2F;bin</strong></p><h3 id="安装目录结构"><a href="#安装目录结构" class="headerlink" title="安装目录结构"></a>安装目录结构</h3><ul><li>redis-benchmark 性能测试工具 可以在自己本地运行  看看自己电脑性能如何</li><li>redis-check-aof  修复有问题的AOF文件 </li><li>redis-check-dump 修复有问题的dump.rdb文件</li><li>redis-sentinel Redis集群使用</li><li>redis-server  Redis服务器启动命令</li><li>redis-cli 客户端  操作入口</li></ul><h2 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h2><ul><li>备份redis.conf<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /redis-x-x-x/redis.conf(文件路径) /etc/redis.conf(目标文件路径)</span><br></pre></td></tr></table></figure></li><li>使用vim将reids.conf 文件中的daemonize no 改为 yes  让服务在后台启动</li><li>启动<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure></li><li>客户端访问<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure></li><li>多个端口可以<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli-p6379</span><br></pre></td></tr></table></figure></li><li>测试验证 ping 显示PONG  表示链接成功</li><li>退出  exit</li></ul><h1 id="Redis-常用五大数据类型"><a href="#Redis-常用五大数据类型" class="headerlink" title="Redis 常用五大数据类型"></a>Redis 常用五大数据类型</h1><h2 id="Redis键-key"><a href="#Redis键-key" class="headerlink" title="Redis键(key)"></a>Redis键(key)</h2><ul><li>keys * 查看当前库所有key (匹配: keys *1)</li><li>exitsts key  判断某个key是否存在</li><li>type key 查看你的key是什么类型</li><li>del key  删除指定的key数据</li><li>unlink key  根据value选择非阻塞删除<blockquote><p>仅将keys从keyspace 元数据中删除 真正的删除会在后续异步操作</p></blockquote></li><li>expire key 10  为给定的key设置过期时间</li><li>ttl key  查看还有多少秒过期  -1 表示永不过期 -2 表示已过期</li></ul><p>select 命令切换数据库<br>dbsize 查看当前数据库的key的数量<br>flushdb 清空当前库<br>flushall 通杀全部库</p><h2 id="Redis-字符串-String"><a href="#Redis-字符串-String" class="headerlink" title="Redis 字符串(String)"></a>Redis 字符串(String)</h2><p>String 是Redis最基本的类型 一个key对应一个value 一个Redis中字符串value最多可以是512M</p><p>String类型是二进制安全的 意味着Redis的string可以包含任何数据 比如图片或者序列化对象等</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>NX: 当数据库中key不存在时  可以将key-value添加数据库</li><li>XX:当数据库中key存在时 可以将key-value添加数据库  与NX参数互斥</li><li>EX: key的超时秒数</li><li>PX：key的超时毫秒数 与EX互斥</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>set &lt;key&gt;&lt;value&gt;</td><td>添加键值对</td></tr><tr><td>get &lt;key&gt;</td><td>查询对应键值</td></tr><tr><td>append &lt;key&gt;&lt;value&gt;</td><td>将给定的&lt;value&gt;追加到原值的末尾</td></tr><tr><td>strlen &lt;key&gt;</td><td>获取值的长度</td></tr><tr><td>setnx &lt;key&gt;&lt;value&gt;</td><td>只有在key不存在时 设置key的值</td></tr><tr><td>incr &lt;key&gt;</td><td>将key中储存的数字值增1  **只能对数字值使用 如果为空 新增</td></tr><tr><td>decr &lt;key&gt;</td><td>将key中存储的数字值减1  **只能对数字值操作 如果为空 新增</td></tr><tr><td>incrby&#x2F;decrby  &lt;key&gt;&lt;步长&gt;</td><td>将key中存储的数字值增减 自定义步长</td></tr><tr><td>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; ….</td><td>同时设置一个或多个</td></tr><tr><td>mget &lt;key1&gt;&lt;key2&gt;…</td><td>同时获取一个或多个value</td></tr><tr><td>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;</td><td>同时设置一个或多个</td></tr><tr><td>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</td><td>获得值的范围 类似java中</td></tr><tr><td>setrange &lt;key&gt;&lt;起始位置&gt; <value></value></td><td>覆写&lt;key&gt;所存储的字符串值 从起始位置开始</td></tr><tr><td>setex &lt;key&gt; &lt;过期时间&gt;<value></value></td><td>设置键值的同时 设置过期时间 单位秒</td></tr><tr><td>getset &lt;key&gt;&lt;value&gt;</td><td>设置了新值的同时获得旧值</td></tr></tbody></table><h2 id="Redis-列表"><a href="#Redis-列表" class="headerlink" title="Redis 列表"></a>Redis 列表</h2><p>单键多值<br>Redis 列表时简单的字符串列表 按照插入的顺序排序  你可以添加一个元素到列表的头部 或 尾部</p><p>它的底层实现是双向链表  对两端的操作性能很高  通过索引下标的操作中间的节点性能会较差</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>push&#x2F;rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;….</td><td>从左边&#x2F;右边插入一个或多个值</td></tr><tr><td>pop&#x2F;rpop &lt;key&gt;</td><td>从左边&#x2F;右边移除一个值  <strong>值在键在  值光键亡</strong></td></tr><tr><td>rpoplpush &lt;key1&gt;&lt;key2&gt;</td><td>从&lt;key1&gt;列表右边移出一个值插入到&lt;key2&gt;列表的左边</td></tr><tr><td>lrange &lt;key&gt;&lt;strat&gt;&lt;stop&gt;</td><td>按照索引下标获得元素(从左到右)</td></tr><tr><td>lrange mylist 0 -1</td><td>表示获取链表中的所有值</td></tr><tr><td>lindex &lt;key&gt;&lt;index&gt;</td><td>按照索引下标获得元素(从左到右)</td></tr><tr><td>llen &lt;key&gt;</td><td>获得列表长度</td></tr><tr><td>linsert &lt;key&gt; before &lt;value&gt;&lt;newvalue&gt;</td><td>在&lt;value&gt;的后面插入&lt;newvalue&gt;插入值</td></tr><tr><td>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</td><td>从左边删除n个value(从左到右)</td></tr><tr><td>lset &lt;key&gt;&lt;index&gt;&lt;value&gt;</td><td>将列表key下标为index的值替换成 value</td></tr></tbody></table><h2 id="Redis-集合-Set"><a href="#Redis-集合-Set" class="headerlink" title="Redis 集合(Set)"></a>Redis 集合(Set)</h2><p>Redis set对外提供的功能与list类似是一个列表的功能 特殊之处在于set是可以自动去重的 当你需要存储一个列表数据  又不希望出现重复数据时 set是一个很好的选择  并且set提供了判断某个成员是否在一个set集合内的重要接口  这个也是list没有的 </p><p>Redis 的 set 是 String 类型的无序集合 它底层是一个 value 为 null 的 hash 表 所以添加 删除  查找的复杂度都是O(1)</p><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; …</td><td>将一个或多个member 元素加入到集合key中 已经存在的 member 元素将被忽略</td></tr><tr><td>smembers &lt;key&gt;</td><td>取出该集合的所有值</td></tr><tr><td>sismember &lt;key&gt;&lt;value&gt;</td><td>判断集合 &lt;key&gt; 中是否含有该 &lt;value&gt;值 有 1 没有 0</td></tr><tr><td>scard &lt;key&gt;</td><td>返回该集合的元素个数</td></tr><tr><td>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; …</td><td>删除集合中的某个元素</td></tr><tr><td>spop &lt;key&gt;</td><td>随机从该集合中移出一个值</td></tr><tr><td>srandmemeber &lt;key&gt;&lt;n&gt;</td><td>随机从该集合中取出n个值  不会从集合中删除</td></tr><tr><td>smove &lt;source&gt;&lt;destination&gt; &lt;value&gt;</td><td>把集合中一个值从一个集合移动到另一个集合</td></tr><tr><td>sinter &lt;key1&gt;&lt;key2&gt;</td><td>返回两个集合中的交集元素</td></tr><tr><td>sunion &lt;key1&gt;&lt;key2&gt;</td><td>返回两个集合的并集元素</td></tr><tr><td>sdiff &lt;key1&gt;&lt;keye2&gt;</td><td>返回两个集合的差集元素(key1中的 不包含key2中的)</td></tr></tbody></table><h2 id="Redis-哈希-Hash"><a href="#Redis-哈希-Hash" class="headerlink" title="Redis 哈希(Hash)"></a>Redis 哈希(Hash)</h2><p>Redis hash 是一个键值对集合<br>Redis hash 是一个string类型的field和value的映射表 hash 特别适合用于存储对象 类似java中的Map&lt;String,Object&gt;</p><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>hset &lt;key&gt;&lt;field&gt;<value></value></td><td>给&lt;key&gt;集合中的 &lt;filed&gt; 键赋值&lt;value&gt;</td></tr><tr><td>hget&lt;key1&gt;&lt;field&gt;</td><td>从&lt;key1&gt;集合&lt;field&gt; 取出value</td></tr><tr><td>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;…</td><td>批量设置hash的值</td></tr><tr><td>hexists &lt;key1&gt;&lt;field&gt;</td><td>查看哈希表key 中 给定域field 是否存在</td></tr><tr><td>hkeys &lt;key&gt;</td><td>列出该hash集合的所有field</td></tr><tr><td>hvaks &lt;key&gt;</td><td>列出该hash集合的所有value</td></tr><tr><td>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</td><td>为哈希表key中域field的值加上增量 1 -1</td></tr><tr><td>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</td><td>将哈希表key中的域field的值设置为value 当且仅当域field不存在</td></tr></tbody></table><h2 id="Redis-有序集合Zset-sorted-set"><a href="#Redis-有序集合Zset-sorted-set" class="headerlink" title="Redis 有序集合Zset(sorted set)"></a>Redis 有序集合Zset(sorted set)</h2><p>Redis 有序集合zset 和 普通集合set非常相似 是一个没有重复元素的字符串集合<br>不同之处是有序集合的每个成员都关联了一个评分(score) 这个评分被用来按照从最低分到最高分的方式排序集合中的成员 集合的成员是唯一的 但是评分可以重复</p><p>因为元素是有序的  所以你也可以很快的根据评分 或者次序来获取一个范围的元素</p><p>访问有序集合的中间元素也是非常快的  因此你能够使用有序集合作为一个没有重复成员的智能列表</p><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;</td><td>将一个或多个member元素及其score值加入到有序集合key中</td></tr><tr><td>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]</td><td>返回有序集合key中 下标在start stop 之间的元素 带WITHSCORES 可以让分数一起和值返回到结果集</td></tr><tr><td>zrangebyscore key minmax [withscores][limit offset count]</td><td>返回有序集key中 所有score值介于min 和 max 之间(包括等于min 或 max)的成员 有序集合成员按照score值递增次序排列</td></tr><tr><td>zrevrangebyscore key maxmin [withsscore] [limit offset count]</td><td>同上 改为从大到小</td></tr><tr><td>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</td><td>为元素的score加上增量</td></tr><tr><td>zrem &lt;key&gt;&lt;value&gt;</td><td>删除该集合下 指定值的元素</td></tr><tr><td>zcount &lt;key&gt;&lt;min&gt;&gt;<max></max></td><td>统计该集合 分数区间内的元素个数</td></tr><tr><td>zrank &lt;key&gt;&lt;value&gt;</td><td>返回该值在集合中的排名 从0开始</td></tr></tbody></table><h1 id="Redis-新数据类型"><a href="#Redis-新数据类型" class="headerlink" title="Redis 新数据类型"></a>Redis 新数据类型</h1><h2 id="Redis-Bitmaps"><a href="#Redis-Bitmaps" class="headerlink" title="Redis Bitmaps"></a>Redis Bitmaps</h2><p>Redis 提供了Bitmaps这个”数据类型” 可以实现对位的操作</p><ul><li>Bitmaps 本身不是一种数据类型 实际上它就是字符串 但是它可以对字符串的位进行操作</li><li>Bitmaps 单独提供了一套命令 所以在Redis中使用Bitmaps和使用字符串的方法不太相同 可以把Bitmaps想象成一个以位为单位的数组 数组的每个单元只能存储0 或 1 数组的下标在Bitmaps中叫做偏移量</li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>setbit &lt;key&gt;&lt;offset&gt;&lt;value&gt;</td><td>设置Bitmaps中某个偏移量的值</td></tr><tr><td>getbit &lt;key&gt;&lt;offset&gt;</td><td>获取Bitmaps中某个偏移量的值</td></tr><tr><td>bitcount &lt;key&gt;[start end]</td><td>统计字符串从start字节到end字节比特值为1的数量</td></tr><tr><td>bitop and(or&#x2F;not&#x2F;xor) &lt;destkey&gt; [key…]</td><td>bitop是一个复合操作 它可以做多个Bitmaps的and or xor 操作并将结果保存在destkey中</td></tr></tbody></table><h2 id="Redis-HyperLogLog"><a href="#Redis-HyperLogLog" class="headerlink" title="Redis HyperLogLog"></a>Redis HyperLogLog</h2><p>Redis HyperLogLog 是用来做基数统计的算法 HyperLogLog 键只需要花费12KB内存 就可以计算接近2^64个不同元素的基数 这和计算基数时 元素越多耗费内存就越多的集合形成鲜明对比<br>但是 因为HyperLogLog只会根据输入元素来计算基数 而不会存储输入元素本身 所以HyperLogLog 不能像集合那样  返回输入的各个元素</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>pfadd &lt;key&gt;&lt;element&gt; [element….]</td><td>添加指定元素到HyperLogLog中</td></tr><tr><td>pfcount &lt;key&gt; [key…]</td><td>计算出HLL的近似基数  可以计算多个HLL 比如用HLL存储每天的UV(Unique visitor 指通过互联网访问、浏览这个网页的自然人) 计算一周的UV可以使用七天的UV合并计算即可</td></tr><tr><td>pfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey…]</td><td>将与1个或多个HLL合并后的结果存储在另一个HLL中 比如每月活跃用户可以使用每天的活跃用户来合并计算可得</td></tr></tbody></table><h2 id="Redis-GEO-Geographic"><a href="#Redis-GEO-Geographic" class="headerlink" title="Redis GEO(Geographic)"></a>Redis GEO(Geographic)</h2><p>该类型就是元素的2维坐标 在地图上就是经纬度  redis基于该类型 提供了经纬度设置 查询 范围查询 距离查询 经纬度Hash等常见操作</p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>geoadd &lt;key&gt;&lt;longitude&gt;&lt;latitude&gt;&lt;member&gt; [longitude latitude member…]</td><td>添加地理位置(  经度 维度  名称)</td></tr><tr><td>geopos &lt;key&gt;&lt;member&gt; [member…]</td><td>获得指定地区的坐标值</td></tr><tr><td>geodist &lt;key&gt;&lt;member1&gt;&lt;member2&gt; [m 米</td><td>km 千米</td></tr><tr><td>georadius &lt;key&gt; &lt;longitude&gt;&lt;latitude&gt; radius m</td><td>km</td></tr></tbody></table><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><h2 id="IDEA-链接Redis"><a href="#IDEA-链接Redis" class="headerlink" title="IDEA 链接Redis"></a>IDEA 链接Redis</h2><ul><li>创建工程</li><li>导入Jedis坐标</li><li>对redis配置文件进行修改<ul><li>注释掉第69行的 bind 127.0.0.1</li><li>将 protected-mode 设置为no</li><li>将 daemonize 设置yes</li></ul></li><li>开放端口6379 或者关闭防火墙</li></ul><h2 id="Jedis-字符串操作"><a href="#Jedis-字符串操作" class="headerlink" title="Jedis 字符串操作"></a>Jedis 字符串操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">&quot;===========增加数据===========&quot;</span>);</span><br><span class="line">    System.out.println(jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>));</span><br><span class="line">    System.out.println(jedis.set(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>));</span><br><span class="line">    System.out.println(jedis.set(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除键key2:&quot;</span> + jedis.del(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取键key2:&quot;</span> + jedis.get(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改key1:&quot;</span> + jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取key1的值：&quot;</span> + jedis.get(<span class="string">&quot;key1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;在key3后面加入值：&quot;</span> + jedis.append(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;End&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;key3的值：&quot;</span> + jedis.get(<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;增加多个键值对：&quot;</span> + jedis.mset(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;value01&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;value02&quot;</span>, <span class="string">&quot;key03&quot;</span>, <span class="string">&quot;value03&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;key03&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;key03&quot;</span>, <span class="string">&quot;key04&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除多个键值对：&quot;</span> + jedis.del(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;key02&quot;</span>&#125;));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;key03&quot;</span>));</span><br><span class="line"></span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">&quot;===========新增键值对,防止覆盖原先值==============&quot;</span>);</span><br><span class="line">    System.out.println(jedis.setnx(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>));</span><br><span class="line">    System.out.println(jedis.setnx(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>));</span><br><span class="line">    System.out.println(jedis.setnx(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2-new&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;key1&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;===========新增键值对并设置有效时间=============&quot;</span>);</span><br><span class="line">    System.out.println(jedis.setex(<span class="string">&quot;key3&quot;</span>, <span class="number">2</span>, <span class="string">&quot;value3&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;key3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;===========获取原值，更新为新值==========&quot;</span>);<span class="comment">//GETSET is an atomic set this value and return the old value command.</span></span><br><span class="line">    System.out.println(jedis.getSet(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;key2GetSet&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;获得key2的值的字串：&quot;</span> + jedis.getrange(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jedis-Hash操作"><a href="#Jedis-Hash操作" class="headerlink" title="Jedis Hash操作"></a>Jedis Hash操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis操作Hash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>);</span><br><span class="line">    jedis.hmset(<span class="string">&quot;hash&quot;</span>, map);</span><br><span class="line">    jedis.hset(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key5&quot;</span>, <span class="string">&quot;value5&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return Map&lt;String,String&gt;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键为：&quot;</span> + jedis.hkeys(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return Set&lt;String&gt;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有值为：&quot;</span> + jedis.hvals(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return List&lt;String&gt;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span> + jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">6</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span> + jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除一个或者多个键值对：&quot;</span> + jedis.hdel(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash中键值对的个数：&quot;</span> + jedis.hlen(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;判断hash中是否存在key2：&quot;</span> + jedis.hexists(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;判断hash中是否存在key3：&quot;</span> + jedis.hexists(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取hash中的值：&quot;</span> + jedis.hmget(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取hash中的值：&quot;</span> + jedis.hmget(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;key4&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jedis-列表操作"><a href="#Jedis-列表操作" class="headerlink" title="Jedis 列表操作"></a>Jedis 列表操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">&quot;===========添加一个list===========&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;lists&quot;</span>, <span class="string">&quot;ArrayList&quot;</span>, <span class="string">&quot;Vector&quot;</span>, <span class="string">&quot;Stack&quot;</span>, <span class="string">&quot;HashMap&quot;</span>, <span class="string">&quot;WeakHashMap&quot;</span>, <span class="string">&quot;LinkedHashMap&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;lists&quot;</span>, <span class="string">&quot;HashSet&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;lists&quot;</span>, <span class="string">&quot;TreeSet&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;lists&quot;</span>, <span class="string">&quot;TreeMap&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));<span class="comment">//-1代表倒数第一个元素，-2代表倒数第二个元素</span></span><br><span class="line">    System.out.println(<span class="string">&quot;lists区间0-3的元素：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    <span class="comment">// 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈</span></span><br><span class="line">    System.out.println(<span class="string">&quot;删除指定元素个数：&quot;</span> + jedis.lrem(<span class="string">&quot;lists&quot;</span>, <span class="number">2</span>, <span class="string">&quot;HashMap&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除下表0-3区间之外的元素：&quot;</span> + jedis.ltrim(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists列表出栈（左端）：&quot;</span> + jedis.lpop(<span class="string">&quot;lists&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists添加元素，从列表右端，与lpush相对应：&quot;</span> + jedis.rpush(<span class="string">&quot;lists&quot;</span>, <span class="string">&quot;EnumMap&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists列表出栈（右端）：&quot;</span> + jedis.rpop(<span class="string">&quot;lists&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改lists指定下标1的内容：&quot;</span> + jedis.lset(<span class="string">&quot;lists&quot;</span>, <span class="number">1</span>, <span class="string">&quot;LinkedArrayList&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的长度：&quot;</span> + jedis.llen(<span class="string">&quot;lists&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取lists下标为2的元素：&quot;</span> + jedis.lindex(<span class="string">&quot;lists&quot;</span>, <span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;sortedList&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;sortedList排序前：&quot;</span> + jedis.lrange(<span class="string">&quot;sortedList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(jedis.sort(<span class="string">&quot;sortedList&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;sortedList排序后：&quot;</span> + jedis.lrange(<span class="string">&quot;sortedList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jedis-集合操作"><a href="#Jedis-集合操作" class="headerlink" title="Jedis 集合操作"></a>Jedis 集合操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">&quot;============向集合中添加元素============&quot;</span>);</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e4&quot;</span>, <span class="string">&quot;e3&quot;</span>, <span class="string">&quot;e0&quot;</span>, <span class="string">&quot;e8&quot;</span>, <span class="string">&quot;e7&quot;</span>, <span class="string">&quot;e5&quot;</span>));</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e6&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除一个元素e0：&quot;</span> + jedis.srem(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e0&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除两个元素e7和e6：&quot;</span> + jedis.srem(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e7&quot;</span>, <span class="string">&quot;e6&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;随机的移除集合中的一个元素：&quot;</span> + jedis.spop(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet中包含元素的个数：&quot;</span> + jedis.scard(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;e1是否在eleSet中：&quot;</span> + jedis.sismember(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;=================================&quot;</span>);</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e4&quot;</span>, <span class="string">&quot;e3&quot;</span>, <span class="string">&quot;e0&quot;</span>, <span class="string">&quot;e8&quot;</span>, <span class="string">&quot;e7&quot;</span>, <span class="string">&quot;e5&quot;</span>));</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet2&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e4&quot;</span>, <span class="string">&quot;e3&quot;</span>, <span class="string">&quot;e0&quot;</span>, <span class="string">&quot;e8&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;将eleSet1中删除e1并存入eleSet3中：&quot;</span> + jedis.smove(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet3&quot;</span>, <span class="string">&quot;e1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1中的元素：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet3中的元素：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;============集合运算=================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1中的元素：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet2中的元素：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1和eleSet2的交集:&quot;</span> + jedis.sinter(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1和eleSet2的并集:&quot;</span> + jedis.sunion(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1和eleSet2的差集:&quot;</span> + jedis.sdiff(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet2&quot;</span>));<span class="comment">//eleSet1中有，eleSet2中没有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jedis-有序集合操作"><a href="#Jedis-有序集合操作" class="headerlink" title="Jedis 有序集合操作"></a>Jedis 有序集合操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSortedSet</span><span class="params">()</span>&#123;</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    Map&lt;String,Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;key2&quot;</span>,<span class="number">1.5</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key3&quot;</span>,<span class="number">1.6</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key4&quot;</span>,<span class="number">1.9</span>);</span><br><span class="line">    System.out.println(jedis.zadd(<span class="string">&quot;zset&quot;</span>, <span class="number">3</span>,<span class="string">&quot;key1&quot;</span>));</span><br><span class="line">    System.out.println(jedis.zadd(<span class="string">&quot;zset&quot;</span>,map));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中的所有元素：&quot;</span>+jedis.zrangeByScore(<span class="string">&quot;zset&quot;</span>, <span class="number">0</span>,<span class="number">100</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中key2的分值：&quot;</span>+jedis.zscore(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中key2的排名：&quot;</span>+jedis.zrank(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除zset中的元素key3：&quot;</span>+jedis.zrem(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中的所有元素：&quot;</span>+jedis.zrange(<span class="string">&quot;zset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中元素的个数：&quot;</span>+jedis.zcard(<span class="string">&quot;zset&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中分值在1-4之间的元素的个数：&quot;</span>+jedis.zcount(<span class="string">&quot;zset&quot;</span>, <span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;key2的分值加上5：&quot;</span>+jedis.zincrby(<span class="string">&quot;zset&quot;</span>, <span class="number">5</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;key3的分值加上4：&quot;</span>+jedis.zincrby(<span class="string">&quot;zset&quot;</span>, <span class="number">4</span>, <span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中的所有元素：&quot;</span>+jedis.zrange(<span class="string">&quot;zset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redis-事务-锁机制"><a href="#Redis-事务-锁机制" class="headerlink" title="Redis 事务 锁机制"></a>Redis 事务 锁机制</h1><p>Redis  事务时一个单独的隔离操作  事务中的所有命令都会序列化 按顺序的执行  事务在执行的过程中  不会被其他客户端发送来的命令请求所打断<br>Redis事务的主要作用就是串联多个命令防止其他命令插队</p><h2 id="Multi-Exec-discard"><a href="#Multi-Exec-discard" class="headerlink" title="Multi Exec  discard"></a>Multi Exec  discard</h2><p>从输入Multi命令开始  输入的命令都会依次进入命令队列中  但不会执行  知道输入Exec后 Redis会将之前的命令队列中的命令依次执行<br>组队的过程中可以通过discard来放弃组队</p><ul><li>在组队中某个命令出现了错误  执行时整个的所有队列都会被取消</li><li>在执行阶段某个命令出现了错误  则只有报错的命令不会被执行 而其他的命令都会被执行</li></ul><h2 id="WATCH-UNWATCH"><a href="#WATCH-UNWATCH" class="headerlink" title="WATCH  UNWATCH"></a>WATCH  UNWATCH</h2><ul><li><p>在执行multi之前 先执行watch key1 [key2] 可以监视一个或者多个key  如果在事务执行之前这些key被其他命令所改动  那么事务将会被打断</p></li><li><p>unwatch 取消watch命令对所有key的监视</p></li><li><p>如果在执行watch命令之后 exec命令或discard命令先被执行了的话 那么就不需要在执行unwatch了</p></li></ul><h2 id="Redis-事务三特性"><a href="#Redis-事务三特性" class="headerlink" title="Redis 事务三特性"></a>Redis 事务三特性</h2><ul><li>单独隔离操作<ul><li>事务中的所有命令都会被序列化 按顺序的执行  事务在执行的过程中  不会被其他客户端发送来的命令请求所打断</li></ul></li><li>没有隔离级别的概念<ul><li>队列中的命令没有提交之前都不会实际被执行  因为事务提交前任何指令都不会被实际执行</li></ul></li><li>不保证原子性<ul><li>事务中如果有一条命令执行失败 其后的命令仍然会被执行  没有回滚</li></ul></li></ul><h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><h2 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB (Redis DataBase)"></a>RDB (Redis DataBase)</h2><p>在指定的时间间隔内将内存中的数据集快照写入磁盘  恢复时将快照文件直接读到内存里</p><h3 id="备份执行"><a href="#备份执行" class="headerlink" title="备份执行"></a>备份执行</h3><p>Redis 会单独创建(fork)一个子进程来进行持久化  会先将数据写入到一个临时文件中 待持久化过程都结束了  再用这个临时文件替换上次持久化好的文件<br>整个过程中  主进程时不进行任何IO操作的  这就确保了极高的性能  如果需要大规模数据的恢复  且对数据恢复的完整性不是非常敏感  那RDB方式要比AOF方式更加的高效<br>RDB的缺点是最后一次持久化后的数据可能会丢失</p><h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><ul><li>fork的作用是复制一个与当前进程一样的进程  新的进程的所有数据(变量 环境变量  程序计数器等)数值都和原进程一致  但是是一个全新的进程  并作为原进程的子进程</li><li>在Linux程序中 fork会产生一个和父进程完全相同的子进程 但子进程在此后多会exec系统调用 出于效率考虑  Linux中引入了<a href="https://cloud.tencent.com/developer/article/1914919">写时复制技术</a></li><li>一般情况父进程和子进程会共用同一段物理内存  只有进程空间的各段的内容要发生变化时  才会将父进程的内容复制一份给子进程</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>Fork的时候 内存中的数据被克隆了一份 大致2倍的膨胀性要考虑</li><li>虽然Redis在fork时使用了写时拷贝技术  但是如果数据庞大的时候还是比较消耗性能</li><li>在备份周期在一定间隔时间做一次备份 所以如果Redis意外down掉的话 就会丢失最后一次快照后的所有修改</li></ul><h2 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF (Append Only File)"></a>AOF (Append Only File)</h2><p>以日志的形式来记录每个写操作(增量保存) 将Redis执行过的所有写指令记录下来 只许追加文件但不可以改写文件 redis启动之初会读取该文件重新构建数据 换言之 redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><ul><li>AOF 默认不开启  在配置文件中开启</li><li>AOF 和 RDB 同时开启 系统默认读取AOF的数据(数据不会存在丢失)</li></ul><h3 id="AOF-同步频率设置"><a href="#AOF-同步频率设置" class="headerlink" title="AOF 同步频率设置"></a>AOF 同步频率设置</h3><ul><li>appendfsync always  始终同步 每次redis的写入都会立刻记入日志  性能较差但数据完整性比较好</li><li>appendfsync everysec 每秒同步 每秒记入日志一次 如果宕机 本秒的数据可能丢失</li><li>appendfsync no redis不主动进行同步  把同步时机交给操作系统</li></ul><h3 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h3><p>AOF 采用文件追加方式 文件越来越大为避免出现此种情况 新增了重写机制 当AOF文件的大小操作所设置的阈值时 Redis就会启动AOF文件的内容压缩 只保留可以恢复数据的最小指令集 可以使用命令 <strong>bgrewriteaof</strong></p><p>AOF文件持续增长而过大时  会fork出一条新进程来讲文件重写(先写临时文件最后在rename) redis4.0 版本后的重写 是指把rdb的快照 以二进制的形式附在新的aof头部 作为已有的历史数据  替换掉原来的流水账操作</p><h3 id="AOF-持久化流程"><a href="#AOF-持久化流程" class="headerlink" title="AOF 持久化流程"></a>AOF 持久化流程</h3><ul><li>客户端的请求写命令会被append追加到AOF缓冲区内</li><li>AOF缓冲区根据AOF持久化策略将操作sync同步到磁盘的AOF文件中</li><li>AOF文件大小超过重写策略或手动重写时 会对AOF文件rewrite重写 压缩AOF文件容量</li></ul><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ul><li>备份机制更稳健  丢失数据概率更低</li><li>可读的日志文本 通过操作AOF文件 可以处理误操作</li></ul><h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><ul><li>比起RDB占用更多的磁盘空间</li><li>恢复备份速度要慢</li><li>每次读写都同步的花  有一定的性能压力</li><li>存在个别bug  造成恢复不能</li></ul><h1 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h1><p>主机数据更新后根据配置和策略  自动同步到备机的(master&#x2F;slaver)机制 Master以写为主  Slave以读为主</p><ul><li>读写分离</li><li>容灾快速恢复  一台从服务器寄了之后可以从其他从服务器读取数据</li><li>info replication  打印主从服务器的信息</li><li>slave of &lt;ip&gt;&lt;port&gt;  成为某个实例的从服务器</li><li>slave of no one 取消从服务器</li><li>masterauth 密码  在配置文件中设置主服务器中的密码</li><li>从服务器挂了之后重启会从头开始复制主服务器中的数据 命令行只能设置一次性的主从关系  持久的主从关系要从配置文件中设置</li></ul><h2 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h2><ul><li>当从服务器连接上主服务器之后 从服务器向主服务器发送进行数据同步信息</li><li>主服务器收到从服务器发送过来的同步信息  把主服务器数据进行持久化rdb文件 把rdb文件发送给从服务器 从服务器拿到rdb文件之后进行读取</li><li>每次主服务器进行写操作之后 和从服务器进行数据同步</li></ul><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>能够后台监控主机是否故障  如果故障了根据投票数自动将从服务器转换为主服务器  哨兵继续监测新主机  原来主机哪怕重启也只能当新主机的从服务器</p><ul><li><p>新建sentinel.conf文件 写入 </p><blockquote><p>sentinel monitor mymaster ip  1</p></blockquote><ul><li>1 表示至少有多少个哨兵同意迁移的数量</li></ul></li><li><p>启动哨兵  </p><blockquote><p>redis-sentinel 哨兵配置文件的位置</p></blockquote></li><li><p>主机选择原则</p><ul><li>选择优先级靠前的     优先级在redis.conf中设置 默认为100</li><li>选择偏移量最大的      偏移量是指获得原主机数据最全的</li><li>选择runid最小的     每个redis实例启动后都会随机生成一个40位的runid</li></ul></li></ul><h1 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h1><p>Redis 集群实现了对Redis的水平扩容  即启动N个Redis节点  将整个数据库分布存储在这N个节点中  每个节点存储总数据的1&#x2F;N</p><p>Redis集群通过分区(partition)来提供一定程度的可用性(availability):即使集群中有一部分节点失效或这无法进行通讯  集群也可以继续处理命令请求</p><h2 id="redis-cluster配置修改"><a href="#redis-cluster配置修改" class="headerlink" title="redis cluster配置修改"></a>redis cluster配置修改</h2><ul><li>cluster-enabled yes 打开集群模式</li><li>cluster-config-file nodes-6379.conf 设定节点配置文件名</li><li>cluster-node-timeout 15000 设置节点失联时间  超过该时间(毫秒)，集群自动进行主从切换</li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>该部分由虚拟机模拟集群 正常情况在不同的服务器中的redis中设置这几个属性即可</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> /home/bigdata/redis.<span class="keyword">conf</span>  正常的redis配置文件</span><br><span class="line">------需要添加的部分--------------</span><br><span class="line">pidfile <span class="string">&quot;var/run/redis_6379.pid&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump6379.rdb&quot;</span></span><br><span class="line"><span class="keyword">dir</span> <span class="string">&quot;/home/bigdata/redis_cluster&quot;</span></span><br><span class="line">logfile <span class="string">&quot;/home/bigdata/redis_cluster/redis_err_6379.log&quot;</span></span><br><span class="line"><span class="keyword">cluster</span>-enabled yes</span><br><span class="line"><span class="keyword">cluster</span>-config-<span class="keyword">file</span> nodes-6379.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">cluster</span>-node-timeout 15000</span><br></pre></td></tr></table></figure><h2 id="构建集群"><a href="#构建集群" class="headerlink" title="构建集群"></a>构建集群</h2><ul><li>先进入redis的src命令</li><li>使用redis-cli –cluster create –cluster-replicas  1(表示从机数量) &lt;iplist&gt; 将redis的ip加端口加上创建集群</li><li>使用redis -c -p 进行集群策略连接  设置数据会自动切换到相应的写主机</li><li>使用cluster nodes 命令查看集群信息</li></ul><h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a>slots</h2><ul><li>一个Redis集群包含16384个插槽(hash slot),数据库中的每个键都属于这16384个插槽的其中一个</li><li>集群使用公式<a href="https://zhuanlan.zhihu.com/p/61636624">CRC16</a>(key) % 16384 来计算键key属于哪个槽  其中CRC16(key)语句用于计算键key的CRC16校验和</li><li>集群中的每个节点负责处理一部分插槽</li><li>cluster keyslot &lt;key&gt;  计算某个键的插槽值</li><li>cluster countkeysinslot 插槽值  查看某个插槽中值</li><li>cluster getkeysinslot 插槽值  返回某个插槽中的键</li></ul><h1 id="Redis-应用问题解决"><a href="#Redis-应用问题解决" class="headerlink" title="Redis 应用问题解决"></a>Redis 应用问题解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>key对应的数据在数据源并不存在  每次针对此key的请求从缓存获取不到  请求都会压到数据源  从而压垮数据源 比如用一个不存在的用户id获取用户信息 不论缓存还是数据库都没<br>有 若黑客利用此漏洞进行攻击可能压垮数据库</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>对空值进行缓存 <blockquote><p>如果一个查询返回的数据为空(不管数据是否真实存在) 我们仍然把这个空结果进行缓存  设置空结果的过期时间会很短  最长不会超过五分钟</p></blockquote></li><li>设置可访问名单<blockquote><p>使用bitmaps类型定义一个可以访问的名单 名单id作为bitmaps的偏移量 每次访问和bitmap里面的id进行比较  如果访问id不在bitmaps里面 进行拦截 不允许访问</p></blockquote></li><li>采用布隆过滤器 (Bloom Filter) 实际上是一个很长的二进制向量(位图)和一系列随机映射函数(哈希函数)<blockquote><p>布隆过滤器可以用于检索一个元素是否在一个集合中 它的有点是空间效率和查询时间都远远超过一般的算法 缺点是有一定的误识别率和删除困难将所有可能存在的数据哈希到一个足够大的bitmaps中 一个一定不存在的数据会被bitmaps拦截掉 从而避免了对底层存储系统的查询压力</p></blockquote></li><li>进行实时监控<blockquote><p>当发现Redis的命中率开始急速降低  需要排查访问对象和访问的数据  和运维人员配合 可以设置黑名单限制服务</p></blockquote></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>key对应的数据存在  但在redis中过期  此时若有大量并发请求过来  这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存  这个时候大并发的请求可能会瞬间把后端DB压垮</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>预先设置热门数据<blockquote><p>在redis高峰访问前 把一些热门数据提前存入到redis里面  加大这些热门数据key的时长</p></blockquote></li><li>实时调整  现场监控哪些数据热门 实时调整key的过期时长</li><li>使用锁<ul><li>在缓存失效的时候(判断拿出来的值为空) 不是立即去load db</li><li>先使用缓存工具的某些带成功操作返回值的操作(比如Redis的SETNX)</li></ul></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>key对应的数据存在  但在redis中过期  此时若有大量并发请求过来  这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存  这个时候大并发的请求可能会瞬间把后端DB压垮<br><br>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存 前者则是某一个key正常访问</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>构建多级缓存架构 nginx缓存+redis缓存+其他缓存</li><li>使用锁或者队列<blockquote><p>用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写  从而避免失效时大量的并发请求落到底层存储系统上  不适用高并发情况</p></blockquote></li><li>设置过期标志更新缓存<blockquote><p>记录缓存数据是否过期(设置提前量) 如果过期会触发通知另外的线程在后台去更新实际key的缓存</p></blockquote></li><li>将缓存失效时间分散开<blockquote><p>可以在原有的失效时间基础上增加一个随机值  比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低 就很难引发集体失效事件</p></blockquote></li></ul><h1 id="SpringBoot-整合-Redis"><a href="#SpringBoot-整合-Redis" class="headerlink" title="SpringBoot 整合 Redis"></a>SpringBoot 整合 Redis</h1><p>Redis配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span>      <span class="comment">// 开启缓存</span></span><br><span class="line"><span class="meta">@Configuration</span>      <span class="comment">// 配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置redistemplate相关配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 配置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jacksonSeial</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span></span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jacksonSeial.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 值采用json序列化</span></span><br><span class="line">        template.setValueSerializer(jacksonSeial);</span><br><span class="line">        <span class="comment">//使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置hash key 和value序列化模式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(jacksonSeial);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择redis作为默认缓存工具</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对hash类型的数据操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HashOperations&lt;String,String,Object&gt; <span class="title function_">hashOperations</span><span class="params">(RedisTemplate&lt;String,Object&gt; redisTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对redis字符串类型数据库操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ValueOperations&lt;String, Object&gt; <span class="title function_">valueOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对链表类型的数据操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ListOperations&lt;String, Object&gt; <span class="title function_">listOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对无序集合Set操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SetOperations&lt;String, Object&gt; <span class="title function_">setOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对有序集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ZSetOperations&lt;String, Object&gt; <span class="title function_">zSetOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf</title>
      <link href="/2022/11/05/Thymeleaf/"/>
      <url>/2022/11/05/Thymeleaf/</url>
      
        <content type="html"><![CDATA[<h1 id="Thymeleaf-模板引擎"><a href="#Thymeleaf-模板引擎" class="headerlink" title="Thymeleaf 模板引擎"></a>Thymeleaf 模板引擎</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Thymeleaf： 是使用java开发的模板技术， 在服务器端运行。 把处理后的数据发送给浏览器。</p><p>​         模板是作视图层工作的。  显示数据的。  Thymeleaf是基于Html语言。 Thymleaf语法是应用在</p><p>​        html标签中 。 SpringBoot框架集成Thymealeaf,  使用Thymeleaf代替jsp。</p><p>Thymeleaf 的官方网站：<a href="http://www.thymeleaf.org/">http://www.thymeleaf.org</a><br>Thymeleaf 官方手册：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html</a></p><span id="more"></span><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><ol><li><p>标准变量表达式 </p><p>语法：  ${key} </p><p>作用： 获取key对于的文本数据，  key 是request作用域中的key ， 使用request.setAttribute(), model.addAttribute()</p><p>在页面中的 html标签中， 使用 th:text&#x3D;”${key}”</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>标准变量表达式:  $&#123;key&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;site&#125;&quot;</span>&gt;</span>key不存在<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>获取SysUser对象 属性值<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;myuser.id&#125;&quot;</span>&gt;</span>id<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;myuser.name&#125;&quot;</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;myuser.sex&#125;&quot;</span>&gt;</span>姓名：m男<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;myuser.age&#125;&quot;</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;myuser.getName()&#125;&quot;</span>&gt;</span>获取姓名使用getXXX<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>选择变量表达式（ 星号变量表达式）</p><p>语法：  *{key}</p><p>作用： 获取这个key对应的数据，   *{key}需要和th:object 这个属性一起使用。</p><p>目的是简单获取对象的属性值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>使用 *&#123;&#125; 获取SysUser的属性值<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;myuser&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;sex&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;age&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>使用*&#123;&#125;完成的表示 对象的属性值<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;myuser.name&#125;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>链接表达式</p><p>语法： @{url}</p><p>作用： 表示链接， 可以</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"> , <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;...&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;..&quot;</span>&gt;</span> ,<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;...&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Thymeleaf属性"><a href="#Thymeleaf属性" class="headerlink" title="Thymeleaf属性"></a>Thymeleaf属性</h2><p>属性是放在html元素中的，就是html元素的属性，加入了th前缀。  属性的作用不变。    加入上th， 属性的值由模板引擎处理了。  在属性可以使用变量表达式</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/loginServlet&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;/loginServlet&quot;</span> <span class="attr">th:method</span>=<span class="string">&quot;$&#123;methodAttr&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="each"><a href="#each" class="headerlink" title="each"></a>each</h2><p>each循环， 可以循环List，Array</p><p>语法：</p><p>在一个html标签中，使用th:each</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;集合循环成员,循环的状态变量:$&#123;key&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;集合循环成员&#125;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">集合循环成员,循环的状态变量:两个名称都是自定义的。 “循环的状态变量”这个名称可以不定义，默认是&quot;集合循环成员Stat&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>each循环Map</p><p>在一个html标签中，使用th:each</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;集合循环成员,循环的状态变量:$&#123;key&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;集合循环成员.key&#125;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;集合循环成员.value&#125;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">集合循环成员,循环的状态变量:两个名称都是自定义的。 “循环的状态变量”这个名称可以不定义，默认是&quot;集合循环成员Stat&quot;</span><br><span class="line"></span><br><span class="line">key:map集合中的key</span><br><span class="line">value：map集合key对应的value值</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="th-if"><a href="#th-if" class="headerlink" title="th:if"></a>th:if</h2><p>“th:if”  : 判断语句， 当条件为true， 显示html标签体内， 反之不显示 没有else语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot; 10 &gt; 0 &quot;</span>&gt;</span> 显示文本内容 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有一个 th:unless  和 th:if相反的行为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:unless</span>=<span class="string">&quot; 10 &lt; 0 &quot;</span>&gt;</span> 当条件为false显示标签体内容 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例子：if</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span> if 使用<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;sex==&#x27;m&#x27;&#125;&quot;</span>&gt;</span>性别是男<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;isLogin&#125;&quot;</span>&gt;</span>已经登录系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;age &gt; 20&#125;&quot;</span>&gt;</span>年龄大于20<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&quot;&quot;空字符是true--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span>name是“”<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--null是false--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;isOld&#125;&quot;</span>&gt;</span> isOld是null<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子： unless</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h3</span>&gt;</span>unless: 判断条件为false，显示标签体内容<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;sex==&#x27;f&#x27;&#125;&quot;</span>&gt;</span>性别是男的<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;isLogin&#125;&quot;</span>&gt;</span>登录系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;isOld&#125;&quot;</span>&gt;</span> isOld是null <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="th-switch"><a href="#th-switch" class="headerlink" title="th:switch"></a>th:switch</h2><p>th:switch 和 java中的swith一样的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">&quot;要比对的值&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;值1&quot;</span>&gt;</span></span><br><span class="line">        结果1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;值2&quot;</span>&gt;</span></span><br><span class="line">        结果2</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;*&quot;</span>&gt;</span></span><br><span class="line">        默认结果</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    以上的case只有一个语句执行</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="th-inline"><a href="#th-inline" class="headerlink" title="th:inline"></a>th:inline</h2><ol><li><p>内联text：  在html标签外，获取表达式的值</p><p>语法： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>显示姓名是：[[$&#123;key&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>内联 text, 使用内联表达式显示变量的值<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:inline</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是[[$&#123;name&#125;]]，年龄是[[$&#123;age&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            我是<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>,年龄是<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;age&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用内联text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是[[$&#123;name&#125;]],性别是[[$&#123;sex&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>内联javascript</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:inline</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">var</span> myname = [[$&#123;name&#125;]];</span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">var</span> myage = [[$&#123;age&#125;]];</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">         <span class="comment">//alert(&quot;获取的模板中数据 &quot;+ myname + &quot;,&quot;+myage)</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;单击事件，获取数据 &quot;</span>+ myname + <span class="string">&quot;,&quot;</span>+ [[$&#123;sex&#125;]])</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>文本字面量: 使用单引号括起来的字符串<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;我是&#x27;+$&#123;name&#125;+&#x27;,我所在的城市&#x27;+$&#123;city&#125;&quot;</span>&gt;</span>数据显示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>数字字面量<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;20&gt;5&#125;&quot;</span>&gt;</span> 20大于 5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">h3</span>&gt;</span>boolean字面量<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;isLogin == true&#125;&quot;</span>&gt;</span>用户已经登录系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">h3</span>&gt;</span>null字面量<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;myuser != null&#125;&quot;</span>&gt;</span>有myuser数据<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p>连接字符串有两种语法</p><p>1） 语法使用 单引号括起来字符串  ， 使用 + 连接其他的 字符串或者表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;我是&#x27;+$&#123;name&#125;+&#x27;,我所在的城市&#x27;+$&#123;city&#125;&quot;</span>&gt;</span>数据显示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）语法：使用双竖线， |字符串和表达式|</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;|我是$&#123;name&#125;,我所在城市$&#123;city|&quot;</span>&gt;</span></span><br><span class="line">    显示数据</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h3</span>&gt;</span>字符串连接方式1：使用单引号括起来的字符串<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;我是&#x27;+$&#123;name&#125;+&#x27;,我所在的城市&#x27;+$&#123;city&#125;&quot;</span>&gt;</span>数据显示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>字符串连接方式2：|字符串和表达式|<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;|我是$&#123;name&#125;,所在城市$&#123;city&#125;,其他人$&#123;myuser.name&#125;|&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">算术运 算： + , - - , * , / , %</span><br><span class="line">关系比较 : &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</span><br><span class="line">相等判断： == , != ( eq , ne )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>使用运算符<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;age &gt; 10&#125;&quot;</span>&gt;</span>年龄大于 10 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123; 20 + 30 &#125;&quot;</span>&gt;</span>显示运算结果<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;myuser == null&#125;&quot;</span>&gt;</span>myuser是null<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;myuser eq null&#125;&quot;</span>&gt;</span>myuser是null<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;myuser ne null&#125;&quot;</span>&gt;</span>myuser不是null<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;isLogin == true ? &#x27;用户已经登录&#x27; : &#x27;用户需要登录&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;isLogin == true ? ( age &gt; 10 ? &#x27;用户是大于10的&#x27; : &#x27;用户年龄比较小&#x27;) : &#x27;用户需要登录&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">三元运算符：</span><br><span class="line"> 表达式  ？ true的结果 : false的结果</span><br><span class="line"></span><br><span class="line">三元运算符可以嵌套</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>文档地址：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#web-context-namespaces-for-requestsession-attributes-etc">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#web-context-namespaces-for-requestsession-attributes-etc</a>.</p><p>#request 表示 HttpServletRequest</p><p>#session 表示 HttpSession对象</p><p>session 表示Map对象的， 是#session的简单表示方式， 用来获取session中指定的key的值</p><p>​               #session.getAttribute(“loginname”) &#x3D;&#x3D; session.loginname</p><p>这些是内置对象，可以在模板文件中直接使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 350px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>内置对象#request,#session，session的使用<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>获取作用域中的数据<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getAttribute(&#x27;requestData&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#session.getAttribute(&#x27;sessionData&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.loginname&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>使用内置对象的方法<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        getRequestURL=<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getRequestURL()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        getRequestURI=<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getRequestURI()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        getQueryString=<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getQueryString()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        getContextPath=<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getContextPath()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        getServerName=<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getServerName()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        getServerPort=<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getServerPort()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="内置工具类"><a href="#内置工具类" class="headerlink" title="内置工具类"></a>内置工具类</h2><p>内置工具类型： Thymeleaf自己的一些类，提供对string， date ，集合的一些处理方法</p><p>#dates: 处理日器的工具类</p><p>#numbers:处理数字的</p><p>#lists: 处理list集合的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 350px&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>日期类对象 #dates<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(mydate )&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(mydate,&#x27;yyyy-MM-dd&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(mydate,&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.year(mydate)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.month(mydate)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.monthName(mydate)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.createNow()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>内置工具类#numbers，操作数字的<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#numbers.formatCurrency(mynum)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#numbers.formatDecimal(mynum,5,2)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>内置工具类#strings,操作字符串<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.toUpperCase(mystr)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.indexOf(mystr,&#x27;power&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.substring(mystr,2,5)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.substring(mystr,2)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.concat(mystr,&#x27;---java开发的黄埔军校---&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.length(mystr)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.length(&#x27;hello&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#strings.isEmpty(mystr)&#125;&quot;</span>&gt;</span> mystring 不是 空字符串  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>内置工具类#lists,操作list集合<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#lists.size(mylist)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.contains(mylist,&#x27;a&#x27;)&#125;&quot;</span>&gt;</span>有成员a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;!$&#123;#lists.isEmpty(mylist)&#125;&quot;</span>&gt;</span> list 集合有多个成员<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>处理null<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;zoo?.dog?.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h2><p>模板是内容复用， 定义一次，在其他的模板文件中多次使用。</p><p>模板使用：</p><p>1.定义模板</p><p>2.使用模板</p><p>模板定义语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">th:fragment=&quot;模板自定义名称&quot;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">&quot;head&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        动力节点-java开发</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        www.bjpowernode.com</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用模板语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) ~&#123;templatename :: selector&#125;</span><br><span class="line">   templatename:  文件名称</span><br><span class="line">   selector： 自定义模板名称</span><br><span class="line">2）templatename :: selector</span><br><span class="line">   templatename:  文件名称</span><br><span class="line">   selector： 自定义模板名称</span><br><span class="line"></span><br><span class="line">对于使用模板：有包含模板（th:include）， 插入模板(th:insert)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Thymeleaf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2022/11/02/SpringBoot/"/>
      <url>/2022/11/02/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p><span id="more"></span><h1 id="第一章-JavaConfig"><a href="#第一章-JavaConfig" class="headerlink" title="第一章  JavaConfig"></a>第一章  JavaConfig</h1><ol><li><p>为什么要使用 Spring Boot</p><p>因为Spring， SpringMVC 需要使用的大量的配置文件 （xml文件）</p><p>还需要配置各种对象，把使用的对象放入到spring容器中才能使用对象</p><p>需要了解其他框架配置规则。</p></li><li><p>SpringBoot 就相当于 不需要配置文件的Spring+SpringMVC。 常用的框架和第三方库都已经配置好了。</p><p>拿来就可以使用了。</p></li><li><p>SpringBoot开发效率高，使用方便多了</p></li></ol><h2 id="1-1-JavaConfig"><a href="#1-1-JavaConfig" class="headerlink" title="1.1 JavaConfig"></a>1.1 JavaConfig</h2><p>JavaConfig: 使用java类作为xml配置文件的替代， 是配置spring容器的纯java的方式。 在这个java类这可以创建java对象，把对象放入spring容器中（注入到容器）， </p><p>使用两个注解：</p><p>1）@Configuration ： 放在一个类的上面，表示这个类是作为配置文件使用的。</p><p>2）@Bean：声明对象，把对象注入到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"><span class="keyword">package</span> com.bjpowernode.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bjpowernode.vo.Student;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configuration:表示当前类是作为配置文件使用的。 就是用来配置容器的</span></span><br><span class="line"><span class="comment"> *       位置：在类的上面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  SpringConfig这个类就相当于beans.xml</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建方法，方法的返回值是对象。 在方法的上面加入<span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment">     * 方法的返回值对象就注入到容器中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span>: 把对象注入到spring容器中。 作用相当于&lt;bean&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     位置：方法的上面</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     说明：<span class="doctag">@Bean</span>,不指定对象的名称，默认是方法名是 id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">createStudent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        s1.setAge(<span class="number">26</span>);</span><br><span class="line">        s1.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 指定对象在容器中的名称（指定&lt;bean&gt;的id属性）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span>的name属性，指定对象的名称（id）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;lisiStudent&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">makeStudent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        s2.setAge(<span class="number">22</span>);</span><br><span class="line">        s2.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-2-ImporResource"><a href="#1-2-ImporResource" class="headerlink" title="1.2 @ImporResource"></a>1.2 @ImporResource</h2><p>@ImportResource 作用导入其他的xml配置文件， 等于 在xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resources</span>=<span class="string">&quot;其他配置文件&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(value =&#123; &quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-PropertyResource"><a href="#1-3-PropertyResource" class="headerlink" title="1.3 @PropertyResource"></a>1.3 @PropertyResource</h2><p>@PropertyResource: 读取properties属性配置文件。 使用属性配置文件可以实现外部化配置 ，</p><p>在程序代码之外提供数据。</p><p>步骤：</p><ol><li>在resources目录下，创建properties文件， 使用k&#x3D;v的格式提供数据</li><li>在PropertyResource 指定properties文件的位置</li><li>使用@Value（value&#x3D;”${key}”）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(value =&#123; &quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:config.properties&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.bjpowernode.vo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二-章-Spring-Boot"><a href="#第二-章-Spring-Boot" class="headerlink" title="第二 章 Spring Boot"></a>第二 章 Spring Boot</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>SpringBoot是Spring中的一个成员， 可以简化Spring，SpringMVC的使用。 他的核心还是IOC容器。</p><p>特点：</p><ul><li><p>Create stand-alone Spring applications</p><p> 创建spring应用</p></li><li><p>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</p><p>内嵌的tomcat， jetty ， Undertow </p></li><li><p>Provide opinionated ‘starter’ dependencies to simplify your build configuration</p><p>提供了starter起步依赖，简化应用的配置。   </p><p>比如使用MyBatis框架 ， 需要在Spring项目中，配置MyBatis的对象 SqlSessionFactory ， Dao的代理对象</p><p>在SpringBoot项目中，在pom.xml里面, 加入一个 mybatis-spring-boot-starter依赖</p></li><li><p>Automatically configure Spring and 3rd party libraries whenever possible</p><p>尽可能去配置spring和第三方库。叫做自动配置（就是把spring中的，第三方库中的对象都创建好，放到容器中， 开发人员可以直接使用）</p></li><li><p>Provide production-ready features such as metrics, health checks, and externalized configuration</p><p> 提供了健康检查， 统计，外部化配置</p></li><li><p>Absolutely no code generation and no requirement for XML configuration</p><p>不用生成代码， 不用使用xml，做配置</p></li></ul><h2 id="2-2-创建Spring-Boot项目"><a href="#2-2-创建Spring-Boot项目" class="headerlink" title="2.2 创建Spring Boot项目"></a>2.2 创建Spring Boot项目</h2><h3 id="2-2-1-第一种方式，-使用Spring提供的初始化器，-就是向导创建SpringBoot应用"><a href="#2-2-1-第一种方式，-使用Spring提供的初始化器，-就是向导创建SpringBoot应用" class="headerlink" title="2.2.1 第一种方式， 使用Spring提供的初始化器， 就是向导创建SpringBoot应用"></a>2.2.1 第一种方式， 使用Spring提供的初始化器， 就是向导创建SpringBoot应用</h3><p>使用的地址： <a href="https://start.spring.io/">https://start.spring.io</a></p><p>SpringBoot项目的结构：</p><p><img src="/2022/11/02/SpringBoot/course\25-SpringBoot\笔记\images\image-20210115152427829.png" alt="image-20210115152427829">    </p><h3 id="2-2-1-使用国内的地址"><a href="#2-2-1-使用国内的地址" class="headerlink" title="2.2.1  使用国内的地址"></a>2.2.1  使用国内的地址</h3><p><a href="https://start.springboot.io/">https://start.springboot.io</a></p><p><img src="/2022/11/02/SpringBoot/course\25-SpringBoot\笔记\images\image-20210115155556662.png" alt="image-20210115155556662">    </p><h2 id="2-3-注解的使用"><a href="#2-3-注解的使用" class="headerlink" title="2.3  注解的使用"></a>2.3  注解的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">符合注解：由</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span><span class="meta">@SpringBootConfiguration</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Configuration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：使用了<span class="meta">@SpringBootConfiguration</span>注解标注的类，可以作为配置文件使用的，</span><br><span class="line">    可以使用Bean声明对象，注入到容器</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.@EnableAutoConfiguration</p><p>启用自动配置， 把java对象配置好，注入到spring容器中。例如可以把mybatis的对象创建好，放入到容器中</p><p>3.@ComponentScan</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span> 扫描器，找到注解，根据注解的功能创建对象，给属性赋值等等。</span><br><span class="line">默认扫描的包： <span class="meta">@ComponentScan</span>所在的类所在的包和子包。</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="2-4-SpringBoot的配置文件"><a href="#2-4-SpringBoot的配置文件" class="headerlink" title="2.4 SpringBoot的配置文件"></a>2.4 SpringBoot的配置文件</h2><p>配置文件名称： application</p><p>扩展名有： properties( k&#x3D;v) ;  yml ( k: v)</p><p>使用application.properties,   application.yml</p><p>例1：application.properties设置 端口和上下文</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置端口号</span><br><span class="line">server.port=8082</span><br><span class="line">#设置访问应用上下文路径， contextpath</span><br><span class="line">server.servlet.context-path=/myboot</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例2： application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/myboot2</span></span><br></pre></td></tr></table></figure><h2 id="2-5-多环境配置"><a href="#2-5-多环境配置" class="headerlink" title="2.5 多环境配置"></a>2.5 多环境配置</h2><p>有开发环境， 测试环境， 上线的环境。</p><p>每个环境有不同的配置信息， 例如端口， 上下文件， 数据库url，用户名，密码等等</p><p>使用多环境配置文件，可以方便的切换不同的配置。</p><p>使用方式： 创建多个配置文件， 名称规则： application-环境名称.properties(yml)</p><p>创建开发环境的配置文件： application-dev.properties(  application-dev.yml )</p><p>创建测试者使用的配置： application-test.properties</p><h2 id="2-6-ConfigurationProperties"><a href="#2-6-ConfigurationProperties" class="headerlink" title="2.6 @ConfigurationProperties"></a>2.6 @ConfigurationProperties</h2><p>@ConfigurationProperties: 把配置文件的数据映射为java对象。</p><p>属性：prefix 配置文件中的某些key的开头的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;school&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchoolInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String website;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getWebsite</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> website;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWebsite</span><span class="params">(String website)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.website = website;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SchoolInfo&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, website=&#x27;&quot;</span> + website + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#配置端口号</span><br><span class="line">server.port=8082</span><br><span class="line">#context-path</span><br><span class="line">server.servlet.context-path=/myboot</span><br><span class="line"></span><br><span class="line">#自定义key=value</span><br><span class="line">school.name=动力节点</span><br><span class="line">school.website=www.bjpowernode.com</span><br><span class="line">school.address=北京的大兴区</span><br><span class="line"></span><br><span class="line">site=www.bjpowernode.com</span><br></pre></td></tr></table></figure><h2 id="2-7-使用容器"><a href="#2-7-使用容器" class="headerlink" title="2.7 使用容器"></a>2.7 使用容器</h2><p>你想通过代码，从容器中获取对象。</p><p>通过SpringApplication.run(Application.class, args); 返回值获取容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;primarySource&#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConfigurableApplicationContext : 接口，是ApplicationContext的子接口</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">ApplicationContext</span></span><br></pre></td></tr></table></figure><h2 id="2-8-ComnandLineRunner-接口-，-ApplcationRunner接口"><a href="#2-8-ComnandLineRunner-接口-，-ApplcationRunner接口" class="headerlink" title="2.8 ComnandLineRunner 接口 ，  ApplcationRunner接口"></a>2.8 ComnandLineRunner 接口 ，  ApplcationRunner接口</h2><p>这两个接口都 有一个run方法。 执行时间在容器对象创建好后， 自动执行run（）方法。</p><p>可以完成自定义的在容器对象创建好的一些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第三章-Web组件"><a href="#第三章-Web组件" class="headerlink" title="第三章 Web组件"></a>第三章 Web组件</h1><p>讲三个内容： 拦截器， Servlet ，Filter</p><h2 id="3-1-拦截器"><a href="#3-1-拦截器" class="headerlink" title="3.1 拦截器"></a>3.1 拦截器</h2><p>拦截器是SpringMVC中一种对象，能拦截器对Controller的请求。</p><p>拦截器框架中有系统的拦截器， 还可以自定义拦截器。  实现对请求预先处理。</p><p>实现自定义拦截器：</p><ol><li><p>创建类实现SpringMVC框架的HandlerInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2.需在SpringMVC的配置文件中，声明拦截器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    &lt;mvc:path=&quot;url&quot; /&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;拦截器类全限定名称&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot中注册拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加拦截器对象， 注入到容器中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建拦截器对象</span></span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定拦截的请求uri地址</span></span><br><span class="line">        String path []= &#123;<span class="string">&quot;/user/**&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//指定不拦截的地址</span></span><br><span class="line">        String excludePath  [] = &#123;<span class="string">&quot;/user/login&quot;</span>&#125;;</span><br><span class="line">        registry.addInterceptor(interceptor)</span><br><span class="line">                .addPathPatterns(path)</span><br><span class="line">                .excludePathPatterns(excludePath);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-Servlet"><a href="#3-2-Servlet" class="headerlink" title="3.2  Servlet"></a>3.2  Servlet</h2><p>在SpringBoot框架中使用Servlet对象。</p><p>使用步骤：</p><ol><li>创建Servlet类。 创建类继承HttpServlet</li><li>注册Servlet ，让框架能找到Servlet</li></ol><p> 例子：</p><p>1.创建自定义Servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Servlet类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       <span class="comment">//使用HttpServletResponse输出数据，应答结果</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span>  <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;===执行的是Servlet==&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>注册Servlet</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebApplictionConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法， 注册Servlet对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">servletRegistrationBean</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public ServletRegistrationBean(T servlet, String... urlMappings)</span></span><br><span class="line">        <span class="comment">//第一个参数是 Servlet对象， 第二个是url地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ServletRegistrationBean bean =</span></span><br><span class="line">                <span class="comment">//new ServletRegistrationBean( new MyServlet(),&quot;/myservlet&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>();</span><br><span class="line">        bean.setServlet( <span class="keyword">new</span> <span class="title class_">MyServlet</span>());</span><br><span class="line">        bean.addUrlMappings(<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/test&quot;</span>); <span class="comment">// &lt;url-pattern&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-过滤器Filter"><a href="#3-3-过滤器Filter" class="headerlink" title="3.3 过滤器Filter"></a>3.3 过滤器Filter</h2><p>Filter是Servlet规范中的过滤器，可以处理请求， 对请求的参数， 属性进行调整。 常常在过滤器中处理字符编码</p><p>在框架中使用过滤器：</p><ol><li>创建自定义过滤器类</li><li>注册Filter过滤器对象</li></ol><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了MyFilter，doFilter &quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebApplicationConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">filterRegistrationBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">FilterRegistrationBean</span> <span class="variable">bean</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line">        bean.setFilter( <span class="keyword">new</span> <span class="title class_">MyFilter</span>());</span><br><span class="line">        bean.addUrlPatterns(<span class="string">&quot;/user/*&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-字符集过滤器"><a href="#3-4-字符集过滤器" class="headerlink" title="3.4 字符集过滤器"></a>3.4 字符集过滤器</h2><p>CharacterEncodingFilter : 解决post请求中乱码的问题</p><p>在SpringMVC框架， 在web.xml 注册过滤器。 配置他的属性。 </p><p>第一种方式：</p><p>使用步骤：</p><ol><li><p>配置字符集过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSystemConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册Servlet</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">servletRegistrationBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyServlet</span> <span class="variable">myServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyServlet</span>();</span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(myServlet,<span class="string">&quot;/myservlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> reg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册Filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">filterRegistrationBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">FilterRegistrationBean</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用框架中的过滤器类</span></span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        <span class="comment">//指定使用的编码方式</span></span><br><span class="line">        filter.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//指定request ， response都使用encoding的值</span></span><br><span class="line">        filter.setForceEncoding(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        reg.setFilter(filter);</span><br><span class="line">        <span class="comment">//指定 过滤的url地址</span></span><br><span class="line">        reg.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改application.properties文件， 让自定义的过滤器起作用</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#SpringBoot中默认已经配置了CharacterEncodingFilter。 编码默认ISO-8859-1</span></span><br><span class="line"><span class="comment">#设置enabled=false 作用是关闭系统中配置好的过滤器， 使用自定义的CharacterEncodingFilter</span></span><br><span class="line"><span class="attr">server.servlet.encoding.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>第二种方式</p><p>修改application.properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">9001</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/myboot</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#让系统的CharacterEncdoingFilter生效</span></span><br><span class="line"><span class="attr">server.servlet.encoding.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#指定使用的编码方式</span></span><br><span class="line"><span class="attr">server.servlet.encoding.charset</span>=<span class="string">utf-8</span></span><br><span class="line"><span class="comment">#强制request，response都使用charset属性的值</span></span><br><span class="line"><span class="attr">server.servlet.encoding.force</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h1 id="第四章-ORM-操作-MySQL"><a href="#第四章-ORM-操作-MySQL" class="headerlink" title="第四章 ORM 操作 MySQL"></a>第四章 ORM 操作 MySQL</h1><p>使用MyBatis框架操作数据，  在SpringBoot框架集成MyBatis</p><p>使用步骤：</p><ol><li><p>mybatis起步依赖 ： 完成mybatis对象自动配置， 对象放在容器中</p></li><li><p>pom.xml 指定把src&#x2F;main&#x2F;java目录中的xml文件包含到classpath中</p></li><li><p>创建实体类Student</p></li><li><p>创建Dao接口 StudentDao , 创建一个查询学生的方法 </p></li><li><p>创建Dao接口对应的Mapper文件， xml文件， 写sql语句</p></li><li><p>创建Service层对象， 创建StudentService接口和他的实现类。 去dao对象的方法。完成数据库的操作</p></li><li><p>创建Controller对象，访问Service。</p></li><li><p>写application.properties文件</p><p>配置数据库的连接信息。</p></li></ol><h3 id="第一种方式-：-Mapper"><a href="#第一种方式-：-Mapper" class="headerlink" title="第一种方式 ： @Mapper"></a>第一种方式 ： @Mapper</h3><p>@Mapper：放在dao接口的上面， 每个接口都需要使用这个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Mapper</span>：告诉MyBatis这是dao接口，创建此接口的代理对象。</span></span><br><span class="line"><span class="comment"> *     位置：在类的上面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    Student <span class="title function_">selectById</span><span class="params">(<span class="meta">@Param(&quot;stuId&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种方式-MapperScan"><a href="#第二种方式-MapperScan" class="headerlink" title="第二种方式  @MapperScan"></a>第二种方式  @MapperScan</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@MapperScan</span>: 找到Dao接口和Mapper文件</span></span><br><span class="line"><span class="comment"> *     basePackages：Dao接口所在的包名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.bjpowernode.dao&quot;,&quot;com.bjpowernode.mapper&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三种方式：-Mapper文件和Dao接口分开管理"><a href="#第三种方式：-Mapper文件和Dao接口分开管理" class="headerlink" title="第三种方式： Mapper文件和Dao接口分开管理"></a>第三种方式： Mapper文件和Dao接口分开管理</h3><p> 现在把Mapper文件放在resources目录下</p><p>1）在resources目录中创建子目录 （自定义的） ， 例如mapper</p><p>2）把mapper文件放到 mapper目录中</p><p>3）在application.properties文件中，指定mapper文件的目录</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定mapper文件的位置</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="comment">#指定mybatis的日志</span></span><br><span class="line"><span class="attr">mybatis.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在pom.xml中指定 把resources目录中的文件 ， 编译到目标目录中</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--resources插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="第四个-事务"><a href="#第四个-事务" class="headerlink" title="第四个  事务"></a>第四个  事务</h3><p>Spring框架中的事务：</p><p>1） 管理事务的对象： 事务管理器（接口， 接口有很多的实现类）</p><p>​      例如：使用Jdbc或mybatis访问数据库，使用的事务管理器：DataSourceTransactionManager</p><p>2 ) 声明式事务：  在xml配置文件或者使用注解说明事务控制的内容</p><p>​     控制事务： 隔离级别，传播行为， 超时时间</p><p>3）事务处理方式：</p><p>​      1） Spring框架中的@Transactional</p><p>​      2)    aspectj框架可以在xml配置文件中，声明事务控制的内容</p><p>​    </p><p>SpringBoot中使用事务： 上面的两种方式都可以。</p><p>1）在业务方法的上面加入@Transactional ,  加入注解后，方法有事务功能了。</p><p>2）明确的在 主启动类的上面 ，加入@EnableTransactionManager</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Transactional</span>: 表示方法的有事务支持</span></span><br><span class="line"><span class="comment"> *       默认：使用库的隔离级别， REQUIRED 传播行为； 超时时间  -1</span></span><br><span class="line"><span class="comment"> *       抛出运行时异常，回滚事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;业务方法addStudent&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span>  <span class="operator">=</span>  studentDao.insert(student);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行sql语句&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抛出一个运行时异常， 目的是回滚事务</span></span><br><span class="line">    <span class="comment">//int m   = 10 / 0 ;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2022/10/09/SpringMVC/"/>
      <url>/2022/10/09/SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SpringMVC 是一种基于 Java 的实现 MVC(Model-View-Controller) 设计模型的请求驱动类型的轻量级 Web 框架 </p><span id="more"></span><h1 id="创建SpringMVC对象"><a href="#创建SpringMVC对象" class="headerlink" title="创建SpringMVC对象"></a>创建SpringMVC对象</h1><ul><li><p>声明springmvc核心对象DispatcherServlet</p></li><li><p>需要在tomcat启动后创建DispatcherServlet的实例</p></li><li><p>DispatcherServlet 在创建过程中 会同时创建springmvc对象</p></li><li><p>读取springmvc的配置文件 把这个配置文件中的对象都创建好 当用户发送请求时就可以直接使用对象了</p></li><li><p>处理用户提交的请求  springmvc中使用方法来处理<br>方法是自定义的 可以有多种返回值  多种参数 方法名称自定义</p></li><li><p>servlet的初始化会执行init 方法 </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DispatcherServlet 在init方法中&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建容器对象  读取配置文件</span></span><br><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;springmvc.xml&quot;</span>);</span><br><span class="line"><span class="comment">//把容器中的对象放入到ServletContext中</span></span><br><span class="line">getServletContext().setAttribute(key,cxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="web-xml的配置"><a href="#web-xml的配置" class="headerlink" title="web.xml的配置"></a>web.xml的配置</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      在tomcat启动后 创建servlet对象</span></span><br><span class="line"><span class="comment">      load-on-startup 表示tomcat 启动后创建对象的顺序  值为整数 数值越小</span></span><br><span class="line"><span class="comment">      创建对象越早   是个大于等于0的整数</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--        自定义springmvc的配置文件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--            springmvc的配置文件的位置属性--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--            指定自定义文件的位置--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      使用框架的时候  url-pattern 可以使用两种值</span></span><br><span class="line"><span class="comment">      - 使用扩展名方式  语法  ***.do</span></span><br><span class="line"><span class="comment">      - 使用斜杠 &quot;/&quot;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      当项目中使用了 / 时  它会替代tomcat中的default</span></span><br><span class="line"><span class="comment">       导致所有的静态资源 都给DispatcherServlet 处理  默认情况下  DispatcherServlet 没有处理静态资源的能力</span></span><br><span class="line"><span class="comment">       所以静态资源将无法访问</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="SpringMVC-注解"><a href="#SpringMVC-注解" class="headerlink" title="SpringMVC 注解"></a>SpringMVC 注解</h1><ul><li>@RequestMapping  请求映射  作用是把一个请求地址和一个方法绑定在一起一个请求指定一个方法处理<ul><li>属性<ul><li>value  是一个string  表示请求的url地址（some.do）<br> value 的值必须是一致的  不能重复</li><li>method  表示请求的方式  它的值RequestMethod类枚举值例如表示get请求方式 RequestMethod.Get or  Post</li></ul></li><li>位置<ul><li>在方法的上面   </li><li>在类的上面  所有请求地址的公共部分  叫做模块名称</li></ul></li><li>使用@RequestMapping 修饰的方法叫做处理器方法 该方法可以处理请求 类似doGet doPost</li></ul></li><li>返回值<ul><li>Model  数据  请求处理完成后  要显示给用户的数据</li><li>View  视图   比如jsp等等</li></ul></li></ul><h1 id="SpringMVC-接收参数"><a href="#SpringMVC-接收参数" class="headerlink" title="SpringMVC 接收参数"></a>SpringMVC 接收参数</h1><ul><li><p>逐个接受用户的请求参数</p><ul><li>要求<ul><li>处理器方法的形参名与请求中参数名一致</li><li>同名的参数赋值给同名的形参</li></ul></li></ul></li><li><p>框架接受请求参数</p><ul><li>使用request 对象接受请求参数<blockquote><p>String strName &#x3D; request.getParameter(“name”)</p></blockquote></li><li>框架通过DisoatcherServlet 调用方法  调用方法时按名称对应将接受的参数赋值给形参并进行相应的类型转换</li></ul></li><li><p>请求中参数名称和处理器方法形参不一样时</p><ul><li>使用@RequestParam 给变量起别名<ul><li>属性   <ul><li>value   请求中参数名称(别名)</li><li>required  是一个Boolean  默认是true  表示请求中必须包含此参数</li></ul></li><li>位置<br>在处理器方法的形参定义的前面</li></ul></li></ul></li><li><p>处理器方法是java对象  </p><ul><li>要求这个对象的属性名与请求中参数名一致<br>框架会创建形参的java对象  并调用set方法对属性赋值</li></ul></li></ul><h1 id="SpringMVC-返回值"><a href="#SpringMVC-返回值" class="headerlink" title="SpringMVC 返回值"></a>SpringMVC 返回值</h1><ul><li>处理器方法返回String    表示逻辑视图名称或数据  需要配置视图解析器<ul><li>区分返回值string是不是数据  看有没有@ResponseBody注解 有则是数据 否则是视图</li><li>当charset默认为ISO-8859-1 时  会出现中文乱码  在@RequestMapping中设置   produces &#x3D; “text&#x2F;plain;charset &#x3D; utf-8”</li></ul></li><li>放回值是void 不能表示数据 也不能表示视图<ul><li>在处理ajax的时候  可以使用void返回值  通过HttpServletResponse输出数据  响应ajax请求</li><li>ajax请求服务器返回的就是数据  和视图无关</li></ul></li><li>返回值是Object   返回的对象是数据  和视图无关<br>可以使用对象表示的数据  响应ajax请求<ul><li>实现步骤<ul><li>加入处理json的的工具库依赖 springmvc默认使用的是jackjson</li><li>在spring配置文件之间加入<a href="mvc:annotation-driven">mvc:annotation-driven</a>注解驱动<br>  json &#x3D; om.writeValueString(Object);<br>  注解驱动完成的功能  完成java对象到json xml  text  二进制等数据的转换</li><li>在处理器方法上加入@ResponseBody注解<br>  response.setContextType(“”application&#x2F;json;charset &#x3D; utf-8)<br>  PrintWriter pw &#x3D; response.getWriter();<br>  pw.println(json);</li></ul></li></ul></li></ul><h1 id="SpringMVC-处理静态资源"><a href="#SpringMVC-处理静态资源" class="headerlink" title="SpringMVC 处理静态资源"></a>SpringMVC 处理静态资源</h1><ul><li>第一种处理静态资源的方式<br><ul><li>需要在springmvc的配置文件中加入<a href="mvc:default-servlet-handler">mvc:default-servlet-handler</a></li><li>加入该标签后  框架会创建一个控制器对象DefaultServletHttpRequestHandler （类似自己创建的myController）</li><li>DefaultServletHttpRequestHandler这个对象可以把接收的请求 转发给 tomcat的default这个servlet  实现静态资源的访问</li></ul></li><li>第二种处理静态资源的方式<ul><li>mvc:resource 加入后框架会创建  ResourceHttpServletHandler 这个处理器对象</li><li>让这个对象处理静态资源的访问  不依赖tomcat服务器<ul><li>mapping 访问静态资源的url地址 可以使用通配符 **</li><li>location 静态资源在项目中的位置  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><strong>default-servlet-handler 与 @RequestMapping 有冲突  加上注解驱动解决</strong></p><h1 id="SpringMVC-Forward-and-Redirect"><a href="#SpringMVC-Forward-and-Redirect" class="headerlink" title="SpringMVC Forward and Redirect"></a>SpringMVC Forward and Redirect</h1><ul><li>处理器返回ModelAndView 实现转发forward<ul><li>语法 setViewName（“forward：视图文件的完整路径”）</li><li>forward  特点  不和视图解析器一同使用  就当项目中没有视图解析器</li></ul></li><li>处理器返回ModelAndView 实现转发redirect<ul><li>语法 setViewName（“redirect：视图文件的完整路径”）</li><li>redirect  特点  不和视图解析器一同使用  就当项目中没有视图解析器<br>进行重定向时加入模型的数据会拼接到地址的后面  类似get请求 可以通过获取param来获得数据<h1 id="SpringMVC-配置文件"><a href="#SpringMVC-配置文件" class="headerlink" title="SpringMVC 配置文件"></a>SpringMVC 配置文件</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    声明组件扫描器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kris.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    声明 视图解析器 帮助开发人员设置视图文件的路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        前缀  视图文件的路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        后缀   视图文件的拓展名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="SpringMVC-处理异常"><a href="#SpringMVC-处理异常" class="headerlink" title="SpringMVC 处理异常"></a>SpringMVC 处理异常</h1><ul><li>定义一个全局异常类 加上@ControllerAdvice注解<ul><li>@ControllerAdvice : 控制器增强（也就是说给控制器类增加功能–异常处理功能）<ul><li>位置：在类的上面。</li><li>特点：必须让框架知道这个注解所在的包名，需要在springmvc配置文件声明组件扫描器。<br>指定@ControllerAdvice所在的包名</li></ul></li></ul></li><li>处理异常的方法和控制器方法的定义一样， 可以有多个参数，可以有ModelAndView,<br>String, void,对象类型的返回值<ul><li>形参：Exception，表示Controller中抛出的异常对象。<br>通过形参可以获取发生的异常信息。</li><li>@ExceptionHandler(异常的class)：表示异常的类型，当发生此类型异常时，由当前方法处理</li></ul></li></ul><h1 id="SpringMVC-拦截器"><a href="#SpringMVC-拦截器" class="headerlink" title="SpringMVC 拦截器"></a>SpringMVC 拦截器</h1><ul><li><p>拦截器类需要实现HandlerInterceptor接口 接口中有 preHandle postHandle   afterCompletion 三个方法</p><ul><li><p>preHandle 预处理器对象</p><ul><li>参数<ul><li>Object  handle 被拦截的控制器对象</li></ul></li><li>返回值<ul><li>true  通过拦截器 可以执行控制器方法</li><li>false  无法通过拦截器  请求被拦截</li></ul></li></ul></li><li><p>特点</p><ul><li>方法在控制器方法之前先执行  用户的请求首先到达此方法</li><li>在这个方法中可以获取请求的信息  验证该请求是否符合要求</li><li>可以验证用户是否登录以及用户是否用权限访问某个连接地址</li><li>如果验证失败 可以截断请求 请求不能被处理</li><li>如果验证成功  可以放行请求  此时控制器方法才可以执行</li></ul></li><li><p>postHandle 后处理方法</p><ul><li>参数<ul><li>Object  被拦截的处理器对象</li><li>ModelAndView 处理器方法的返回值</li></ul></li><li>特点</li><li>在处理器方法之后执行的</li><li>能够获取到处理器方法的返回值ModelAndView  可以修改返回的视图和数据  可以影响到最后的执行结果</li><li>主要是对原来的执行结果进行二次修正</li></ul></li><li><p>afterCompletion 最后执行的方法</p><ul><li>参数<ul><li>Object handler 被拦截的处理器对象</li><li>Exception ex  程序中发生的异常</li></ul></li><li>特点<ul><li>在请求处理完成后执行  框架中规定是当你的视图处理完成后 对视图执行了forward 就认为请求处理完成</li><li>一般做资源回收工作的  程序请求过程中创建了一些对象  在这里可以删除  把占用的内存回收</li></ul></li></ul></li></ul></li><li><p>声明拦截器  拦截器可以有0个或多个</p></li><li><p>在框架中保存多个拦截器是ArrayList</p></li><li><p>按照声明的先后顺序放入到list中</p><h2 id="拦截器的声明"><a href="#拦截器的声明" class="headerlink" title="拦截器的声明"></a>拦截器的声明</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        声明第一个拦截器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            指定拦截的url地址</span></span><br><span class="line"><span class="comment">            path 就是url地址  可以使用通配符 **</span></span><br><span class="line"><span class="comment">                ** 表示任意字符  文件或者多级目录和目录下的文件</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            声明拦截器对象--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.handler.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        第二个拦截器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.handler.MyInterceptor2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="SpringMVC处理post请求参数乱码问题"><a href="#SpringMVC处理post请求参数乱码问题" class="headerlink" title="SpringMVC处理post请求参数乱码问题"></a>SpringMVC处理post请求参数乱码问题</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    注册声明过滤器  解决post请求参数乱码问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>character<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>foreResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>character<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树</title>
      <link href="/2022/09/17/HuffmanTree/"/>
      <url>/2022/09/17/HuffmanTree/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近</p><span id="more"></span><h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><p><strong>路径</strong>：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。</p><p><strong>路径长度</strong>：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。</p><p><strong>结点的权</strong>：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。</p><p><strong>结点的带权路径长度</strong>：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 &#x3D; 10 。</p><h1 id="构建哈夫曼树的过程"><a href="#构建哈夫曼树的过程" class="headerlink" title="构建哈夫曼树的过程"></a>构建哈夫曼树的过程</h1><ul><li>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</li><li>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；</li><li>重复 上述步骤 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;             </span><br><span class="line">        <span class="comment">//创建哈夫曼树</span></span><br><span class="line">        <span class="type">HNode</span> <span class="variable">root</span> <span class="operator">=</span> creatHuffmanTree(arr);</span><br><span class="line">        <span class="comment">//遍历哈夫曼树</span></span><br><span class="line">        traversal(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建赫夫曼树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 创建赫夫曼树需要的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回赫夫曼树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HNode <span class="title function_">creatHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//用于存储结点的链表</span></span><br><span class="line">        List&lt;HNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HNode&gt;();</span><br><span class="line">        <span class="comment">//循环数组 将其中的值创建为结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> it : arr) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">HNode</span>(it));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行循环创建哈夫曼树</span></span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//先进行排序</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到最小的结点</span></span><br><span class="line">            <span class="type">HNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//找到次小的结点</span></span><br><span class="line">            <span class="type">HNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建这两个结点的二叉树</span></span><br><span class="line">            <span class="type">HNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HNode</span>(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">//删除已经处理过的结点</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">            <span class="comment">//将其父节点加入链表</span></span><br><span class="line">            list.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回赫夫曼树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(HNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        System.out.println(root.value);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)</span><br><span class="line">            traversal(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)</span><br><span class="line">            traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HNode</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;HNode&gt;&#123;</span><br><span class="line">    <span class="comment">//结点的权</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">//结点的左右子节点</span></span><br><span class="line">    HNode left,right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HNode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(HNode o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.value &gt; o.value)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.value == o.value)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// public boolean equals(Object obj) &#123;</span></span><br><span class="line">    <span class="comment">//     Node node = (Node) obj;</span></span><br><span class="line">    <span class="comment">//     if(this.value == node.value)</span></span><br><span class="line">    <span class="comment">//         return true;</span></span><br><span class="line">    <span class="comment">//     return false;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://c.biancheng.net/view/3398.html">C语言中文网</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2022/09/16/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/09/16/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。</p><span id="more"></span><ul><li><p>堆排序是一种选择排序 它的最坏 最好 平均时间复杂度均为O(nlogn) 是一种不稳定排序</p></li><li><p>堆具有以下性质的完全二叉树 每个结点的值都大于或者等于其左右子节点值<br>称为大顶堆  <strong>没有要求结点的左子节点的值和右子节点的值的大小关系</strong></p></li><li><p>每个结点的值都小于或等于其左右子节点的值 称为小顶堆</p></li></ul><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性 使得每次从无序中选择最大记录(最小记录)变得简单</p><ul><li>将待排序的序列构造成一个最大堆 此时序列的最大值为根节点</li><li>一次将根节点与待排序序列的最后一个元素交换</li><li>再维护从根节点到该元素的前一个结点为最大堆 如此往复 最终得到一个递增序列</li></ul><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素。</li><li>再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys ≤ R[n-1].key</li><li>由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。</li><li>直到无序区只有一个元素为止。</li></ul><p><a href="http://www.rmboot.com/HeapSort.html">快速排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;             </span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr  排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//第一个非叶子结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> (len -<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//对非叶子结点逐个判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            adjustHeap(i,len,arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 进行堆处理的非叶子节点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len  数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> len,<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//非叶子节点的左子节点下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (index &lt;&lt; <span class="number">1</span>) +<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//非叶子节点的右子节点下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左右节点较大值的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果下标超出范围 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; len) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//获取较大数的下标</span></span><br><span class="line">        <span class="keyword">if</span>(right &lt;= len &amp;&amp; arr[right] &gt; arr[left])</span><br><span class="line">            maxIndex = right;</span><br><span class="line">        <span class="comment">//如果子节点的值大于根节点的值</span></span><br><span class="line">        <span class="comment">//将其交换  再检测交换后子树的堆</span></span><br><span class="line">        <span class="keyword">if</span>(arr[maxIndex] &gt; arr[index])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(maxIndex,index,arr);</span><br><span class="line">            adjustHeap(maxIndex, len, arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> maxIndex,<span class="type">int</span> index,<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[maxIndex];</span><br><span class="line">        arr[maxIndex] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/124885051">知乎-developer1024</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2022/08/13/HashTable/"/>
      <url>/2022/08/13/HashTable/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>哈希表也叫散列表，哈希表是一种数据结构，它提供了快速的插入操作和查找操作，无论哈希表总中有多少条数据，插入和查找的时间复杂度都是为O(1)，因为哈希表的查找速度非常快，所以在很多程序中都有使用哈希表，例如拼音检查器</p><span id="more"></span><p>哈希表采用的是一种转换思想，其中一个中要的概念是如何将「键」或者「关键字」转换成数组下标？在哈希表中，这个过程有哈希函数来完成，但是并不是每个「键」或者「关键字」都需要通过哈希函数来将其转换成数组下标，有些「键」或者「关键字」可以直接作为数组的下标。</p><h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><blockquote><p>哈希函数的作用是帮我们把非int的「键」或者「关键字」转化成int，可以用来做数组的下标</p></blockquote><p>哈希函数就是一种<strong>映射</strong>，是从关键字到存储地址的映射。 通常，包含哈希函数的算法的算法复杂度都假设为O(1)，这就是为什么在哈希表中搜索数据的时间复杂度会被认为是”平均为O(1)的复杂度”.</p><ul><li>哈希函数的定义域必须包括需要存储的全部关键码，而如果哈希表允许有m个地址时，其值域必须在0 到m-1之间</li><li>哈希函数计算出来的地址能均匀分布在整个空间中</li><li>哈希函数应该比较简单</li></ul><h2 id="除留余数法（最常用）"><a href="#除留余数法（最常用）" class="headerlink" title="除留余数法（最常用）"></a>除留余数法（最常用）</h2><p>函数：Hash（key）&#x3D;key MOD p （p&lt;&#x3D;m m为表长），求出来的hash(key)就为存储该key的下标</p><p>例如有一下数据{2, 4, 6, 8, 9}<br>表长为10，也就是数组容量为10</p><h2 id="直接定制法（常用）"><a href="#直接定制法（常用）" class="headerlink" title="直接定制法（常用）"></a>直接定制法（常用）</h2><p>取关键字的某个线性函数为散列地址(A、B为常数)：Hash（Key）&#x3D; A*Key + B<br>优点：简单、均匀<br>缺点：需要事先知道关键字的分布情况<br>适用场景：适合查找较小数据范围且连续的情况</p><h2 id="平方取中法（少）"><a href="#平方取中法（少）" class="headerlink" title="平方取中法（少）"></a>平方取中法（少）</h2><p>如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。<br>使用举例<br>比如key&#x3D;1234 1234^2&#x3D;1522756 取227作hash地址<br>比如key&#x3D;4321 4321^2&#x3D;18671041 取671作hash地址<br>适用场景：事先不知道数据并且数据长度较小的情况</p><h1 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h1><p>即不同的key通过同一哈希函数产生了相同的哈希位置，H（key1）&#x3D;H（key2），例如我们在除留余数法中的例子，如果此时插入一个12，其hash(12)为2，此时下标为2的位置已经有元素，此时就会产生哈希冲突</p><h1 id="处理哈希冲突"><a href="#处理哈希冲突" class="headerlink" title="处理哈希冲突"></a>处理哈希冲突</h1><h2 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h2><blockquote><p>从计算的哈希位置开始，往后找到第一个空闲的位置存放数据</p></blockquote><p><strong>待补充</strong></p><h2 id="开散列"><a href="#开散列" class="headerlink" title="开散列"></a>开散列</h2><blockquote><p>开散列方法又叫链地址法，哈希表中存储的是链表的头结点。具有相同的哈希地址会存放在同一链表中，每个链表中的元素都具有相同的哈希地址。</p></blockquote><p><img src="/2022/08/13/HashTable/%E5%BC%80%E6%95%A3%E5%88%97.png" alt="开散列"></p><p>该哈希表示由指针数组来组成的，每个数组中的元素都是一个链表的头指针。从该表中我们可以看出，产生哈希冲突的元素并不会占用其他元素的位置，每个链表中的元素都是哈希冲突的元素</p><ul><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHashTable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个哈希表</span></span><br><span class="line">        <span class="type">HashTab</span> <span class="variable">hashTab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTab</span>();</span><br><span class="line">        <span class="comment">// 创建几个数据</span></span><br><span class="line">        <span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">2</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">3</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">4</span>, <span class="string">&quot;l2&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">5</span>, <span class="string">&quot;l3&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">7</span>, <span class="string">&quot;l3&quot;</span>);</span><br><span class="line">        <span class="comment">// 加入数据</span></span><br><span class="line">        hashTab.add(p1);</span><br><span class="line">        hashTab.add(p2);</span><br><span class="line">        hashTab.add(p3);</span><br><span class="line">        hashTab.add(p4);</span><br><span class="line">        hashTab.add(p5);</span><br><span class="line">        hashTab.add(p6);</span><br><span class="line">        <span class="comment">// 遍历哈希表</span></span><br><span class="line">        hashTab.list();</span><br><span class="line">        <span class="comment">//查找数据</span></span><br><span class="line">        System.out.println(hashTab.search(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//删除数据</span></span><br><span class="line">        hashTab.delete(<span class="number">1</span>);</span><br><span class="line">        hashTab.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 编写哈希表 用于管理链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTab</span> &#123;</span><br><span class="line">    <span class="comment">// 初始容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 存储数据的链表数组</span></span><br><span class="line">    PeoLinkedList[] peoLinkedLists;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 无参构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashTab() &#123;</span><br><span class="line">        peoLinkedLists = <span class="keyword">new</span> <span class="title class_">PeoLinkedList</span>[capacity];</span><br><span class="line">        init(peoLinkedLists);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 有参构造方法 提供初始化容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashTab(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        peoLinkedLists = <span class="keyword">new</span> <span class="title class_">PeoLinkedList</span>[capacity];</span><br><span class="line">        init(peoLinkedLists);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始化链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(PeoLinkedList[] peoLinkedLists)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            peoLinkedLists[i] = <span class="keyword">new</span> <span class="title class_">PeoLinkedList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取存储链表的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getListNo</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(People p)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取存储链表的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getListNo(p.id);</span><br><span class="line">        <span class="comment">// 存储数据</span></span><br><span class="line">        peoLinkedLists[index].add(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 查找对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> People <span class="title function_">search</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取存储链表的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getListNo(id);</span><br><span class="line">        <span class="comment">// 查找数据</span></span><br><span class="line">        <span class="keyword">return</span> peoLinkedLists[index].search(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 删除对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取存储链表的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getListNo(id);</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        peoLinkedLists[index].delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 遍历哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; peoLinkedLists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (peoLinkedLists[i].getHead() == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            peoLinkedLists[i].list();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个类</span></span><br><span class="line"><span class="comment"> * 编写一个链表 往其中添加数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeoLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// 头指针 用于指向第一个数据</span></span><br><span class="line">    <span class="keyword">private</span> People head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用于往链表中添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(People p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">People</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span> (cur.next != <span class="literal">null</span>)</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            cur.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用于遍历该链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(cur.toString());</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> People <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 查找对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> People <span class="title function_">search</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">People</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.id == id)</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 删除对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">            <span class="type">People</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">            cur.next = head;</span><br><span class="line">            <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.next.id == id)</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个自定义类</span></span><br><span class="line"><span class="comment"> * 往哈希表中存储该类信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    People next;</span><br><span class="line">   </span><br><span class="line">    People()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    People(<span class="type">int</span> id, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">&quot; &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashTable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2022/08/12/BinarySearch/"/>
      <url>/2022/08/12/BinarySearch/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>二分查找是一个对<strong>有序列表</strong>进行查找的一个算法</p><span id="more"></span><p>二分查找的实现原理非常简单，首先要有一个有序的列表。但是如果没有，则该怎么办？可以使用排序算法进行排序。</p><p>以升序数列为例，比较一个元素与数列中的中间位置的元素的大小，如果比中间位置的元素大，则继续在后半部分的数列中进行二分查找；如果比中间位置的元素小，则在数列的前半部分进行比较；如果相等，则找到了元素的位置。每次比较的数列长度都会是之前数列的一半，直到找到相等元素的位置或者最终没有找到要找的元素</p><h1 id="二分法的第一种写法"><a href="#二分法的第一种写法" class="headerlink" title="二分法的第一种写法"></a>二分法的第一种写法</h1><p>第一种写法定义target在左闭右闭的区间内  也就是[left,right]<br>区间的定义决定了二分法的写法   因为target在[left,right]的区间内</p><ul><li>while(left &lt;&#x3D; right) 要使用 &lt;&#x3D;  就要保证left &#x3D;&#x3D; right 是有意义的</li><li>在这种情况下  right要赋值为mid-1   因为这个nums[mid]一定不等于target  那么接下来要查找的左区间结束下标位置就是mid-1<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;       </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">else</span> </span><br><span class="line">            <span class="variable">right</span> <span class="operator">=</span> mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二分法的第二种写法"><a href="#二分法的第二种写法" class="headerlink" title="二分法的第二种写法"></a>二分法的第二种写法</h1><p>第一种写法定义target在左闭右开的区间内  也就是[left,right)<br>区间的定义决定了二分法的写法   因为target在[left,right)的区间内</p><ul><li>while(left &lt; right) 因为在区间[left,right)  left &#x3D;&#x3D; right 是没有意义的</li><li>在这种情况下  right要赋值为mid  即下一个查询区间不会去比较nums[mid]<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length ;    <span class="comment">//区别一   </span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;        <span class="comment">//区别二</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">else</span> </span><br><span class="line">            <span class="variable">right</span> <span class="operator">=</span> mid;        <span class="comment">//区别三</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li>递归<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">22</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">66</span>,<span class="number">88</span>&#125;;</span><br><span class="line">        <span class="comment">//查找函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> search(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,<span class="number">34</span>);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 二分查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获得中间下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>; <span class="comment">//防止整数型溢出</span></span><br><span class="line">        <span class="comment">//如果找到直接返回下标</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="comment">//如果中间值大于目标值 则左递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            <span class="keyword">return</span>  search(nums, left, mid-<span class="number">1</span>, target);</span><br><span class="line">        <span class="comment">//如果中间值小于目标值 则右递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            <span class="keyword">return</span> search(nums, mid+<span class="number">1</span>, right, target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h1><a href="/2023/02/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="704.二分查找">704.二分查找</a> <p><a href="https://leetcode.cn/problems/binary-search/">leetcode地址</a><br></p><a href="/2023/02/21/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/" title="35.搜索插入位置">35.搜索插入位置</a><p><a href="https://leetcode.cn/problems/search-insert-position/">leetcode地址</a><br></p><a href="/2023/02/21/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/" title="34.在排序数组中查找元素的第一个和最后一个位置">34.在排序数组中查找元素的第一个和最后一个位置</a> <p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">leetcode地址</a><br></p><a href="/2023/02/22/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/" title="69.x的平方根">69.x的平方根</a> <p><a href="https://leetcode.cn/problems/sqrtx/">leetcode地址</a><br></p><a href="/2023/02/22/%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%A0%B9/" title="367.有效的完全平方根">367.有效的完全平方根</a> <p><a href="https://leetcode.cn/problems/valid-perfect-square/">leetcode地址</a><br></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基数排序</title>
      <link href="/2022/08/12/RadixSort/"/>
      <url>/2022/08/12/RadixSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数</p><span id="more"></span><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>找到最大数的位置 决定了循环几轮</li><li>将数组中的数每轮按照个,十,百等位数放入相应的数组(桶)中</li><li>在将其按顺序取出</li><li>循环结束时便排好了序</li></ul><p><a href="http://www.rmboot.com/RadixSort.html">基数排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基数排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//找到最大的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> findMax(nums);</span><br><span class="line">        <span class="comment">//获得最大数的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建二维数组 作为n个桶</span></span><br><span class="line">        <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用一维数组记录桶中元素的个数</span></span><br><span class="line">        <span class="type">int</span>[] numOfBucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行基数排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,n = <span class="number">1</span>;i &lt; maxLength;i++, n*=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="comment">//逐个获取数字的个位数 并存入桶中</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> nums[j]/n % <span class="number">10</span>;</span><br><span class="line">                bucket[digit][numOfBucket[digit]] = nums[j];</span><br><span class="line">                numOfBucket[digit]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从桶中挨个取出数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; numOfBucket.length;k++)&#123;</span><br><span class="line">                <span class="comment">//如果桶中数据不为0则取出</span></span><br><span class="line">                <span class="keyword">if</span>(numOfBucket[k] != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;l &lt; numOfBucket[k];l++)&#123;</span><br><span class="line">                        nums[index++] = bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                numOfBucket[k] = <span class="number">0</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 找到最大的数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max)</span><br><span class="line">                max = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2022/08/12/QuickSort/"/>
      <url>/2022/08/12/QuickSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法</p><span id="more"></span><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</p></li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">快速排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">//测试数组</span></span><br><span class="line">         <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">         <span class="comment">//排序函数</span></span><br><span class="line">         sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">         <span class="comment">//打印结果</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">             System.out.println(i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 快速排序</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//左下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//右下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="comment">//获取基准值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[(left+right) /<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="comment">//在左边找到一个大于基准值的值</span></span><br><span class="line">            <span class="keyword">while</span>(nums[l] &lt; pivot)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="comment">//在右边找到一个小于基准值的值</span></span><br><span class="line">            <span class="keyword">while</span>(nums[r] &gt; pivot)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="comment">//如果l大于r 则表示基准值左边都小于基准则 右边则都大于</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, l, r);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//避免与基准值相同的值一直交换</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] == pivot)</span><br><span class="line">                r--; </span><br><span class="line">            <span class="keyword">if</span>(nums[r] == pivot)</span><br><span class="line">                l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止栈溢出</span></span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; r)</span><br><span class="line">            sort(nums, left, r);</span><br><span class="line">        <span class="comment">//右递归</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; l)</span><br><span class="line">            sort(nums, l, right);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 交换两个数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        temp = nums[l];</span><br><span class="line">        nums[l] = nums[r];</span><br><span class="line">        nums[r] = temp;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2022/08/11/MergeSort/"/>
      <url>/2022/08/11/MergeSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用</p><span id="more"></span><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）</li><li>自下而上的迭代</li></ul><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p></li><li><p>重复步骤 3 直到某一指针达到序列尾；</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p></li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">归并排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序的辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] aux;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自底向上的归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> [] a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">//分配与数组相等的空间</span></span><br><span class="line">        aux = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">        <span class="comment">// sort(a,0,a.length-1);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> <span class="number">1</span>; sz &lt; N;sz = sz+sz)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>;lo &lt; N - sz;lo += sz+sz)&#123;</span><br><span class="line">                merge(a, lo, lo+sz-<span class="number">1</span>,Math.min(lo+sz+sz-<span class="number">1</span>, N));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 自顶向上的归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// private static void  sort(int[] a,int lo,int hi) &#123;</span></span><br><span class="line">    <span class="comment">//     if(hi &lt;= lo)</span></span><br><span class="line">    <span class="comment">//         return;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int mid = lo + (hi - lo)/2;</span></span><br><span class="line">    <span class="comment">//     //将左边排序</span></span><br><span class="line">    <span class="comment">//     sort(a, lo, mid);</span></span><br><span class="line">    <span class="comment">//     //将右边排序</span></span><br><span class="line">    <span class="comment">//     sort(a, mid+1, hi);</span></span><br><span class="line">    <span class="comment">//     merge(a, lo ,mid,hi);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> lo,<span class="type">int</span> mid,<span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将所有元素复制到辅助数组中 备份数据 在原数组中修改 避免数据丢失</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo;k &lt;= hi;k++)&#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo;k &lt;= hi;k++)&#123;</span><br><span class="line">            <span class="comment">//左边用尽取右边数组</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++];</span><br><span class="line">            <span class="comment">//右边用尽取左边数组</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi)     a[k] = aux[i++];</span><br><span class="line">            <span class="comment">//正常比较 取较小数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aux[j]  &lt; aux[i])   a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2022/08/11/ShellSort/"/>
      <url>/2022/08/11/ShellSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法</p><span id="more"></span><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1</li><li>按增量序列个数 k，对序列进行 k 趟排序</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度</li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">希尔排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellionSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 希尔排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 确定间隔 取3*x+1 分组 </span></span><br><span class="line">        <span class="keyword">while</span>(h &lt; <span class="number">3</span>/N) h = <span class="number">3</span>*h+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当 间隔减为1之前 对每个组进行组内排序</span></span><br><span class="line">        <span class="comment">//在减为1之前 对组内排序的结果是整个数组大致有序</span></span><br><span class="line">        <span class="comment">//最后对整个数组进行插入排序</span></span><br><span class="line">        <span class="comment">//希尔排序的本质是插入排序  插入排序在数组大致有序的情况下拥有最高性能</span></span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h;i &lt; N;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &gt;= h&amp;&amp;nums[j] &lt; nums[j-h];j-=h)&#123;</span><br><span class="line">                    swap(nums, j, j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums , <span class="type">int</span> index_1,<span class="type">int</span> index_2)</span>&#123;</span><br><span class="line">        <span class="comment">//交换值相同时  不交换</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index_1] == nums[index_2])</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index_1];</span><br><span class="line">        nums[index_1] = nums[index_2];</span><br><span class="line">        nums[index_2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2022/08/11/InsertionSort/"/>
      <url>/2022/08/11/InsertionSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p><span id="more"></span><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">插入排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">//测试数组</span></span><br><span class="line">         <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">         <span class="comment">//排序函数</span></span><br><span class="line">         sort(nums);</span><br><span class="line">         <span class="comment">//打印结果</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">             System.out.println(i);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="comment">// 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录要插入的数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从已经排序的序列最右边的开始比较，找到比其小的数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存在比其小的数，插入</span></span><br><span class="line">            <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2022/08/11/SelectionSort/"/>
      <url>/2022/08/11/SelectionSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好</p><span id="more"></span><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li><li>重复第二步，直到所有元素均排序完毕</li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">选择排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//一层循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            <span class="comment">//暂存目前下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[min])</span><br><span class="line">                    <span class="comment">//当前值小于之前的最小值时 更新下标</span></span><br><span class="line">                    min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从头到尾将最小值放置</span></span><br><span class="line">            swap(nums, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums , <span class="type">int</span> index_1,<span class="type">int</span> index_2)</span>&#123;</span><br><span class="line">        <span class="comment">//交换值相同时  不交换</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index_1] == nums[index_2])</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index_1];</span><br><span class="line">        nums[index_1] = nums[index_2];</span><br><span class="line">        nums[index_2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2022/08/11/BubbleSort/"/>
      <url>/2022/08/11/BubbleSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法</p><span id="more"></span><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><p>冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来<br>说并没有什么太大作用。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">冒泡排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//用于测试的数组</span></span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2022/08/11/Recursion/"/>
      <url>/2022/08/11/Recursion/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>递归(Recursion)是一种解决问题的有效方法 在递归过程中 函数将自身作为子例程调用</p></blockquote><span id="more"></span><p>递归的思想是把一个大型复杂问题层层转化为一个与原问题规模更小的问题，问题被拆解成子问题后，递归调用继续进行，直到子问题无需进一步递归就可以解决的地步为止。</p><p><img src="/2022/08/11/Recursion/Recursion.png" alt="Recursion"></p><h1 id="什么时候考虑递归"><a href="#什么时候考虑递归" class="headerlink" title="什么时候考虑递归"></a>什么时候考虑递归</h1><ul><li>当问题和子问题具有递推关系 比如杨辉三角 计算阶乘等</li><li>具有递归性质的数据结构 比如链表 树 图</li><li>反向性问题  比如取反</li></ul><h1 id="递归需要遵守的重要规则"><a href="#递归需要遵守的重要规则" class="headerlink" title="递归需要遵守的重要规则"></a>递归需要遵守的重要规则</h1><ul><li>执行一个方法时 就创建一个新的受保护的独立空间</li><li>方法的局部变量是独立的 不会相互影响</li><li>如果方法中使用的引用类型变量(数组等) 就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近 否则就是无限递归</li><li>当一个方法执行完毕 或者遇到return 就会返回 遵守谁调用 就将结果返回给谁 同时当方法执行完毕或者返回时 该方法也就执行完毕</li></ul><h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h1><blockquote><p>尾递归函数是递归函数的一种，其中递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用</p></blockquote><p>尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。可以理解为，在程序执行到递归函数最后一条递归调用指令时回收了当前的栈空间（其实是复用了当前的栈空间）</p><h1 id="采用递归解法的几个经典问题"><a href="#采用递归解法的几个经典问题" class="headerlink" title="采用递归解法的几个经典问题"></a>采用递归解法的几个经典问题</h1><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">factorial</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(fact(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n * fact(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="斐波纳契数"><a href="#斐波纳契数" class="headerlink" title="斐波纳契数"></a>斐波纳契数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(fib(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EightQueen</span> &#123;</span><br><span class="line">    <span class="comment">//定义皇后的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">QUEEN_NUM</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//定义一个数组 保存皇后放置位置的结果</span></span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[QUEEN_NUM];</span><br><span class="line">    <span class="comment">//总解法数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EightQueen</span> <span class="variable">eightQueen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EightQueen</span>();</span><br><span class="line">        <span class="comment">//从第一行开始放置</span></span><br><span class="line">        eightQueen.place(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//打印总解法数</span></span><br><span class="line">        System.out.println(eightQueen.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将皇后的位置输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//只有得到解时才会打印 所以count可以++</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : array)</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 查看我们放置第n个皇后 就去检测该皇后是否与前面已经摆放好了的皇后冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="comment">//判断竖直方向和斜向</span></span><br><span class="line">        <span class="keyword">if</span>(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 放置第n个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">place</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == QUEEN_NUM)&#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次放入皇后 并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; QUEEN_NUM;i++)&#123;</span><br><span class="line">            <span class="comment">//从第一列开始</span></span><br><span class="line">            array[n] = i;</span><br><span class="line">            <span class="comment">//判断是否冲突</span></span><br><span class="line">            <span class="keyword">if</span>(judge(n))&#123;</span><br><span class="line">                <span class="comment">//不冲突 放置下一个</span></span><br><span class="line">                place(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//冲突则i++ 将皇后放置到下一列再次判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2022/08/06/Stack/"/>
      <url>/2022/08/06/Stack/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>栈（stack）又名堆栈，是一个先入后出(FIFO-First In Last Out)的有序列表</p><span id="more"></span><ul><li>栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表 允许插入和删除的一端 为变化的一段 称为栈顶(Top) 另一端为固定的一段 称为栈底(Bottom)</li><li>最先放入栈中的元素在栈底 最后放入的元素在栈顶 而删除元素刚好相反 最后放入的元素最先删除 最先放入的元素最后删除</li></ul><p><img src="/2022/08/06/Stack/Stack.png" alt="Stack"></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>子程序的调用 在跳往子程序前 会将下一个指令的地址存到堆栈中 直到子程序执行完后再将地址取出 以回到原来的程序中</li><li>表达式的转换(中缀表达式转后缀表达式)与求值</li><li>双叉树的遍历</li><li>图形的深度优先搜索</li></ul><h1 id="使用数组实现栈"><a href="#使用数组实现栈" class="headerlink" title="使用数组实现栈"></a>使用数组实现栈</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">//指向栈顶</span></span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="comment">//用于存储数据的数组</span></span><br><span class="line">    <span class="type">int</span> arr[];</span><br><span class="line">    <span class="comment">//初始化容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">INIT_CAPACITY</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//记录数量</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 无参构造方法</span></span><br><span class="line"><span class="comment">     * 初始化变量</span></span><br><span class="line"><span class="comment">     * 将数组初始容量设为6 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MyStack()&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        top = -<span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[INIT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当前栈中元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> item)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())</span><br><span class="line">            addCapaty();</span><br><span class="line">        arr[++top] = item;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断栈满</span></span><br><span class="line"><span class="comment">     * 将其私有化</span></span><br><span class="line"><span class="comment">     * 仅用于内部判断其是否等于当前最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= INIT_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始容量不够时重新分配空间</span></span><br><span class="line"><span class="comment">     * 将原来的数组复制过来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCapaty</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;EMPTY!!!&quot;</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> arr[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 返回栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 测试方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyStack</span> <span class="variable">myStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStack</span>();</span><br><span class="line">        myStack.push(<span class="number">1</span>);</span><br><span class="line">        myStack.push(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回栈元素数量测试</span></span><br><span class="line">        System.out.println(myStack.capacity());</span><br><span class="line"></span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//返回栈顶元素测试</span></span><br><span class="line">        myStack.push(<span class="number">1</span>);</span><br><span class="line">        System.out.println(myStack.peek());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//栈空出栈测试</span></span><br><span class="line">        System.out.println(myStack.pop()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dijkstra-的双栈算术表达式求值算法"><a href="#Dijkstra-的双栈算术表达式求值算法" class="headerlink" title="Dijkstra 的双栈算术表达式求值算法"></a>Dijkstra 的双栈算术表达式求值算法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Dijkstra 的双栈算术表达式求值算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraDoubleStack</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;(1+((2+3)*(4*5)))&quot;</span>;</span><br><span class="line">        <span class="comment">//存储符号</span></span><br><span class="line">        Stack&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储数字与结果</span></span><br><span class="line">        Stack&lt;Double&gt; vals = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//如果是左括号 跳过</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="comment">//将符号压入栈中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;+&#x27;</span>) </span><br><span class="line">                ops.push(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                ops.push(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                ops.push(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                ops.push(s.charAt(i));</span><br><span class="line">            <span class="comment">//遇到右括号时将所需要的两个数弹出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//弹出符号 判断进行哪个运算</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> ops.pop();</span><br><span class="line">                <span class="type">double</span> <span class="variable">v</span> <span class="operator">=</span> vals.pop();</span><br><span class="line">                <span class="keyword">if</span>(ch == <span class="string">&#x27;+&#x27;</span>) v = vals.pop()+v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) v = vals.pop()-v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;*&#x27;</span>) v = vals.pop()*v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;/&#x27;</span>) v = vals.pop()/v;</span><br><span class="line">                <span class="comment">//计算好结果后将结果压入vals栈中</span></span><br><span class="line">                vals.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">//不是上述情况则是数字 将其压入vals栈中</span></span><br><span class="line">                vals.push(Double.parseDouble(s.charAt(i)+<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后剩下的就是结果</span></span><br><span class="line">        System.out.println(vals.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无括号的表达式则比较运算符的优先级</li><li>如果当前的操作符的优先级小于等于栈中的操作符</li><li>就pop出两个数和一个符号进行运算 否则直接入栈</li></ul><h1 id="前缀-中缀-后缀表达式"><a href="#前缀-中缀-后缀表达式" class="headerlink" title="前缀 中缀 后缀表达式"></a>前缀 中缀 后缀表达式</h1><h2 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h2><ul><li>前缀表达式又称波兰式 前缀表达式的运算符位于操作数之前</li><li>举例<ul><li>(3+4) x 5 - 6 对应的前缀表达式是- x + 3 4 5 6</li></ul></li><li>计算机求值时从右至左扫描表达式 遇到数字时 将数字压入栈中</li><li>遇到运算符时弹出栈顶的两个数 进行计算 并将结果入栈</li><li>重复以上操作</li></ul><h2 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h2><ul><li>中缀表达式就是常见的运算表达式 </li><li>举例 <ul><li>(3+4)x5-6</li></ul></li><li>中缀表达式的求值是人最熟悉的 但是对计算机来说缺不好操作因此在计算时往往会将其转成其他表达式来操作(一般转成后缀表达式)</li></ul><h2 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h2><ul><li>后缀表达式又称逆波兰表达式 与前缀表达式相似 知识运算符位于操作数之后</li><li>举例<ul><li>(3+4)x5-6 对应的后缀表达式是 34+5 x 6-</li></ul></li><li>计算机求值时 从左至右扫描表达式 遇到数字时 将数字压入堆栈 遇到运算符时 弹出栈顶的两个数 用运算符对他们进行相应的计算 将结果压入栈中 重复以上操作</li></ul><h2 id="中缀表达式转换成后缀表达式"><a href="#中缀表达式转换成后缀表达式" class="headerlink" title="中缀表达式转换成后缀表达式"></a>中缀表达式转换成后缀表达式</h2><ul><li>初始化两个栈 运算符栈s1和存储中间结果的栈s2</li><li>从左至右扫描中缀表达式</li><li>遇到操作数时 将其压入s2</li><li>遇到运算符时 比较其与s1 栈顶运算符的优先级<ul><li>如果s1为空 或栈顶运算符为左括号 则将其直接压入s1</li><li>否则 若优先级比栈顶运算符的高 也将运算符压入s1</li><li>否则 将s1栈顶的运算符弹出并压入s2中</li></ul></li><li>如果遇到括号<ul><li>如果是左括号 直接压入s1</li><li>如果是右括号 则依次弹出s1栈顶的运算符 并压入s2 直到遇到左括号为止 此时将这一对括号丢弃</li></ul></li><li>重复2~5 直到表达式的最右边</li><li>将s1中剩余的运算符依次弹出并压入s2</li><li>依次弹出s2中的元素并输出 结果的逆序即为中缀表达式对应的后缀表达式</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poland</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 给定中缀表达式 即正常的表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;1+((2+3)*4)-5&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转成后缀表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">subffixExpression</span> <span class="operator">=</span>  convert(expression);</span><br><span class="line"></span><br><span class="line">        System.out.println(subffixExpression);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 中缀表达书转换成后缀表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">convert</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 数字栈 由于全程没有出栈操作 且最后需要反转 可以用List</span></span><br><span class="line">        ArrayList&lt;String&gt; number = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 符号栈</span></span><br><span class="line">        Stack&lt;String&gt; signal = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 用于拼接数字的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">numberStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 用于遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历该中缀表达式</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            numberStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//如果第一个是数字</span></span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//获得该数字的字符串</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; str.length()&amp;&amp;str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    numberStr += str.charAt(i);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将其加入数组</span></span><br><span class="line">                <span class="keyword">if</span> (numberStr != <span class="string">&quot;&quot;</span>)</span><br><span class="line">                    number.add(numberStr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//是符号时 如果符号栈空 或者是左括号时 直接入符号栈</span></span><br><span class="line">                <span class="keyword">if</span>(signal.isEmpty())</span><br><span class="line">                    signal.push(str.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    signal.push(str.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果是右括号时 在遇到左括号之前将符号栈的弹出加入数组</span></span><br><span class="line">                    <span class="keyword">while</span>(!signal.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                        number.add(signal.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将括号去掉</span></span><br><span class="line">                    signal.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//当运算符的优先级更小时将符号栈弹出加入到数组</span></span><br><span class="line">                    <span class="keyword">while</span>(!signal.empty() &amp;&amp; Operation.getValue(signal.peek()) &gt;= Operation.getValue(str.charAt(i)+<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                        number.add(signal.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//再把运算符压入符号栈</span></span><br><span class="line">                    signal.push(str.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; str.length());</span><br><span class="line">        <span class="comment">//遍历完之后如果符号栈还有残留</span></span><br><span class="line">        <span class="comment">//全部弹出加入数组</span></span><br><span class="line">        <span class="keyword">while</span>(!signal.empty())</span><br><span class="line">            number.add(signal.pop());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> number.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 编写一个类 Operation  可以返回一个运算符 对应的优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SUB</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MUL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DIV</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(String operation)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(operation)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LeetCode-相关题目"><a href="#LeetCode-相关题目" class="headerlink" title="LeetCode 相关题目"></a>LeetCode 相关题目</h1><ul><li>Easy<br><a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a><br><br><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列</a><br><br><a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素</a><br><br><a href="https://leetcode.cn/problems/min-stack/">最小栈</a><br></li><li>Medium</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2022/08/03/Queue/"/>
      <url>/2022/08/03/Queue/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>队列(Queue) 是一种采用先进先出(FIFO)策略的抽象数据结构</p><span id="more"></span><ul><li>队列是一个有序列表 可以用数组或是链表来实现</li><li>遵循先入先出的原则 即:先存入队列的数据 要先取出 后存入的要后取出</li><li>通常队列使用链表来进行实现 这样不会有大小的限制</li><li>使用数组实现时可以对下标取余达到对前面出队以后空出的数组空间进行重复利用的效果</li></ul><p><img src="/2022/08/03/Queue/Queue.png" alt="Queue"></p><h1 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a>数组实现队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="comment">//初始化容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="comment">//头指针 用于输出数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">//尾指针 记录末尾数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">//用于实现的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> arr[];</span><br><span class="line">    <span class="comment">//记录存储数据大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> maxSize)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往队列中添加数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">int</span> item)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())</span><br><span class="line">            <span class="comment">//可以抛出异常 直接返回会导致多余的数据忽略</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//添加时的数组下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (++rear) % maxSize;</span><br><span class="line">        arr[index] = item;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队头的数据弹出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        count--; </span><br><span class="line">        <span class="comment">//出队时的数组下标</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (++front) % maxSize;</span><br><span class="line">         <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayQueue</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//将数据加满</span></span><br><span class="line">        arrayQueue.enqueue(<span class="number">1</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">2</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">3</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">4</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//判断isFull函数是否有用</span></span><br><span class="line">        System.out.println(arrayQueue.isFull());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//全部出队 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(arrayQueue.dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断isEmpty函数是否可用</span></span><br><span class="line">        System.out.println(arrayQueue.isEmpty());</span><br><span class="line">        <span class="comment">//再次入队 判断其循环可用性</span></span><br><span class="line">        arrayQueue.enqueue(<span class="number">6</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">7</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue</span>&lt;Item&gt;&#123;</span><br><span class="line">    <span class="comment">//指向最早添加的结点</span></span><br><span class="line">    <span class="keyword">private</span> Node  first;</span><br><span class="line">    <span class="comment">//指向最近添加的结点</span></span><br><span class="line">    <span class="keyword">private</span> Node  last;</span><br><span class="line">    <span class="comment">//队列中的元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="comment">//定义了结点的嵌套类</span></span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">//表尾添加元素</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldlast</span> <span class="operator">=</span> last;</span><br><span class="line">        last = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        last.item = item;</span><br><span class="line">        last.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) first = last;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            oldlast.next = last;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//表头删除元素</span></span><br><span class="line">        <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> first.item;</span><br><span class="line">        first = first.next;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) last = <span class="literal">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组</title>
      <link href="/2022/08/02/spraseArray/"/>
      <url>/2022/08/02/spraseArray/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当一个数组中大部分元素为同一个值时 可以使用稀疏数组来保存该数组</p><span id="more"></span><ul><li>稀疏数组的处理方法<ul><li>记录数组一共有几行几列 有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中 从而缩小程序的规模</li></ul></li></ul><p><img src="/2022/08/02/spraseArray/spraseArray.png" alt="spraseArray"></p><ul><li>第一行 保存整个数组的信息 <ul><li>row 有多少行</li><li>col 有多少列</li><li>val 有多少个有效值</li></ul></li><li>其余行分别存储其他有效数的位置<ul><li>row 所在行</li><li>col 所在列</li><li>val 有效值</li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">spraseArray</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个原始数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ROW</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">COL</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[ROW][COL];</span><br><span class="line">        <span class="comment">//设置有效值</span></span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">        arr[<span class="number">6</span>][<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">6</span>] = <span class="number">5</span>;</span><br><span class="line">        arr[<span class="number">5</span>][<span class="number">2</span>] = <span class="number">9</span>;</span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">7</span>;</span><br><span class="line">        arr[<span class="number">6</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//输出原始的二维数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] row : arr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> item : row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,item);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组 获取数组中的有效值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//有效值个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ROW;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; COL;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建稀疏数组</span></span><br><span class="line">        <span class="type">int</span> spraseArray[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">        spraseArray[<span class="number">0</span>][<span class="number">0</span>] = ROW;</span><br><span class="line">        spraseArray[<span class="number">0</span>][<span class="number">1</span>] = COL;</span><br><span class="line">        spraseArray[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存取有效值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 用于递增存值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ROW;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; COL;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    spraseArray[count][<span class="number">0</span>] = i;</span><br><span class="line">                    spraseArray[count][<span class="number">1</span>] = j;</span><br><span class="line">                    spraseArray[count][<span class="number">2</span>] = arr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印稀疏数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] row : spraseArray)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> item : row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,item);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将稀疏数组恢复成二维数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取行和列</span></span><br><span class="line">        ROW = spraseArray[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        COL = spraseArray[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//new 一个新的数组</span></span><br><span class="line">        <span class="type">int</span> arr2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[ROW][COL];</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; spraseArray.length;i++)&#123;</span><br><span class="line">            arr2[spraseArray[i][<span class="number">0</span>]][spraseArray[i][<span class="number">1</span>]] = spraseArray[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] row : arr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> item : row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,item);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2022/07/27/Spring-1/"/>
      <url>/2022/07/27/Spring-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring使Java编程对每个人来说都更快，更轻松，更安全。Spring对速度，简单性和生产力的关注使其成为全球最受欢迎的Java框架<br><a href="https://spring.io/">官网</a></p><span id="more"></span><h1 id="Spring-Framework-系统架构"><a href="#Spring-Framework-系统架构" class="headerlink" title="Spring Framework 系统架构"></a>Spring Framework 系统架构</h1><blockquote><p>Spring Framework 是Spring生态圈中最基础的项目 是其他项目的根基</p></blockquote><p><img src="/2022/07/27/Spring-1/SpringFramework%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Spring Framework系统架构图"></p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><blockquote><p>Inversion of Control  控制反转</p></blockquote><ul><li><p>使用对象时，由主动new产生对象转换为由外部提供对象，对象的创建控制权由程序转移到外部 这种思想称为控制反转</p></li><li><p>Spring 技术对Ioc思想进行了实现</p><ul><li>Spring提供了一个容器 称为IoC容器 用来充当IoC思想中的外部</li><li>IoC容器负责对象的创建 初始化等一系列工作 被创建或被管理的对象在IoC中统称Bean<!-- IoC是如何返回用户所需要的对象的呢？ --></li></ul></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>导入spring的坐标spring-context </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Spring配置文件 </p><ul><li>在resources下new一个applicationContext.xml文件</li></ul></li><li><p>配置bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    告诉spring创建对象</span></span><br><span class="line"><span class="comment">    声明bean</span></span><br><span class="line"><span class="comment">    id  对象的自定义名称 唯一值  spring通过这个名称找到对象</span></span><br><span class="line"><span class="comment">    class 类的全限定名称 不能是接口 因为要通过反射机制创建对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    spring 把创建好的对象放入map中 spring框架中有一个map存放对象</span></span><br><span class="line"><span class="comment">    key值是id</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    一个bean标签声明一个对象 </span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    对于非自定义的类 spring也能创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置service与 dao的关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">    name属性表示配置哪一个具体的属性</span></span><br><span class="line"><span class="comment">    ref属性表示参照哪一个bean--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>获取IoC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>获取bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Obejct</span> <span class="variable">o</span> <span class="operator">=</span> (Object)ctx.getBean(id)</span><br></pre></td></tr></table></figure></li></ul><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><blockquote><p>Dependency Injection  依赖注入</p></blockquote><ul><li>在容器中建立bean与bean之间的依赖关系的整个过程 称为依赖注入</li></ul><h3 id="set注入"><a href="#set注入" class="headerlink" title="set注入"></a>set注入</h3><h4 id="简单类型的set注入"><a href="#简单类型的set注入" class="headerlink" title="简单类型的set注入"></a>简单类型的set注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;xx&quot;</span> <span class="attr">class</span> = <span class="string">&quot;yy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;属性名字&quot;</span>  <span class="attr">value</span> = <span class="string">&quot;此属性的值&quot;</span>/&gt;</span></span><br><span class="line">        一个property只能给一个属性赋值</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义类型的set注入"><a href="#自定义类型的set注入" class="headerlink" title="自定义类型的set注入"></a>自定义类型的set注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">class</span>=<span class="string">&quot;yyy&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;属性名称&quot;</span> <span class="attr">ref</span> = <span class="string">“bean的id”/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><ul><li><p>构造注入 spring调用有参数构造方法  在创建对象的同时  在构造方法中给属性赋值</p></li><li><p>构造注入使用  <constructor-arg> 标签</constructor-arg></p></li><li><p>标签属性</p><ul><li>name 表示构造方法的形参名</li><li>index 表示构造方法的参数的位置 参数从左往右位置是0.1.2的顺序</li><li>value 构造方法的形参类型是简单类型 使用value</li><li>ref  构造方法的形参类型是引用类型 使用ref<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.pa_03.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;myName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;myAge&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;mySchool&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--   使用index标志--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.pa_03.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    声明school对象--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mySchool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.pa_03.School&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;beijingdaxue&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h3></li></ul></li><li><p>引用类型的自动注入  spring框架根据某些规则可以给引用类型给引用类型赋值</p></li><li><p>使用的规则常用是 byName  byType</p></li><li><p>byName  </p><ul><li>java类中引用类型的属性名和spring容器中<bean> 的id名称一样<br>且数据类型是一致的 这样的容器中的bean spring能够赋值给引用类型</bean></li></ul></li><li><p>语法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span> id = &quot;xx&quot; class = &quot;yyy&quot; autowire = &quot;byName&quot;&gt;</span><br><span class="line">  简单类型属性赋值</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>byType  </p><ul><li>java类中引用类型的数据类型和spring容器中 <bean>的class属性<br>是同源关系的 这样的bean能够赋值给引用类型<br>在byType中 声明bean只能右一个符合条件的</bean></li></ul></li><li><p>同源就是一类的意思</p><ul><li>java中引用类型的数据类型和bean的class的值是一样的</li><li>java类中引用类型的数据类型和bean的class的值是父子类型的</li><li>java类中引用类型的数据类型和bean的class的值是接口和实现类的关系的</li></ul></li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><blockquote><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方<br>式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个<br>热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑<br>的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高<br>了开发的效率。</p></blockquote><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</li><li>Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</li><li>Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</li><li>Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</li><li>Target（目标对象）：织入 Advice 的目标对象.。</li><li>Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</li></ul><h3 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/<span class="strong">**</span></span><br><span class="line"><span class="strong">  <span class="emphasis">* 定义方法  方法是实现切面功能的</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">  *</span> 方法的定义要求</span></span><br><span class="line"><span class="strong">  <span class="emphasis">*      公共方法  public</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">  *</span>      方法没有返回值</span></span><br><span class="line"><span class="strong">  <span class="emphasis">*      方法名称自定义</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">  *</span>      方法可以有参数 也可以没有</span></span><br><span class="line"><span class="strong">  <span class="emphasis">*          如果有 参数不是自定义的  有几个参数可以使用</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">  *</span>/</span></span><br><span class="line"><span class="strong">/**</span></span><br><span class="line"><span class="bullet">  *</span> execution(&lt;修饰符模式&gt;?&lt;返回类型模式&gt;&lt;方法名模式&gt;(&lt;参数模式&gt;)&lt;异常模式&gt;?)</span><br><span class="line"><span class="bullet">  *</span> https://blog.csdn.net/zhuanglicheng/article/details/109110176</span><br><span class="line">  <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis">/<span class="strong">**</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">  <span class="emphasis">* 指定通知方法中的参数 JoinPoint</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  *</span> JoinPoint  业务方法 要加入切面功能的业务方法</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">  <span class="emphasis">*      作用   可以在通知方法中获取方法执行时的信息  例如方法名称  方法的实参</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  *</span>      如果你的切面功能中需要用到方法的信息 就加入JointPoint</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">  <span class="emphasis">*      这个JoinPoint参数的值是由框架赋予  必须是第一个位置的参数</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  *</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis">  <span class="emphasis">*/</span></span></span></span><br></pre></td></tr></table></figure><ul><li><p>@Aspect  是aspectj框架中的注解</p><ul><li>作用  表示当前类是切面类</li><li>切面类  是用来给业务方法增加功能的类  在这个类中有切面的功能代码</li><li>位置  在类定义的上面</li></ul></li><li><p>@Before 前置通知注解</p><ul><li>属性 value 是切入点表达式 表示切面的功能执行的位置</li><li>位置 在方法上面</li><li>特点<ul><li>在目标方法之前先执行的</li><li>不会改变目标方法的执行结果</li><li>不会影响目标方法的执行</li></ul></li></ul></li><li><p>@AfterReturning 后置通知 方法有参数  推荐Object  参数名自定义</p><ul><li>属性 <ul><li>value 切入点表达式</li><li>returning 自定义的变量  表示目标方法的返回值的 自定义变量名必须和通知方法的形参名一样</li></ul></li><li>位置   方法的上面</li><li>特点<ul><li>在目标方法之后执行的</li><li>能够获取到目标方法的返回值 可以根据这个返回值做不同的处理功能</li><li>可以修改这个返回值  只有当传递的是引用的参数是才会改变  值传递不会改变原有的参数</li></ul></li></ul></li><li><p>@Around 环绕通知 方法必须有一个返回值  推荐使用Object 方法有参数  固定的参数 ProceedingJoinPoint</p><ul><li>属性 value  切入点表达式</li><li>位置 在方法的定义上面</li><li>特点<ul><li>是功能最强的通知</li><li>在目标方法的前和后都能增强功能</li><li>控制目标方法是否被调用执行</li><li>修改原来的目标方法的执行结果 影响最后的调用结果</li></ul></li><li>参数<ul><li>ProceedingJoinPoint  等同于jdk动态代理参数中的Method</li><li>作用  执行目标方法的</li></ul></li><li>返回值  就是目标方法的执行结果 可以被修改<br>环绕通知经常做事务  在目标方法之前开启事务  执行目标方法后提交事务</li></ul></li></ul><h1 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h1><h2 id="bean-配置"><a href="#bean-配置" class="headerlink" title="bean 配置"></a>bean 配置</h2><h3 id="bean-基础配置"><a href="#bean-基础配置" class="headerlink" title="bean 基础配置"></a>bean 基础配置</h3><p><img src="/2022/07/27/Spring-1/bean%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.png" alt="bean基础配置"></p><h3 id="bean-别名配置"><a href="#bean-别名配置" class="headerlink" title="bean 别名配置"></a>bean 别名配置</h3><p><img src="/2022/07/27/Spring-1/bean%E7%9A%84%E5%88%AB%E5%90%8D%E9%85%8D%E7%BD%AE.png" alt="bean的别名配置"></p><h3 id="bean-作用范围配置"><a href="#bean-作用范围配置" class="headerlink" title="bean 作用范围配置"></a>bean 作用范围配置</h3><p><img src="/2022/07/27/Spring-1/bean%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.png" alt="bean基础配置"></p><ul><li>适合交给容器进行管理的bean<ul><li>表现层对象</li><li>业务层对象</li><li>数据层对象</li><li>工具对象</li></ul></li><li>不适合交给容器进行管理的bean<ul><li>封装实体的域对象</li></ul></li></ul><h2 id="bean-实例化"><a href="#bean-实例化" class="headerlink" title="bean 实例化"></a>bean 实例化</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>提供可访问的构造方法</li><li>spring通过反射获得该方法的无参构造方法用以创建对象</li><li>如果无无参构造方法将会报错</li></ul><h3 id="使用静态工厂"><a href="#使用静态工厂" class="headerlink" title="使用静态工厂"></a>使用静态工厂</h3><ul><li>静态工厂  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态工厂创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">id</span> = <span class="string">&quot;orderDao&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.kris.factory.OrderDaoFactory&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-method</span>=<span class="string">&quot;getOrderDao&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用实例化工厂"><a href="#使用实例化工厂" class="headerlink" title="使用实例化工厂"></a>使用实例化工厂</h3><ul><li><p>实例工厂</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.factory.UserDaoFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实例化工厂运行的顺序是:</p><ul><li><p>创建实例化工厂对象,对应的是第一行配置</p></li><li><p>调用对象中的方法来创建bean，对应的是第二行配置</p><ul><li><p>factory-bean:工厂的实例对象</p></li><li><p>factory-method:工厂对象中的具体创建对象的方法名</p></li></ul></li></ul></li></ul><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><ul><li>FactoryBean  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回所创建类的Class对象</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>配置  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.factory.UserDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="bean-生命周期"><a href="#bean-生命周期" class="headerlink" title="bean 生命周期"></a>bean 生命周期</h2><ul><li><p>提供生命周期控制方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean初始化对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean销毁前对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置生命周期控制方法</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实现 InitializingBean DisposableBean 接口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bean-的执行流程"><a href="#bean-的执行流程" class="headerlink" title="bean 的执行流程"></a>bean 的执行流程</h3></li><li><p>初始化容器</p><ul><li>创建对象</li><li>执行构造方法</li><li>执行属性注入(set操作)</li><li>执行bean初始化方法</li></ul></li><li><p>使用bean</p><ul><li>执行业务操作</li></ul></li><li><p>关闭&#x2F;销毁容器</p><ul><li>执行bean销毁方法</li></ul></li></ul><h3 id="bean-销毁时机"><a href="#bean-销毁时机" class="headerlink" title="bean 销毁时机"></a>bean 销毁时机</h3><ul><li>容器关闭前触发bean的小销毁</li><li>关闭容器方式<ul><li>手工关闭容器<br>ConfigurableApplicationContext接口close()操作</li><li>注册关闭钩子 在虚拟机退出前先关闭容器再退出虚拟机<br>ConfigurableApplicationContext接口registerShutdownHook()操作</li></ul></li></ul><h2 id="使用注解创建bean"><a href="#使用注解创建bean" class="headerlink" title="使用注解创建bean"></a>使用注解创建bean</h2><ul><li><p>@Component  创建对象的  等同于<bean> 标签的功能</bean></p><ul><li>属性 value 就是对象的名称   也就是bean的id值</li><li>value的值是唯一的 创建的对象在整个spring容器中就一个</li></ul></li><li><p>@Respository  放在dao的实现类上面表示创建dao对象  dao对象是能访问数据库的</p></li><li><p>@Service       放在service的实现类上 创建service对象  </p><ul><li>service对象是做业务处理的 可以有事务等功能的</li></ul></li><li><p>@Controller     放在控制器类上面  创建控制器对象</p><ul><li>控制器对象  能够接受用户参数 显示请求的处理结果</li></ul></li><li><p>@Value  简单类型的属性赋值</p><ul><li>属性  <ul><li>value 是String类型的  表示简单类型的属性值</li></ul></li><li>位置  <ul><li>在属性定义的上面  无需set方法  推荐使用</li><li>在set方法上面</li></ul></li></ul></li><li><p>@AutoWire  spring框架提供的注解  实现引用类型的赋值</p><ul><li>spring 通过注解给引用类型赋值  使用的是自动注入原理  支持byName  </li><li>byType<ul><li>属性requird bool 默认为  true</li><li>requird &#x3D; true 表示引用类型赋值失败 程序报错 并终止执行</li><li>requird &#x3D; false  引用类型如果赋值失败 程序正常执行 引用类型null </li><li>默认为byType自动注入</li><li>使用byName  需要在属性上面加入@Qualifier(value &#x3D; “bean的id”) 表示使用指定名称的bean完成精准赋值</li></ul></li></ul></li><li><p>@Resource  来自jdk中的注解 spring框架提供了对这个注解的功能支持 可以使用它给引用类型赋值</p><ul><li>使用的也是自动注入原理  支持byName  byType  默认是byName</li><li>位置  <ul><li>在属性定义上面  无需set方法  推荐使用</li><li>在set方法上面</li></ul></li></ul></li></ul><h1 id="关于配置文件"><a href="#关于配置文件" class="headerlink" title="关于配置文件"></a>关于配置文件</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    当项目中有许多类时  可以将配置文件按模块进行分类</span></span><br><span class="line"><span class="comment">    创建一个主配置文件  包含其他的配置文件 主配置文件一般不定义对象</span></span><br><span class="line"><span class="comment">    语法</span></span><br><span class="line"><span class="comment">        &lt;import resource = &quot;其他配置文件的路径&quot;/&gt;</span></span><br><span class="line"><span class="comment">        关键字 classpath  表示类路径（class文件所在的目录）</span></span><br><span class="line"><span class="comment">        在配置文件中要指定其他文件的位置 需要使用classpath 告诉spring到哪去加载读取配置文件</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    在包含关系的配置文件中 可以通配符(* ；表示任意字符)</span></span><br><span class="line"><span class="comment">    注意  主的配置文件名称不能包含在通配符的范围内 不然会造成死循环</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:pa_04/applicationContext.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    声明组件扫描器</span></span><br><span class="line"><span class="comment">    base-package 指定注解在你的项目中的包名</span></span><br><span class="line"><span class="comment">    component-scan工作方式  spring 会扫描遍历base-package指定的包</span></span><br><span class="line"><span class="comment">        把包中和子包中的所有类 找到类中的注解 按照注解的功能创建对象  或给属性赋值</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    指定多个包</span></span><br><span class="line"><span class="comment">        - 使用多次组件扫描器</span></span><br><span class="line"><span class="comment">        - 使用分割符(;或,) 分割多个包名</span></span><br><span class="line"><span class="comment">            base-package = &quot;com.kris.pa_01; com.kris.pa_02&quot;</span></span><br><span class="line"><span class="comment">        - 指定父包</span></span><br><span class="line"><span class="comment">            base-package = &quot;com.kris&quot;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">&quot;com.kris.pa_04&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用配置文件 在注解的value中即可使用  &#123;键名&#125;  来表示对应的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:test.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        声明自动代理生成器 使用aspectj框架内部的功能 创建目标的代理对象</span></span><br><span class="line"><span class="comment">        创建代理对象是在内存中实现的  修改目标对象的内存中的结构 创建为代理对象</span></span><br><span class="line"><span class="comment">        所以目标对象就是被修改后的代理对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        aspectj-autoproxy  会把spring容器中的所有目标对象一次性都生成代理对象</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       把数据库的配置信息，写在一个独立的文件，编译修改数据库的配置内容</span></span><br><span class="line"><span class="comment">       spring知道jdbc.properties文件的位置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明数据源DataSource, 作用是连接数据库的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入给DruidDataSource提供连接数据库信息 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    使用属性配置文件中的数据，语法 $&#123;key&#125; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/kris?serverTimezone=UTC<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="symbol">&amp;amp;</span>useSSL=false&quot;</span> /&gt;</span><span class="comment">&lt;!--setUrl()--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a14796542031&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明的是mybatis中提供的SqlSessionFactoryBean类，这个类内部创建SqlSessionFactory的</span></span><br><span class="line"><span class="comment">        SqlSessionFactory  sqlSessionFactory = new ..</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入，把数据库连接池付给了dataSource属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis主配置文件的位置</span></span><br><span class="line"><span class="comment">           configLocation属性是Resource类型，读取配置文件</span></span><br><span class="line"><span class="comment">           它的赋值，使用value，指定文件的路径，使用classpath:表示文件的位置</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatisConfig.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建dao对象，使用SqlSession的getMapper（StudentDao.class）</span></span><br><span class="line"><span class="comment">        MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定SqlSessionFactory对象的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定包名， 包名是dao接口所在的包名。</span></span><br><span class="line"><span class="comment">            MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行</span></span><br><span class="line"><span class="comment">            一次getMapper()方法，得到每个接口的dao对象。</span></span><br><span class="line"><span class="comment">            创建好的dao对象放入到spring的容器中的。 dao对象的默认名称是 接口名首字母小写</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.kris.dao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.service.Impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/07/26/Git-1/"/>
      <url>/2022/07/26/Git-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到非常大的项目的所有内容。</p><span id="more"></span><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li><p>实现跨区域多人协同开发</p></li><li><p>追踪和记载一个或者多个文件的历史记录</p></li><li><p>组织和保护你的源代码和文档</p></li><li><p>统计工作量</p></li><li><p>并行开发、提高开发效率</p></li><li><p>跟踪记录整个软件的开发过程</p></li><li><p>减轻开发人员的负担，节省时间，同时降低人为错误</p></li></ul><h2 id="常见版本控制"><a href="#常见版本控制" class="headerlink" title="常见版本控制"></a>常见版本控制</h2><ul><li><p>Git</p></li><li><p>SVN（Subversion）</p></li><li><p>CVS（Concurrent Versions System）</p></li><li><p>VSS（Micorosoft Visual SourceSafe）</p></li><li><p>TFS（Team Foundation Server）</p></li><li><p>Visual Studio Online</p></li></ul><p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p><h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><h3 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><h3 id="集中版本控制"><a href="#集中版本控制" class="headerlink" title="集中版本控制"></a>集中版本控制</h3><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改<br>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p>每个人都拥有全部的代码！安全隐患！</p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><h3 id="Git-和-SVN的主要区别"><a href="#Git-和-SVN的主要区别" class="headerlink" title="Git 和 SVN的主要区别"></a>Git 和 SVN的主要区别</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><h1 id="Git-环境配置"><a href="#Git-环境配置" class="headerlink" title="Git 环境配置"></a>Git 环境配置</h1><h2 id="常用Linux命令"><a href="#常用Linux命令" class="headerlink" title="常用Linux命令"></a>常用Linux命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>cd</td><td>改变目录</td></tr><tr><td>cd..</td><td>回退到上个目录，直接cd进入默认目录</td></tr><tr><td>pwd</td><td>显示当前所在的目录路径</td></tr><tr><td>ls(ll)</td><td>都是列出当前目录中的所有文件 只不过ll列出的内容更为详细</td></tr><tr><td>touch</td><td>新建一个文件</td></tr><tr><td>rm</td><td>删除一个文件</td></tr><tr><td>mkdir</td><td>新建一个文件夹</td></tr><tr><td>rm-r</td><td>删除一个文件夹</td></tr><tr><td>rm-rf</td><td>强制删除</td></tr><tr><td>mv</td><td>移动文件  mv 移动文件 目标文件夹</td></tr><tr><td>reset</td><td>重新初始化终端</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>history</td><td>查看命令历史</td></tr><tr><td>help</td><td>帮助</td></tr><tr><td>exit</td><td>退出</td></tr><tr><td>#</td><td>注释</td></tr></tbody></table><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看配置</span></span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统config</span></span><br><span class="line">git config <span class="params">--system</span> <span class="params">--list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前用户(global)配置</span></span><br><span class="line">git config <span class="params">--global</span> <span class="params">--list</span></span><br></pre></td></tr></table></figure><h2 id="Git配置相关文件"><a href="#Git配置相关文件" class="headerlink" title="Git配置相关文件"></a>Git配置相关文件</h2><ul><li><p>Git\etc\gitconfig  ：Git 安装目录下的 gitconfig     –system 系统级</p></li><li><p>C:\Users\Administrator\ .gitconfig    只适用于当前登录用户的配置  –global 全局</p></li></ul><h2 id="设置用户名和邮箱"><a href="#设置用户名和邮箱" class="headerlink" title="设置用户名和邮箱"></a>设置用户名和邮箱</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git config --global <span class="literal">user</span>.<span class="keyword">name</span> <span class="string">&quot;username&quot;</span>  <span class="comment">#名称</span></span><br><span class="line">git config --global <span class="literal">user</span>.email email   <span class="comment">#邮箱</span></span><br></pre></td></tr></table></figure><p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p><h1 id="Git-基本理论"><a href="#Git-基本理论" class="headerlink" title="Git 基本理论"></a>Git 基本理论</h1><h2 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage&#x2F;Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。</p><ul><li><p>Workspace：工作区，就是你平时存放项目代码的地方</p></li><li><p>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</p></li><li><p>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</p></li><li><p>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p></li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul><li><p>在工作目录中添加、修改文件；</p></li><li><p>将需要进行版本管理的文件放入暂存区域；</p></li><li><p>将暂存区域的文件提交到git仓库。</p></li></ul><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="/2022/07/26/Git-1/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Git工作流程"></p><h1 id="Git-项目搭建"><a href="#Git-项目搭建" class="headerlink" title="Git 项目搭建"></a>Git 项目搭建</h1><h2 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h2><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><ul><li><p>创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="variable">$ </span>git init</span><br></pre></td></tr></table></figure></li><li><p>执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p></li></ul><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><ul><li>另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line">$ git <span class="keyword">clone</span> <span class="title">[url</span>]  <span class="comment"># https://gitee.com/kuangstudy/openclass.git</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Git-文件操作"><a href="#Git-文件操作" class="headerlink" title="Git 文件操作"></a>Git 文件操作</h1><h2 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h2><blockquote><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p></blockquote><ul><li><p>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p></li><li><p>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</p></li><li><p>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</p></li><li><p>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</p></li></ul><h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看指定文件状态</span></span><br><span class="line"><span class="attribute">git</span> status<span class="meta"> [filename]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看所有文件状态</span></span><br><span class="line"><span class="attribute">git</span> status</span><br><span class="line"></span><br><span class="line"><span class="comment"># git add .                  添加所有文件到暂存区</span></span><br><span class="line"><span class="comment"># git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span></span><br></pre></td></tr></table></figure><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><blockquote><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等<br>在主目录下建立”.gitignore”文件，此文件有如下规则：</p></blockquote><ul><li><p>忽略文件中的空行或以井号（#）开始的行将会被忽略。</p></li><li><p>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</p></li><li><p>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</p></li><li><p>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</p></li><li><p>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为注释</span></span><br><span class="line">*.txt        <span class="comment">#忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span></span><br><span class="line">!lib.txt     <span class="comment">#但lib.txt除外</span></span><br><span class="line">/temp        <span class="comment">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span></span><br><span class="line">build<span class="regexp">/       #忽略build/</span>目录下的所有文件</span><br><span class="line">doc<span class="regexp">/*.txt    #会忽略 doc/</span>notes.txt 但不包括 doc<span class="regexp">/server/</span>arch.txt</span><br></pre></td></tr></table></figure><h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><p>git分支常用指令</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-<span class="keyword">name</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-<span class="keyword">name</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git <span class="keyword">push</span> origin --<span class="keyword">delete</span> [branch-<span class="keyword">name</span>]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p><p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Element</title>
      <link href="/2022/07/19/Element/"/>
      <url>/2022/07/19/Element/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一套基于Vue 的网站组件库 用于快速构建网页</p><p><a href="https://element.eleme.cn/#/zh-CNListener">官网</a></p><span id="more"></span><h1 id="Element-快速入门"><a href="#Element-快速入门" class="headerlink" title="Element 快速入门"></a>Element 快速入门</h1><ul><li>引入Element的css js 文件 和Vue.js<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;element-ui/lib/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>创建Vue核心对象<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>官网复制Element组件代码<h1 id="Element-布局"><a href="#Element-布局" class="headerlink" title="Element 布局"></a>Element 布局</h1></li><li>Element 中有两种布局方式<ul><li><p>Layout布局 通过基础的24分栏 迅速简便的创建布局<br><img src="/2022/07/19/Element/Layout%E5%B8%83%E5%B1%80.png" alt="Layout布局"></p></li><li><p>Container 布局容器 用于布局的容器组件 方便快速的搭建页面的基本结构</p><p><img src="/2022/07/19/Element/Container%E5%B8%83%E5%B1%80.png" alt="Container布局"></p></li></ul></li></ul><h1 id="Element-组件"><a href="#Element-组件" class="headerlink" title="Element 组件"></a>Element 组件</h1>]]></content>
      
      
      <categories>
          
          <category> Element </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2022/07/18/Vue/"/>
      <url>/2022/07/18/Vue/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Vue 是一套前端框架 免除原生JS中的DOM操作 简化书写<br>基于MVVM(Model-View-ViewModel) 思想 实现数据的双向绑定 将编程的关注点放在数据上<br><a href="https://cn.vuejs.org/">官网</a></p></blockquote><span id="more"></span><h1 id="Vue-快速入门"><a href="#Vue-快速入门" class="headerlink" title="Vue 快速入门"></a>Vue 快速入门</h1><ul><li><p>新建HTML页面 引入Vue.js文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在JS代码区域 创建Vue核心对象 进行数据绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>&#123;</span><br><span class="line">          <span class="attr">username</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>编写视图</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span> = <span class="string">&quot;username&quot;</span> <span class="attr">v-model</span> = <span class="string">&quot;username&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123;<span class="name">username</span>&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="Vue-常用指令"><a href="#Vue-常用指令" class="headerlink" title="Vue 常用指令"></a>Vue 常用指令</h1></li><li><p>指令 HTML标签上带有v-前缀的特殊属性 不同指令具有不同含义</p></li><li><p>常用指令</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>v-bind</td><td>为HTML标签绑定属性值 如设置href css样式等</td></tr><tr><td>v-model</td><td>在表单元素上创建双向数据绑定</td></tr><tr><td>v-on</td><td>为HTML标签绑定事件</td></tr><tr><td>v-show</td><td>根据条件展示某元素 区别在于切换的是display属性的值</td></tr><tr><td>v-for</td><td>列表渲染 遍历容器的元素或者对象的属性</td></tr><tr><td>v-if v-else v-else-if</td><td>条件性的渲染某元素，判定为true时渲染 否则不渲染</td></tr></tbody></table><h1 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h1></li><li><p>生命周期有八个阶段 每触发一个生命周期事件 会自动执行一个生命周期方法</p><table><thead><tr><th>状态</th><th>阶段周期</th></tr></thead><tbody><tr><td>beforeCreate</td><td>创建前</td></tr><tr><td>created</td><td>创建后</td></tr><tr><td>beforeMount</td><td>载入前</td></tr><tr><td>mounted</td><td>挂载完成</td></tr><tr><td>beforeUpdate</td><td>更新前</td></tr><tr><td>updated</td><td>更新后</td></tr><tr><td>beforeDestroy</td><td>销毁前</td></tr><tr><td>destroyed</td><td>销毁后</td></tr></tbody></table></li><li><p>mounted 挂载完成 Vue初始化成功 HTML页面渲染成功</p><ul><li>发送异步请求 加载数据<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;vue 挂载完毕 发送异步请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="/2022/07/18/Vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Vue生命周期"></p><p><a href="https://www.bilibili.com/video/BV1Qf4y1T7Hx?p=147&vd_source=12da55ab9dd7741612032a6f327c8c9d">图片来源</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AJAX</title>
      <link href="/2022/07/17/AJAX/"/>
      <url>/2022/07/17/AJAX/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AJAX(Asynchronous JavaScript And XML) : 异步的JavaScript和XML</p><span id="more"></span><ul><li>AJAX 作用<ul><li>与服务器进行数据交换 通过AJAX 可以给服务器发送请求 并获取服务器响应的数据 </li><li>异步交互 可以在不重新加载整个页面的情况下 与服务器交换数据并更新部分网页的技术</li></ul></li></ul><h1 id="AJAX-快速入门"><a href="#AJAX-快速入门" class="headerlink" title="AJAX 快速入门"></a>AJAX 快速入门</h1><ul><li>编写AjaxServlet 并使用response输出字符串</li><li>创建XMLHttpRequest 对象 用于和服务器交换数据<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span>(window.XMLHttpRequest)&#123;</span><br><span class="line">  xmlhttp = <span class="keyword">new</span> <span class="type">XMLHttpRequest</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  xml = <span class="keyword">new</span> <span class="type">ActiveObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>向服务器发送请求<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;<span class="keyword">GET</span>&quot;</span>,<span class="string">&quot;url&quot;</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure></li><li>获取服务器响应数据<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xmlhttp.readyState == <span class="number">4</span> &amp;&amp; xmlhttp.<span class="keyword">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">      elert(xmlhttp.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Axios-异步框架"><a href="#Axios-异步框架" class="headerlink" title="Axios 异步框架"></a>Axios 异步框架</h1><blockquote><p>Axios 对原生的AJAX进行封装 简化书写</p></blockquote></li><li><a href="https://www.axios-http.cn/">官网</a></li></ul><h2 id="Axios-快速入门"><a href="#Axios-快速入门" class="headerlink" title="Axios 快速入门"></a>Axios 快速入门</h2><ul><li>引入 axios 的  js文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用axios发送请求 并获取响应结果<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">axios</span>(&#123;</span><br><span class="line">  method:&quot;get&quot;,</span><br><span class="line">  url:&quot;...&quot;</span><br><span class="line">&#125;)<span class="selector-class">.then</span>(function(resp)&#123;</span><br><span class="line">  <span class="built_in">alert</span>(resp.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> axios(<span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">  method:</span><span class="string">&quot;post&quot;</span>,</span><br><span class="line"><span class="symbol">  url:</span><span class="string">&quot;...&quot;</span>,</span><br><span class="line"><span class="symbol">  data:</span><span class="string">&quot;username = zhangsan&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span>).then(function(resp)<span class="punctuation">&#123;</span></span><br><span class="line">  alert(resp.data)<span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;</span>)<span class="punctuation">;</span></span><br></pre></td></tr></table></figure><h2 id="Axios-请求方式别名"><a href="#Axios-请求方式别名" class="headerlink" title="Axios 请求方式别名"></a>Axios 请求方式别名</h2><img src="/2022/07/17/AJAX/Axios%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%88%AB%E5%90%8D.png" alt="Axios请求方式别名"></li><li>发送get请求<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">axios.get</span>(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">  .then(<span class="function"><span class="title">function</span>(<span class="variable">resp</span>)&#123;</span></span><br><span class="line"><span class="function">      <span class="title">alert</span>(<span class="variable">resp.data</span>);</span></span><br><span class="line"><span class="function">  &#125;)</span></span><br></pre></td></tr></table></figure></li><li>发送post请求<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">axios</span>.<span class="property">post</span>(<span class="string">&quot;url&quot;</span>,<span class="string">&quot;参数&quot;</span>)</span><br><span class="line">  .<span class="property">then</span>(<span class="title function_">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="variable">resp</span>.<span class="property">data</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><blockquote><p>JavaScript Object Notation JavaScript 对象表示法 其语法简单 层次鲜明 多用于作为数据载体 在网络中进行数据传输</p></blockquote></li></ul><h2 id="JSON-基础语法"><a href="#JSON-基础语法" class="headerlink" title="JSON 基础语法"></a>JSON 基础语法</h2><ul><li><p>定义</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 = &#123;</span><br><span class="line">  <span class="string">&quot;key1&quot;</span> : <span class="type">value1</span>,</span><br><span class="line">  <span class="string">&quot;key2&quot;</span> : <span class="type">value2</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>value的数据类型<ul><li>数字(整数或者浮点数)</li><li>字符串(在双引号中)</li><li>逻辑值(true or false)</li><li>数组(在方括号中)</li><li>对象(在花括号中) </li><li>null</li></ul></li><li>实例  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> json = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">23</span>,</span><br><span class="line">    <span class="string">&quot;addr&quot;</span>:<span class="selector-attr">[<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;上海&quot;</span>]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取数据</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名.<span class="built_in">key</span></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">json.<span class="built_in">key</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="JSON-数据和Java对象转换"><a href="#JSON-数据和Java对象转换" class="headerlink" title="JSON 数据和Java对象转换"></a>JSON 数据和Java对象转换</h2><ul><li>Fastjson是阿里巴巴提供的一个Java语言编写的高性能功能完善的JSON库 是目前Java 语言中最快的JSON库 可以实现Java对象和JSON字符串的相互转换</li><li>使用<ul><li>导入坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependency&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Java对象转JSON<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String jsonStr = <span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span><span class="keyword">to</span><span class="constructor">JSONString(<span class="params">obj</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>JSON 字符串转Java对象<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">User</span> <span class="keyword">user</span> = <span class="type">JSON</span>.parseObject(jsonStr,<span class="keyword">User</span>,<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> AJAX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter&amp;Listener</title>
      <link href="/2022/07/16/Filter/"/>
      <url>/2022/07/16/Filter/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Filter表示过滤器 可以把对资源的请求拦截下来 实现一些特殊的功能 如 权限控制 统一编码处理 敏感字符处理等<br>Listener 表示监听器可以监听就是在appliction session request 三个对象创建 销毁 或往其中添加修改删除属性时自动执行代码的功能组件</p><span id="more"></span><h1 id="Filter-快速入门"><a href="#Filter-快速入门" class="headerlink" title="Filter 快速入门"></a>Filter 快速入门</h1><ul><li>定义类 实现Filter 接口 并重写其所有方法<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">FileterDemo</span> <span class="selector-tag">implements</span> <span class="selector-tag">Filter</span> &#123;</span><br><span class="line">  <span class="variable">@Override</span></span><br><span class="line">  public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">@Override</span></span><br><span class="line">  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">@Override</span></span><br><span class="line">  public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>配置Filter拦截资源路径 在类上定义@WebFilter 注解<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(<span class="string">&quot;/*&quot;</span>)</span></span><br></pre></td></tr></table></figure></li><li>在doFilter方法中编写代码 并放行<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">public void <span class="keyword">do</span><span class="constructor">Filter(ServletRequest <span class="params">servletRequest</span>, ServletResponse <span class="params">servletResponse</span>, FilterChain <span class="params">filterChain</span>)</span> throws IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">// 放行</span></span><br><span class="line">    filterChain.<span class="keyword">do</span><span class="constructor">Filter(<span class="params">servletRequest</span>,<span class="params">servletResponse</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Filter-执行流程"><a href="#Filter-执行流程" class="headerlink" title="Filter 执行流程"></a>Filter 执行流程</h1></li><li>执行放行前逻辑</li><li>放行</li><li>访问资源</li><li>执行放行后逻辑<h1 id="Filter-使用细节"><a href="#Filter-使用细节" class="headerlink" title="Filter 使用细节"></a>Filter 使用细节</h1><h2 id="Filter-拦截路径配置"><a href="#Filter-拦截路径配置" class="headerlink" title="Filter 拦截路径配置"></a>Filter 拦截路径配置</h2></li><li>Filter 可以根据需求 配置不同的拦截资源路径<ul><li>拦截具体的资源 &#x2F;index.jsp 只有访问index.jsp时才会被拦截</li><li>目录拦截 &#x2F;user&#x2F;* 访问&#x2F;user 下的所有资源都会被拦截</li><li>后缀名拦截 *.jsp 访问后缀名为jsp的资源 都会被拦截</li><li>拦截所有 &#x2F;* 访问所有资源 都会被拦截</li></ul></li></ul><h2 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h2><blockquote><p>一个Web应用 可以配置多个过滤器 这多个过滤器称为过滤器链</p></blockquote><ul><li>过滤器的执行顺序由字符串的排序决定</li></ul><h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><ul><li><p>Listener分类<br> <img src="/2022/07/16/Filter/Listener%E5%88%86%E7%B1%BB.png" alt="Listener分类"></p></li><li><p>使用</p><ul><li>定义类 实现对应的接口</li><li>在类上添加@WebListener是注解</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookies&amp;Session</title>
      <link href="/2022/07/15/Cookies-Session/"/>
      <url>/2022/07/15/Cookies-Session/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>会话跟踪是一种维护浏览器状态的方法 服务器需要识别多次请求是否来自于同一浏览器 以便在同一次会话的多次请求间共享数据</p></blockquote><span id="more"></span><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><blockquote><p>客户端会话跟踪技术</p></blockquote><h2 id="Cookie-基本使用"><a href="#Cookie-基本使用" class="headerlink" title="Cookie 基本使用"></a>Cookie 基本使用</h2><ul><li>Cookie：客户端会话技术 将数据保存到客户端 以后每次请求都携带Cookie数据进行访问</li><li>Cookie基本使用<ul><li>创建Cookie对象 设置数据<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cookie cookie</span> = new Cookie(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>发送Cookie到客户端 使用response对象<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.add<span class="constructor">Cookie(<span class="params">cookie</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获取客户端携带的所有Cookie 使用request对象<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies <span class="operator">=</span> request.getCookies()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>遍历数组 获取每一个Cookie对象</li><li>使用Cookie对象方法获取数据<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie.getName()<span class="comment">;</span></span><br><span class="line">cookie.getValue()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="Cookie-原理"><a href="#Cookie-原理" class="headerlink" title="Cookie 原理"></a>Cookie 原理</h2></li></ul></li><li>Cookie 的实现是基于HTTP协议的<ul><li>响应头 set-cookie</li><li>请求头 cookie<h2 id="Cookie-使用细节"><a href="#Cookie-使用细节" class="headerlink" title="Cookie 使用细节"></a>Cookie 使用细节</h2></li></ul></li><li>Cookie 存活时间<ul><li>默认情况下，Cookie 存储在浏览器内存中 当浏览器关闭 内存释放 则Cookie被销毁</li><li>setMaxAge(int seconds) 设置Cookie存活时间<ul><li>正数 将Cookie写入浏览器所在电脑的硬盘 持久化存储 到时间自动删除</li><li>负数 默认值 Cookie在当前浏览器内存中 当浏览器关闭 则Cookie被销毁</li><li>零 删除对应Cookie</li></ul></li></ul></li><li>Cookie 存储中文<ul><li>Cookie 不能直接存储中文</li><li>如需要存储 则需要进行转码 URL编码<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><blockquote><p>服务端会话跟踪技术</p></blockquote><h2 id="Session-基本使用"><a href="#Session-基本使用" class="headerlink" title="Session 基本使用"></a>Session 基本使用</h2></li></ul></li><li>服务端会话跟踪技术 将数据保存到服务端</li><li>JavaEE提供HttpSession接口 来实现一次会话的多次请求间数据共享功能</li><li>使用<ul><li>获取Session对象<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session <span class="operator">=</span> request.getSession()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>Session 对象功能<ul><li>void setAttribute(String name,Object o) 存储数据到session域中</li><li>Object getAttribute(String name) 根据key 获取值</li><li>void removeAttribute(String name) 根据key 删除该键值对<h2 id="Session-原理"><a href="#Session-原理" class="headerlink" title="Session 原理"></a>Session 原理</h2></li></ul></li></ul></li><li>用户第一次请求服务器时，服务器端会生成一个sessionid</li><li>服务器端将生成的sessionid返回给客户端，通过set-cookie</li><li>客户端收到sessionid会将它保存在cookie中，当客户端再次访问服务端时会带上这个sessionid</li><li>当服务端再次接收到来自客户端的请求时，会先去检查是否存在sessionid，不存在就新建一个sessionid重复1,2的流程，如果存在就去遍历服务端的session文件，找到与这个sessionid相对应的文件，文件中的键值便是sessionid，值为当前用户的一些信息</li><li>此后的请求都会交换这个 Session ID，进行有状态的会话。<h2 id="Session-使用细节"><a href="#Session-使用细节" class="headerlink" title="Session 使用细节"></a>Session 使用细节</h2></li><li>Session 钝化 活化<ul><li>钝化 在服务器正常关闭后 Tomcat会自动将Session数据写入硬盘的文件中</li><li>活化 再次启动服务器后 从文件中加载数据到Session中</li></ul></li><li>Session 销毁<ul><li>默认情况下 无操作 30分组后自动销毁<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>调用Session对象的invalidate()方法</li></ul></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>Cookie 和 Session 都是来完成一次会话内多次请求间数据共享的</li><li>区别<ul><li>存储位置 Cookie 是将数据存储在客户端 Session将数据存储在服务器端</li><li>安全性 Cookie 不安全 Seesion 安全</li><li>数据大小 Cookie 最大3KB Session 无大小限制</li><li>存储时间 Cookie可以长时间存储 Session默认30分钟</li><li>服务器性能 Cookie不占服务器资源 Session 占用服务器资源</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Request&amp;Response</title>
      <link href="/2022/07/13/Request-Response/"/>
      <url>/2022/07/13/Request-Response/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Request 获取请求数据<br>Response 设置响应数据</p></blockquote><span id="more"></span><h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><h2 id="Request-继承体系"><a href="#Request-继承体系" class="headerlink" title="Request 继承体系"></a>Request 继承体系</h2><p><img src="/2022/07/13/Request-Response/Request%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png" alt="Request 继承体系"></p><ul><li>TomCat 需要解析请求数据 封装为request对象 并且创建request对象传递到service方法中<h2 id="Request-获取请求数据"><a href="#Request-获取请求数据" class="headerlink" title="Request 获取请求数据"></a>Request 获取请求数据</h2><h3 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h3></li><li>请求数据分为3部分<ul><li>请求行 GET&#x2F;request-demo&#x2F;reql?username &#x3D; zhangsan HTTP&#x2F;1.1<ul><li>String getMethod() 获取请求方式  ： GET</li><li>String getContextPath() 获取虚拟目录(目录访问路径) :&#x2F;request-demo</li><li>StringBuffer getRequestURL() 获取URL ： <a href="http://localhost:8080/request-demo/req1">http://localhost:8080/request-demo/req1</a></li><li>String getRequestURL() 获取URI ： &#x2F;request-demo&#x2F;req1</li><li>String getQueryString() 获取请求参数(GET方式) username&#x3D; zhangsan&amp;password &#x3D; 123</li></ul></li><li>请求头 User-Agent:Mozilla&#x2F;5.0 Chrome&#x2F;91.0.4472.106<ul><li>String getHeader(String name) 根据请求头名称 获取值</li></ul></li><li>请求体 username &#x3D; kris&amp;password &#x3D; 111<ul><li>ServletInputStream getInputSatream() 获取字节输入流</li><li>BufferedReader getReader() 获取字符输入流</li></ul></li></ul></li></ul><h3 id="通用方式获取请求参数"><a href="#通用方式获取请求参数" class="headerlink" title="通用方式获取请求参数"></a>通用方式获取请求参数</h3><ul><li>请求参数获取方式<ul><li>GET 方式<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">String</span> <span class="function"><span class="title">getQueryString</span>()</span></span><br></pre></td></tr></table></figure></li><li>POST 方式<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">BufferedReader</span> <span class="function"><span class="title">getReader</span>()</span></span><br></pre></td></tr></table></figure></li></ul></li><li>Request 通用方式获取请求参数<ul><li>Map&lt;String,String[]&gt; getParameterMap(); 获取所有参数Map集合</li><li>String[] getParameterValues(String name) 根据名称获取参数值(数组)</li><li>String getParameter(String name) 根据名称获取参数值(单个值)</li></ul></li></ul><h3 id="请求参数中文乱码处理"><a href="#请求参数中文乱码处理" class="headerlink" title="请求参数中文乱码处理"></a>请求参数中文乱码处理</h3><ul><li><p>请求参数如果存在中文数据，则会乱码</p><ul><li>POST： 设置输入流的编码<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>GET  先编码 再解码<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">String(<span class="params">username</span>.<span class="params">getBytes</span>(<span class="string">&quot;ISO-8859-1&quot;</span>)</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>URL 编码<ul><li>将字符串按照编码方式转为二进制</li><li>每个字节转为2个16进制数并在前边加上%<h2 id="Request-请求转发"><a href="#Request-请求转发" class="headerlink" title="Request 请求转发"></a>Request 请求转发</h2><blockquote><p>一种在服务器内部的资源跳转方式</p></blockquote></li></ul></li></ul></li><li><p>实现方式</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.getRequestDispatcher(<span class="string">&quot;资源B路径&quot;</span>).forward(req.resp)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>请求转发资源间共享数据 使用Requset 对象</p><ul><li>void setAttribute(String name,Object o) 存储数据到request域中</li><li>Object getAttribute(String name) 根据key 获取值</li><li>void removeAttribute(String name)根据key 删除该键值对</li></ul></li><li><p>请求转发特点</p><ul><li>浏览器地址栏路径不发生变化</li><li>只能转发到当前服务器的内部资源</li><li>一次请求 可以在转发的资源间使用request共享数据</li></ul></li></ul><h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><h2 id="Response-设置响应数据功能介绍"><a href="#Response-设置响应数据功能介绍" class="headerlink" title="Response 设置响应数据功能介绍"></a>Response 设置响应数据功能介绍</h2><ul><li><p>响应行 </p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure><ul><li>void setStatus(int sc) 设置响应状态码</li></ul></li><li><p>响应头</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>:<span class="type">text</span>/html</span><br></pre></td></tr></table></figure><ul><li>void setHeader(String name,String value) 设置响应头键值对</li></ul></li><li><p>响应体</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;html&gt;</span><span class="section">&lt;head&gt;</span><span class="section">&lt;/head&gt;</span><span class="section">&lt;body&gt;</span><span class="section">&lt;/body&gt;</span><span class="section">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><ul><li>PrintWrite getWriter() 获取字符输出流</li><li>ServletOutputStream getOutputStream() 获取字节输出流<h2 id="Response-完成重定向"><a href="#Response-完成重定向" class="headerlink" title="Response 完成重定向"></a>Response 完成重定向</h2><blockquote><p>重定向(Redirect) 一种资源跳转方式</p></blockquote></li></ul></li><li><p>实现方式</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp.set<span class="constructor">Status(302)</span>;</span><br><span class="line">resp.set<span class="constructor">Header(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;另一资源的路径&quot;</span>)</span>;</span><br><span class="line"><span class="comment">//简化版</span></span><br><span class="line">resp.send<span class="constructor">Redirect(<span class="string">&quot;另一资源的路径&quot;</span>)</span></span><br></pre></td></tr></table></figure></li><li><p>重定向特点</p><ul><li>浏览器地址栏发生变化</li><li>可以重定向到任意位置的资源(服务器内部，外部均可)</li><li>两次请求，不能在多个资源使用request共享数据<h2 id="Response-响应字符数据"><a href="#Response-响应字符数据" class="headerlink" title="Response 响应字符数据"></a>Response 响应字符数据</h2></li></ul></li><li><p>使用</p><ul><li>通过Response对象获取字符输出流<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter writer <span class="operator">=</span> resp.getWriter()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>写数据<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.write(<span class="string">&quot;kris&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>设置编码<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset = utf-8&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>该流不需要关闭 随着响应结束 response 对象销毁 由服务器关闭<h2 id="Response-响应字节数据"><a href="#Response-响应字节数据" class="headerlink" title="Response 响应字节数据"></a>Response 响应字节数据</h2></li></ul></li><li><p>使用</p><ul><li>通过Response对象获取字符输出流<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletOutputStream outputStream <span class="operator">=</span> resp.getOutputStream()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>写数据<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputStream.write(字节数据)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>IOUtils工具类的使用</p><ul><li>导入坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOUtils.<span class="keyword">copy</span>(输入流,输出流);</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="/2022/07/12/Servlet/"/>
      <url>/2022/07/12/Servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Servlet 是JavaEE规范之一，就是一个接口 我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</p></blockquote><span id="more"></span><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><ul><li>创建web项目 导入Servlet依赖坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>创建 定义一个类 实现Servlet接口 并重写接口中的所有方法 并在service方法中输入一句话<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ServletDemo</span> <span class="symbol">implements</span> <span class="symbol">Servlet</span></span><br></pre></td></tr></table></figure></li><li>配置 在类上使用@WebServlet 注解 配置Servlet的访问路径<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(<span class="string">&quot;/demo1&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ServletDemo</span> <span class="symbol">implements</span> <span class="symbol">Servlet</span></span><br></pre></td></tr></table></figure><ul><li>注解中的loadOnStartip参数<ul><li>若为负整数(默认-1) 第一次被访问时创建Servlet对象</li><li>0或正整数 服务器启动时创建Servlet对象，数字越小优先级越高</li></ul></li></ul></li><li>访问 启动TomCat 浏览器输入URL访问该Servlet<h1 id="Servlet-执行流程"><a href="#Servlet-执行流程" class="headerlink" title="Servlet 执行流程"></a>Servlet 执行流程</h1></li><li>当Servlet第一次被调用的时候会触发init函数，该函数会把servlet实例加载到内存。该函数只会被调用一次</li><li>web服务器把接收到的http请求封装成一个Request对象，作为service函数的参数传递进去。</li><li>service函数会被调用多次，每访问一次Servlet，它的service函数就会被调用一次</li><li>返回的结果封装在response对象，web服务器先将response的信息拆解出来<br>形成http响应格式。然后将这个结果返回给浏览器。</li><li>浏览器得到结果之后会自己能识别的格式进行解析<h1 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h1></li><li>对象的生命周期指一个对象从被创建到销毁的整个过程</li><li>Servlet 运行在Servlet容器(web服务器)中，其生命周期由容器来管理 分为4个阶段<ul><li>加载和实例化 默认情况下 当Servlet第一次被访问时，由容器创建Servlet对象</li><li>初始化 在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象 完成一些如加载配置文件 创建连接等初始化的工作 该方法只调用一次</li><li>请求处理 每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理</li><li>服务终止 当需要释放内存或者容器关闭时 容器就会调用Servlet实例的destroy()方法完成资源的释放，在destroy()方法调用之后 容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</li></ul></li></ul><h1 id="Servlet-体系结构"><a href="#Servlet-体系结构" class="headerlink" title="Servlet 体系结构"></a>Servlet 体系结构</h1><blockquote><p>开发B&#x2F;S架构的web项目，都是针对HTTP协议 所以自定义的Servlet 会继承HttpServlet</p></blockquote><p><img src="/2022/07/12/Servlet/Servlet%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="Servlet体系结构"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@WebServlet</span>(<span class="string">&quot;/demo2&quot;</span>)</span><br><span class="line">    public <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doGet(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doPost(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Servlet-urlPattern配置"><a href="#Servlet-urlPattern配置" class="headerlink" title="Servlet urlPattern配置"></a>Servlet urlPattern配置</h1><ul><li>Servlet 要想被访问 必须配置其访问路径(urlPattern)<ul><li>一个Servlet 可以配置多个urlPattern<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPattern = &#123;<span class="string">&quot;/demo1&quot;</span>,<span class="string">&quot;/demo2&quot;</span>&#125;)</span></span><br></pre></td></tr></table></figure></li><li>urlPattern 配置规则<ul><li>精确匹配  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">配置路径  <span class="variable">@WebServlet</span>(&quot;/user/select&quot;)</span><br><span class="line">访问路径 localhost:<span class="number">8080</span><span class="operator">/</span>web<span class="operator">-</span>demo<span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span><span class="keyword">select</span></span><br></pre></td></tr></table></figure></li><li>目录匹配  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置路径  @WebServlet(<span class="string">&quot;/user/*&quot;</span>)</span><br><span class="line">访问路径 localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/aaa</span><br><span class="line">         localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/bbb</span><br></pre></td></tr></table></figure></li><li>扩展名匹配  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置路径  @WebServlet(<span class="string">&quot;*.do&quot;</span>)</span><br><span class="line">访问路径 localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/aaa.<span class="keyword">do</span></span><br><span class="line">         localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/bbb.<span class="keyword">do</span></span><br></pre></td></tr></table></figure></li><li>任意匹配  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置路径  <span class="variable">@WebServlet</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">          <span class="variable">@WebServlet</span>(<span class="string">&quot;/*&quot;</span>)</span><br><span class="line">访问路径 <span class="attribute">localhost</span>:<span class="number">8080</span>/web-demo/haha</span><br></pre></td></tr></table></figure></li><li>优先级<br>  精确&gt;目录&gt;扩展名&gt;&#x2F;*&gt;&#x2F;<h1 id="XML-配置方式编写-Servlet"><a href="#XML-配置方式编写-Servlet" class="headerlink" title="XML 配置方式编写 Servlet"></a>XML 配置方式编写 Servlet</h1></li></ul></li></ul></li><li>Servlet 从3.0版本后开始支持使用注解配置 3.0之前只支持XML配置文件的配置方式</li><li>步骤<ul><li>编写Servlet类</li><li>在web.xml中配置Servelt<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;demo&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.kris.servletDemo&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;demo&lt;/servlet&gt;</span><br><span class="line">    &lt;url-pattern&gt;/demo&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TomCat</title>
      <link href="/2022/07/12/TomCat/"/>
      <url>/2022/07/12/TomCat/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Web 服务器是一个应用程序 对HTTP协议的操作进行封装，使的程序员不必直接对协议进行操作，让Web开发更加便捷 </p></blockquote><span id="more"></span><h1 id="TomCat-目录结构"><a href="#TomCat-目录结构" class="headerlink" title="TomCat 目录结构"></a>TomCat 目录结构</h1><ul><li>bin 可执行文件存放目录</li><li>conf 配置文件存放目录</li><li>lib tomcat依赖的jar包</li><li>logs 日志文件</li><li>temp 临时文件</li><li>webapps 应用发布目录</li><li>work 工作目录<h1 id="TomCat-基本使用"><a href="#TomCat-基本使用" class="headerlink" title="TomCat 基本使用"></a>TomCat 基本使用</h1></li><li>配置<ul><li>修改启动端口号: conf&#x2F;server.xml<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port<span class="operator">=</span><span class="string">&quot;8080&quot;</span> protocol<span class="operator">=</span><span class="string">&quot;HTTP/1.1&quot;</span></span><br><span class="line">  connectionTimeout<span class="operator">=</span><span class="string">&quot;20000&quot;</span></span><br><span class="line">  redirectPort<span class="operator">=</span><span class="string">&quot;8443&quot;</span> /&gt;</span><br><span class="line">  //默认为 <span class="number">8080</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>HTTP协议默认端口号为80，如果将TomCat端口号改为80，则将来访问时将不用输入端口号</strong></p><ul><li>启动时可能出现的问题<ul><li>端口号冲突 找到对应程序 将其关闭</li><li>闪退 检查JAVA_HOME 环境变量是否正确配置</li></ul></li><li>TonCat 部署项目<ul><li>将项目放置到webapps 目录下，即部署完成</li></ul></li><li>一般JavaWeb项目会被打成war包 然后将war包放到webapps目录下,TomCat会自动解压缩war文件</li></ul><h1 id="IDEA中创建Maven-Web-项目"><a href="#IDEA中创建Maven-Web-项目" class="headerlink" title="IDEA中创建Maven Web 项目"></a>IDEA中创建Maven Web 项目</h1><ul><li>使用骨架(项目模板)<ul><li>选择web项目骨架，创建项目</li><li>删除pom.xml中多余的坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">以下到<span class="tag">&lt;/<span class="name">project</span>&gt;</span>以上的部分都可删除</span><br></pre></td></tr></table></figure></li><li>补齐缺失的目录结构<ul><li>java</li><li>resources</li></ul></li></ul></li><li>不使用<ul><li>新建maven模板  </li><li>将打包方式改为war</li><li>补齐缺失的目录结构<ul><li>webapp 以及其子目录</li></ul></li></ul></li></ul><h1 id="IDEA中使用TomCat"><a href="#IDEA中使用TomCat" class="headerlink" title="IDEA中使用TomCat"></a>IDEA中使用TomCat</h1><ul><li>pom.xml 添加TomCat插件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用Maven Helper 插件启动项目 选中项目 右键-&gt; Run Maven –&gt; tomcat7:run</li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2022/07/11/JS-1/"/>
      <url>/2022/07/11/JS-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>JavaScript 是一门跨平台，面向对象的脚本语言，来控制网页行为的，它能使网页可交互</p></blockquote><span id="more"></span><h1 id="JS-引入方式"><a href="#JS-引入方式" class="headerlink" title="JS 引入方式"></a>JS 引入方式</h1><ul><li>内部脚本 将JS代码定义在HTML页面中<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  JS代码</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在HTML文档中可以在任意地方，放置任意数量的&lt;script&gt;</li><li>一般把脚本置于&lt;body&gt;元素的底部，可以改善显示速度，因为脚本执行会拖慢显示</li></ul></li><li>外部脚本 将JS代码定义在外部JS文件中，然后引入到HTML页面中<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">script</span> src = <span class="string">&quot;xxx.js&quot;</span>&gt;&lt;\<span class="keyword">script</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>外部脚本不能包含&lt;script&gt;标签</li><li>&lt;script&gt; 标签不能自闭合<h1 id="JS-基础语法"><a href="#JS-基础语法" class="headerlink" title="JS 基础语法"></a>JS 基础语法</h1><h2 id="书写语法"><a href="#书写语法" class="headerlink" title="书写语法"></a>书写语法</h2></li></ul></li><li>区分大小写 与Java一样 变量名 函数名 以及其他一切东西都是区分大小写的</li><li>每行结尾的分号可有可无</li><li>注释<ul><li>单行  &#x2F;&#x2F;</li><li>多行  &#x2F;**&#x2F;</li></ul></li><li>大括号表示代码块<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  代码</span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h2></li><li>使用 window.alert()写入警告框</li><li>使用document.write()写入HTML输出</li><li>使用console.log()写入浏览器控制台<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li><li>JS 中用var关键字来声明变量 相当于全局变量 并且可以重复定义</li><li>JS是一门弱类型语言，变量可以存放不同类型的值<ul><li>组成字符可以是任何字母 数字 下划线 或者美元符号($)</li><li>数字不能开头</li><li>建议使用驼峰命名</li></ul></li><li>ECMAScript 6 新增let关键字来定义变量，用法类似var 但是所声明的变量只在let关键字所在的代码块内有效，且不允许重复声明</li><li>ECMAScript 6 新增了const 关键字 用来声明一个只读的常量，一旦声明，常量的值就不能改变<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2></li><li>原始类型<ul><li>number 数字(整数 小数 NaN(Not a Number))</li><li>string 字符 字符串 单双引皆可</li><li>boolean 布尔 </li><li>null 对象为空</li><li>undefined 当声明的变量未初始化时 该变量的默认值时undefined</li></ul></li></ul><p><strong>使用typeof运算符可以获取数据类型</strong></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>&#x3D;&#x3D; 会先判断数据类型 然后进行转换，在比较值，如 整数20会&#x3D;&#x3D; 字符串20</li><li>&#x3D;&#x3D;&#x3D; 不会进行类型转换，类型不一样返回false</li><li>类型转换<ul><li>字符串的字面值转成整数，如果字符串字母值时字符，会转换成NaN，布尔类型 true 1 false 0</li><li>0或者NaN会转成false 其他则为 true</li><li>空字符串转成false 其他为true</li><li>null 和 undefined都转为false<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2></li></ul></li><li>JS 函数通过function关键词进行定义 语法为<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">定义方式一</span><br><span class="line"><span class="keyword">function</span> 函数名(<span class="params">参数<span class="number">1</span>，参数<span class="number">2</span>，...</span>)&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br><span class="line">定义方式二</span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="keyword">function</span>(<span class="params">参数列表</span>)&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>形参不需要类型 因为JS时弱类型语言</li><li>返回值也不需要定义类型 可以在函数内部直接使用return返回即可</li><li>JS 中，函数调用可以传递任意个数参数<h1 id="JS-常用对象"><a href="#JS-常用对象" class="headerlink" title="JS 常用对象"></a>JS 常用对象</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2></li><li>定义<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="built_in">Array</span>（元素列表）;<span class="comment">//方式 一</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = [元素列表];<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure></li><li>访问<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[索引] <span class="operator">=</span> 值</span><br></pre></td></tr></table></figure></li></ul><p><strong>JS类似于Java集合 长度和类型都可变</strong></p><ul><li>push()  添加元素</li><li>splice() 删除<ul><li>参数一 从哪开始山</li><li>参数二 删几个</li></ul></li></ul><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_array.asp">JS Array</a></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>定义<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="built_in">String</span>(s);<span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = s；<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure></li><li>属性<ul><li>length  字符串长度</li><li>…</li></ul></li><li>方法<ul><li>charAt()  返回指定位置的字符</li><li>indexOf()   检索字符串</li><li>trim() 去除首位的空格</li><li>…</li></ul></li></ul><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_string.asp">JS String</a></p><h2 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h2><ul><li>格式<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名称 <span class="operator">=</span> &#123;</span><br><span class="line">  属性名称<span class="number">1</span>:属性值<span class="number">1</span>，</span><br><span class="line">  属性名称<span class="number">2</span>:属性值<span class="number">2</span>，</span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">  函数名称:<span class="title function_">function</span>(形参列表)&#123;&#125;</span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1></li><li>Brower Object Model 浏览器对象模型</li><li>JavaScript 将浏览器的各个组成部分封装为对象</li></ul><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><ul><li><p>Window 浏览器窗口对象</p></li><li><p>获取 直接使用window 其中window. 可以省略</p></li><li><p>属性 获取其他BOM对象</p><ul><li>history  对History 对象的只读引用</li><li>Navigator  对<a href="https://www.w3school.com.cn/jsref/obj_navigator.asp">Navigator</a>对象的只读引用</li><li>Screen  对<a href="https://www.w3school.com.cn/jsref/obj_screen.asp">Screen</a>对象的只读引用</li><li>location 用于窗口或框架的Location对象</li></ul></li><li><p>方法</p><ul><li>alert() 显示带有一段信息和一个确认按钮的警告框</li><li>confirm() 显示带有一段信息以及确认按钮和取消按钮的对话框 <ul><li>返回flag 确认为true 取消 false</li></ul></li><li>setInterval() 按照指定的周期(以毫秒计)来调用函数或计算表达式 <ul><li>参数一 function</li><li>参数二 毫秒值</li></ul></li><li>setTimeout() 在指定的毫秒数后调用函数或者计算表达式<ul><li>参数一 function</li><li>参数二 毫秒值<h2 id="History-历史记录对象"><a href="#History-历史记录对象" class="headerlink" title="History 历史记录对象"></a>History 历史记录对象</h2></li></ul></li></ul></li><li><p>History 历史记录</p></li><li><p>获取 使用window.history获取 </p></li><li><p>方法</p><ul><li>back()  加载history列表中的前一个URL</li><li>forward()  加载history列表中的下一个URL <h2 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h2></li></ul></li><li><p>Location 地址栏对象</p></li><li><p>获取 使用window.location获取</p></li><li><p>属性</p><ul><li>href  设置或返回完整的URL<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1></li></ul></li><li><p>Document Object Model 文档对象模型</p></li><li><p>将标记语言的各个组成部分封装为对象</p><ul><li>Document 整个文档对象</li><li>Element  元素对象</li><li>Attribute   属性对象</li><li>Text   文本对象</li><li>Comment   注释对象</li></ul></li><li><p>JS 通过 DOM 能对HTML进行操作</p><ul><li>改变HTML元素的内容</li><li>改变HTML元素的样式</li><li>对HTML DOM 事件做出反应</li><li>添加和删除HTML元素<h2 id="获取Element对象"><a href="#获取Element对象" class="headerlink" title="获取Element对象"></a>获取Element对象</h2></li></ul></li><li><p>获取 使用Document 对象的方法来获取</p><ul><li>getElementById 根据id值获取 返回一个Element对象</li><li>getElementByName  根据name属性值获取 返回Element对象数组</li><li>getElementByTagName 根据标签名获取 返回Element对象数组</li><li>getElementByClassName 根据class属性值获取 返回Element对象数组</li></ul></li></ul><h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><ul><li><p>事件 HTML事件是发生在HTML元素上的“事情” 例如</p><ul><li>按钮被点击</li><li>鼠标移动到元素上</li></ul></li><li><p>事件监听 JS可以在事件被侦测到时执行代码</p></li></ul><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><ul><li>方式一 通过HTML标签中的事件属性进行绑定<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">&quot;button&quot;</span> onclick = <span class="string">&#x27;on()&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">on</span><span class="params">()</span></span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;点击&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方式二 通过DOM元素属性绑定<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type<span class="operator">=</span><span class="string">&quot;button&quot;</span> id <span class="operator">=</span> <span class="string">&quot;btn&quot;</span>&gt;</span><br><span class="line">document.getElementById(<span class="string">&quot;btn&quot;</span>).onclick <span class="operator">=</span> function()&#123;</span><br><span class="line">  alert(<span class="string">&quot;点击&quot;</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h2><table><thead><tr><th>事件名</th><th>说明</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标点击事件</td></tr><tr><td>onblur</td><td>元素失去焦点</td></tr><tr><td>onfocus</td><td>元素获得焦点</td></tr><tr><td>onload</td><td>某个页面或图像被完成加载</td></tr><tr><td>onsubmit</td><td>当表单提交时触发该事件</td></tr><tr><td>onkeydown</td><td>某个键盘的键被按下</td></tr><tr><td>onmouseover</td><td>鼠标被移到某元素上</td></tr><tr><td>onmouseout</td><td>鼠标从某元素移开</td></tr></tbody></table><p><a href="https://www.w3school.com.cn/jsref/dom_obj_event.asp">DOM 事件</a></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2022/07/11/CSS/"/>
      <url>/2022/07/11/CSS/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>CSS(Cascading Style Sheet) 层叠样式表 用于控制网页表现</p></blockquote><span id="more"></span><h1 id="CSS-导入方式"><a href="#CSS-导入方式" class="headerlink" title="CSS 导入方式"></a>CSS 导入方式</h1><ul><li>内联样式 在标签内部使用style属性 属性值是css属性键值对<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> style = <span class="string">&quot;color:red&quot;</span>&gt; Hello World&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></li><li>内部样式 使用&lt;style&gt;标签 在标签内部定义css样式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span> = <span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  &lt;\style&gt;</span></span><br></pre></td></tr></table></figure></li><li>外部样式 定义link标签 引入外部的css文件<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel <span class="operator">=</span> <span class="string">&quot;stylesheet&quot;</span> href <span class="operator">=</span> <span class="string">&quot;demo.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h1></li><li>概念 选择器是选取需设置样式的元素（标签）</li><li>分类<ul><li>元素选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素名称&#123;<span class="attribute">color</span> : red;&#125;</span><br></pre></td></tr></table></figure></li><li>id 选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span>属性值&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></li><li>类选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span>属性值&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><h1 id="CSS-属性"><a href="#CSS-属性" class="headerlink" title="CSS 属性"></a>CSS 属性</h1><a href="https://www.w3school.com.cn/cssref/index.asp">CSS参考手册</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2022/07/10/HTML/"/>
      <url>/2022/07/10/HTML/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>HTML(HyperText Markup Language) 超文本标记语言，除了文字信息还可以定义图片 音频 视频等内容，HTML 运行在浏览器上，其标签由浏览器来解析</p></blockquote><span id="more"></span><h1 id="HTML-快速入门"><a href="#HTML-快速入门" class="headerlink" title="HTML 快速入门"></a>HTML 快速入门</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        页面内容</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>HTML 文件以.html 或者 .htm为扩展名</li><li>HTML标签不区分大小写</li><li>HTML 标签属性值 单双引皆可</li><li>HTML 语法松散<h1 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;h1&gt; &lt;h6&gt;</td><td>定义标题，h1最大，h2最小</td></tr><tr><td>&lt;font&gt;</td><td>定义文本的字体 字体尺寸 字体颜色</td></tr><tr><td>&lt;b&gt;</td><td>定义粗体文本</td></tr><tr><td>&lt;i&gt;</td><td>定义斜体文本</td></tr><tr><td>&lt;u&gt;</td><td>定义文本下划线</td></tr><tr><td>&lt;center&gt;</td><td>定义文本居中</td></tr><tr><td>&lt;p&gt;</td><td>定义段落</td></tr><tr><td>&lt;br&gt;</td><td>定义折行</td></tr><tr><td>&lt;hr&gt;</td><td>定义水平线</td></tr></tbody></table></li></ul><h1 id="图片-视频-音频-标签"><a href="#图片-视频-音频-标签" class="headerlink" title="图片 视频 音频 标签"></a>图片 视频 音频 标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;img&gt;</td><td>定义图片</td></tr><tr><td>&lt;audio&gt;</td><td>定义音频</td></tr><tr><td>&lt;video&gt;</td><td>定义视频</td></tr></tbody></table><ul><li><p>img 定义图片</p><ul><li>src 规定显示图片的URL(统一资源定位符)</li><li>height 定义图像的高度 尺寸单位 px 和 %</li><li>width 定义图像的宽度 尺寸单位 px 和 %</li></ul></li><li><p>audio 定义音频 支持 MP3 WAV OGG</p><ul><li>src 规定音频的URL</li><li>controls 显示播放控件</li></ul></li><li><p>video 定义视频 支持 MP4 WebM OGG</p><ul><li>src 规定视频的URL</li><li>controls 显示播放控件<h1 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;a&gt;</td><td>定义超标签，用于链接到另一个资源</td></tr></tbody></table></li></ul></li><li><p>href 指定访问资源的URL</p></li><li><p>target 指定打开资源的方式</p><ul><li>_self 默认值  在当前也页面打开</li><li>_blank 在空白页打开<h1 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;ol&gt;</td><td>定义有序列表</td></tr><tr><td>&lt;ul&gt;</td><td>定义无序列表</td></tr><tr><td>&lt;li&gt;</td><td>定义列表项</td></tr></tbody></table></li></ul></li><li><p>type 设置项目符号 <strong>不建议使用 一般在css中设置</strong></p></li><li><p>有序列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.内容    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">2.内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容 <span class="tag">&lt;/<span class="name">li</span>&gt;</span>   </span><br><span class="line">3.内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span>          </span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;/<span class="name">ol</span>&gt;</span>       </span><br></pre></td></tr></table></figure></li><li><p>无序列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">· 内容    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">· 内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容 <span class="tag">&lt;/<span class="name">li</span>&gt;</span>   </span><br><span class="line">· 内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span>          </span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">ol</span>&gt;</span>     </span><br></pre></td></tr></table></figure><h1 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;table&gt;</td><td>定义表格</td></tr><tr><td>&lt;tr&gt;</td><td>定义行</td></tr><tr><td>&lt;td&gt;</td><td>定义单元格</td></tr><tr><td>&lt;th&gt;</td><td>定义表头单元格</td></tr></tbody></table></li><li><p>table 定义表格</p><ul><li>border 规定表格边框的宽度</li><li>width 规定表格的宽度</li><li>cellspacing 规定单元格之间的空白</li></ul></li><li><p>tr 定义行</p><ul><li>align 定义表格行的内容对齐方式</li></ul></li><li><p>td 定义单元格</p><ul><li>rowspan 规定单元格可横跨的行数</li><li>colspan 规定单元格可横跨的列数</li></ul></li></ul><h1 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;div&gt;</td><td>定义HTML文档中的一个区域部分，经常与css一起使用，用来布局网页</td></tr><tr><td>&lt;span&gt;</td><td>用于组合行内元素</td></tr></tbody></table><p><strong>与CSS一起使用</strong></p><h1 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;form&gt;</td><td>定义表单</td></tr><tr><td>&lt;input&gt;</td><td>定义表单项，通过type属性控制输入形式</td></tr><tr><td>&lt;label&gt;</td><td>为表单项定义标注</td></tr><tr><td>&lt;select&gt;</td><td>定义下拉列表</td></tr><tr><td>&lt;option&gt;</td><td>定义下拉列表的列表项</td></tr><tr><td>&lt;textarea&gt;</td><td>定义文本域</td></tr></tbody></table><ul><li>表单 在网页中只要负责数据采集功能 使用&lt;form&gt;标签定义表单</li><li>表单项(元素)：不同类型的input元素，下拉列表，文本域等</li><li>form 定义表单<ul><li>action 规定当提交表单时向何处发送表单数据 URL</li><li>method 规定发送表单数据的方式<ul><li>get 浏览器会将数据直接附在表单的action URL之后，大小会有限制</li><li>post 浏览器会将数据放到http请求信息体中。大小无限制</li></ul></li></ul></li></ul><table><thead><tr><th>type取值</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>默认值 定义单行的输入字段</td></tr><tr><td>password</td><td>定义密码字段</td></tr><tr><td>radio</td><td>定义单选按钮</td></tr><tr><td>checkbox</td><td>定义复选框</td></tr><tr><td>file</td><td>定义文件上传按钮</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段</td></tr><tr><td>submit</td><td>定义提交按钮 提交按钮会把表单数据发送到服务器</td></tr><tr><td>reset</td><td>定义重置按钮 该按钮会清除表达中的所有数据</td></tr><tr><td>button</td><td>定义可点击按钮</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis---(1)</title>
      <link href="/2022/07/09/MyBatis-1/"/>
      <url>/2022/07/09/MyBatis-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>MyBatis 是一款优秀的持久层框架，用于简化JDBC开发</p></blockquote><span id="more"></span><ul><li><p>持久层</p><ul><li>负责将数据保存到数据库的那一层代码</li><li>JavaEE三层架构：表现层，业务层，持久层</li></ul></li><li><p>框架</p><ul><li>框架就是一个半成品软件，是一套可重用的，通用的 软件基础代码模型</li><li>在框架的基础之上构建软件编写更加高效 规范 通用 可扩展</li></ul></li></ul><h1 id="JDBC-缺点"><a href="#JDBC-缺点" class="headerlink" title="JDBC 缺点"></a>JDBC 缺点</h1><ul><li>硬编码        <ul><li>注册驱动，获取连接</li><li>SQL语句</li></ul></li><li>操作繁琐<ul><li>手动设置参数</li><li>手动封装结果集</li></ul></li></ul><p><strong>MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作，硬编码可通过配置文件的方式完成</strong></p><h1 id="MyBatis-快速入门"><a href="#MyBatis-快速入门" class="headerlink" title="MyBatis 快速入门"></a>MyBatis 快速入门</h1><h2 id="查询表中所有数据"><a href="#查询表中所有数据" class="headerlink" title="查询表中所有数据"></a>查询表中所有数据</h2><ul><li>创建表  添加数据</li><li>创建模块 导入坐标</li><li>编写MyBatis 核心配置文件 –&gt; 替换连接信息 解决硬编码问题</li><li>编写SQL映射文件 –&gt; 统一管理sql语句 解决硬编码问题</li><li>编码<ul><li>定义POJO类</li><li>加载核心配置文件，获取SqlSessionFactory 对象</li><li>获取SqlSession 对象，执行SQL语句</li><li>释放资源<h2 id="解决SQL映射文件的警告提示"><a href="#解决SQL映射文件的警告提示" class="headerlink" title="解决SQL映射文件的警告提示"></a>解决SQL映射文件的警告提示</h2></li></ul></li><li>产生原因：Idea和数据库没有建立连接 不识别表信息</li><li>解决方式；在Idea中配置MySQL数据库连接 <h1 id="Mapper-代理开发"><a href="#Mapper-代理开发" class="headerlink" title="Mapper 代理开发"></a>Mapper 代理开发</h1></li><li>目的<ul><li>解决原生方式的硬编码</li><li>简化后期执行SQL<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2></li></ul></li><li>定义与SQL映射文件同名的Mapper接口，并将Mapper接口的SQL映射文件放置在同一目录下</li><li>设置SQL映射文件的namespace属性为Mapper接口全限定名</li><li>在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致</li><li>编码<ul><li>通过SqlSession的getMapper方法获取Mapper接口的代理对象</li><li>通过对应方法完成sql的执行</li></ul></li></ul><p><strong>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载</strong></p><h1 id="Mybatis-核心配置文件"><a href="#Mybatis-核心配置文件" class="headerlink" title="Mybatis 核心配置文件"></a>Mybatis 核心配置文件</h1><p><a href="https://mybatis.net.cn/configuration.html">MyBatis官方文档</a></p><h1 id="配置文件完成增删改查"><a href="#配置文件完成增删改查" class="headerlink" title="配置文件完成增删改查"></a>配置文件完成增删改查</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kris.dao.AccountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kris.domain.Account&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        select * from tb_account;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>id 执行sql的唯一标识  mybatis根据id 来找到需要执行的sql语句 可以自定义   建议使用接口中的方法名定义</li><li>resultType 表示结果类型 是sql 得到的ResultSet 遍历这个Result得到的java对象类型  写的是类型的全限定名称</li><li><a href="http://mybatis.org/dtd/mybatis-3-mapper.dtd">http://mybatis.org/dtd/mybatis-3-mapper.dtd</a>    约束文件</li><li>namespace 命名空间 dao接口的全限定名称</li></ul><h2 id="查询映射"><a href="#查询映射" class="headerlink" title="查询映射"></a>查询映射</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>resultMap id<span class="operator">=</span>&quot;无要求&quot; type<span class="operator">=</span>&quot;封装类名&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="comment">-- id 是主键字段的映射</span></span><br><span class="line">    <span class="comment">-- result 是其他字段的映射</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">result</span> <span class="keyword">column</span><span class="operator">=</span>&quot;列名&quot; property<span class="operator">=</span>&quot;别名&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">result</span> <span class="keyword">column</span><span class="operator">=</span>&quot;列名&quot; property<span class="operator">=</span>&quot;别名&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>resultMap<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;selectOne&quot; resultMap<span class="operator">=</span>&quot;无要求&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h2 id="MyBatisX插件"><a href="#MyBatisX插件" class="headerlink" title="MyBatisX插件"></a>MyBatisX插件</h2><blockquote><p>MyBatisX 是一款基于IDEA的快速开发插件 为效率而生</p></blockquote><ul><li>功能<ul><li>XML 和接口方法相互跳转</li><li>根据接口方法生成statement</li><li>安装<blockquote><p>在IDEA中的Plugin中搜索即可</p></blockquote></li></ul></li></ul><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ul><li>在定义的Mapper接口中写出需要实现的接口映射</li><li>利用插件的快捷方式在xml文件中编写对应的sql语句</li><li>id 需要与 接口名字相同</li><li>参数接收<ul><li>#{}   会将其替换为？，防止SQL注入</li><li>${}  拼sql 会有SQL注入问题</li></ul></li><li>转义<ul><li>CDATA 区  会将区域内的当作纯文本处理    CD提示</li><li>查询对应字符在xml的转义</li></ul></li><li>多个参数的接受<ul><li>散装参数：使用@Param(“SQL参数占位符名称”)</li><li>对象参数 对象的属性名称要和参数占位符名称一致</li><li>map map的key值要与参数占位符名称一致</li></ul></li><li>使用where 标签 并且 条件前都得加上and</li><li>默认开启事务 需要手动提交</li><li>获取主键id  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">useGeneratedKeys</span> <span class="operator">=</span> </span><br><span class="line">true<span class="string">&quot; keyProperty = &quot;</span>id<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li><li>删除 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delete <span class="keyword">from</span> 表名 <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (</span><br><span class="line">    &lt;foreach collection = <span class="string">&quot;arrays(或者用Param注解改变名称)&quot;</span> <span class="built_in">item</span> = <span class="string">&quot;id&quot;</span> separator=<span class="string">&quot;,&quot;</span>(分隔符)&gt;</span><br><span class="line">    <span class="comment">#&#123;id&#125;</span></span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h1 id="注解完成增删改查"><a href="#注解完成增删改查" class="headerlink" title="注解完成增删改查"></a>注解完成增删改查</h1><blockquote><p>注解用来完成简单的工作  配置文件用来完成复杂的工作</p></blockquote><ul><li>查询 @Select</li><li>添加 @Insert</li><li>修改 @Update</li><li>删除 @Delete<h1 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h1><a href="https://mybatis.net.cn/dynamic-sql.html">MyBatis官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven---(1)</title>
      <link href="/2022/07/08/Maven-1/"/>
      <url>/2022/07/08/Maven-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Apache Maven 是一个项目管理和构建工具，基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建，报告和文档</p></blockquote><span id="more"></span><ul><li>提供了一套标准的项目结构<blockquote><p>在不同的IDE中的项目结构并不相同，Maven提供了一套标准化的项目，以便在不同的IDE中通用</p></blockquote></li><li>提供了一套标准化的构建流程(编译，测试，打包，发布…)</li><li>提供了一套依赖管理机制<blockquote><p>依赖管理就是管理你项目所依赖的第三方资源(jar包。插件…)</p></blockquote></li></ul><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><ul><li><a href="http://maven.apache.org/">官网</a></li><li><a href="http://maven.apache.org/download.cgi">下载地址</a></li><li>解压 apache-maven-3.6.1.rar 即安装完成</li><li>配置环境变量 MAVEN_HOME 为安装路径的bin目录</li><li>配置本地仓库：修改conf&#x2F;settings.xml中的&lt;localRepository&gt;为一个指定目录</li><li>配置阿里云私服，修改conf&#x2F;settings.xml中的&lt;mirrors&gt;标签，为其添加如下子标签<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>compile 编译</li><li>clean 清理</li><li>test 测试</li><li>package 打包</li><li>install 安装<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2></li><li>Maven 构建项目生命周期描述是一次构建过程经历经历了多少个事件</li><li>Maven 对项目构建的生命周期划分为3套<ul><li>clean 清理工作</li><li>default 核心工作 例如编译 测试 打包 安装等</li><li>site 产生报告 发布站点</li></ul></li></ul><p><strong>同一生命周期内，执行后边的命令，前边的所有命令会自动执行</strong></p><h1 id="IDEA-配置Maven"><a href="#IDEA-配置Maven" class="headerlink" title="IDEA 配置Maven"></a>IDEA 配置Maven</h1><h2 id="IDEA-配置Maven-环境"><a href="#IDEA-配置Maven-环境" class="headerlink" title="IDEA 配置Maven 环境"></a>IDEA 配置Maven 环境</h2><ul><li>选择 IDEA 中 File –&gt; Settings</li><li>搜索 maven</li><li>设置 IDEA 使用本地安装的Maven，并修改配置文件路径<h2 id="Maven-坐标详解"><a href="#Maven-坐标详解" class="headerlink" title="Maven 坐标详解"></a>Maven 坐标详解</h2></li><li>什么是坐标 <ul><li>Maven 中的坐标是资源的唯一标识</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul></li><li>Maven 坐标主要组成<ul><li>groupId 定义当前Maven项目隶属组织名称(通常是域名反写 如: com.itheima)</li><li>artifactId 定义当前Maven项目名称(通常是模块名称 如 order-service goods-service)</li><li>version 定义当前项目版本号</li></ul></li></ul><h2 id="IDEA-创建-Maven-项目"><a href="#IDEA-创建-Maven-项目" class="headerlink" title="IDEA 创建 Maven 项目"></a>IDEA 创建 Maven 项目</h2><ul><li>创建模块 选择Maven 点击Next</li><li>填写模块名称 坐标信息 点击finish 创建完成</li><li>编写程序<h2 id="IDEA-导入-Maven-项目"><a href="#IDEA-导入-Maven-项目" class="headerlink" title="IDEA 导入 Maven 项目"></a>IDEA 导入 Maven 项目</h2></li><li>选择右侧Maven面板 点击 + 号</li><li>选中对应项目的pom.xml文件，双击即可</li><li>如果没有Maven面板 选择View -&gt; Appearance -&gt; Tool Window Bars</li></ul><h2 id="配置Maven-Helper-插件"><a href="#配置Maven-Helper-插件" class="headerlink" title="配置Maven-Helper 插件"></a>配置Maven-Helper 插件</h2><ul><li>选择IDEA 中 File -&gt; Settings</li><li>选择 Plugins</li><li>搜索 Maven</li><li>安装 Maven Helper </li><li>重启IDEA</li></ul><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><h2 id="使用坐标导入jar包"><a href="#使用坐标导入jar包" class="headerlink" title="使用坐标导入jar包"></a>使用坐标导入jar包</h2><ul><li>在pom.xml 中编写&lt;dependencies&gt;标签</li><li>在&lt;dependencies&gt; 标签中使用&lt;dependency&gt;引入坐标</li><li>定义坐标的 groupId artifactId version</li><li>点击刷新按钮 使坐标生效<h2 id="使用坐标导入jar包-快捷方式"><a href="#使用坐标导入jar包-快捷方式" class="headerlink" title="使用坐标导入jar包 -快捷方式"></a>使用坐标导入jar包 -快捷方式</h2></li><li>在pom.xml 中按alt + insert，选择Dependency</li><li>在弹出的面板中搜索对应坐标，双击选中</li><li>点击刷新按钮 使坐标生效</li></ul><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><ul><li><p>通过设置坐标的依赖范围(scope)，可以设置对jar包的作用范围：编译环境 测试环境 运行环境</p><table><thead><tr><th>依赖范围</th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例子</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td>system</td><td>Y</td><td>Y</td><td>-</td><td>存储在本地的jar包</td></tr></tbody></table></li><li><p>&lt;scope&gt; 默认值  compile</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2022/07/07/JDBC-1/"/>
      <url>/2022/07/07/JDBC-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>JDBC (Java DataBase Connectivity) 就是使用Java语言操作数据库的一套API</p></blockquote><span id="more"></span><h1 id="JDBC-快速入门"><a href="#JDBC-快速入门" class="headerlink" title="JDBC 快速入门"></a>JDBC 快速入门</h1><ul><li>创建工程，导入jar包</li><li>注册驱动<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获取连接<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = <span class="module-access"><span class="module"><span class="identifier">DriverManager</span>.</span></span>get<span class="constructor">Connection(<span class="params">url</span>,<span class="params">usename</span>,<span class="params">password</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>定义SQL语句<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql <span class="operator">=</span> <span class="string">&quot;update...&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>获取执行SQL对象<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt conn.createStatement()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>执行SQL<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt.execute<span class="constructor">Update(<span class="params">sql</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>处理返回结果</li><li>释放资源</li></ul><h1 id="API-详解"><a href="#API-详解" class="headerlink" title="API 详解"></a>API 详解</h1><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><ul><li>作用<ul><li>注册驱动<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">-- Driver 类源码</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="type">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>MYSQL 5之后的驱动包，可以省略注册驱动的步骤，会自动加载jar包中META-INF&#x2F;services&#x2F;java.sql.Driver文件中的驱动类</strong></li><li>获取数据库连接<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Connection   <span class="title">getConnection</span><span class="params">(<span class="type">String</span> url,<span class="type">String</span> user,<span class="type">String</span> password)</span></span></span><br></pre></td></tr></table></figure><ul><li>url : 连接路径<blockquote><p>语法：jdba:mysql:&#x2F;&#x2F;ip地址（域名）:端口号&#x2F;数据库名称？参数键值对1&amp;参数键值对2…<br><br>示例:jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;kris<br><br>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称？键值对<br>配置useSSL &#x3D; false 参数，禁用安全连接方式，解决警告提示</p></blockquote></li><li>user ：用户名</li><li>password ：密码</li></ul></li></ul></li></ul><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ul><li>作用<ul><li>获取执行SQL的对象<ul><li>执行普通SQL对象  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Statement</span> <span class="function"><span class="title">createStatement</span>()</span></span><br></pre></td></tr></table></figure></li><li>预编译SQL的执行SQL对象：防治SQL注入  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">PreparedStatement</span> <span class="function"><span class="title">prepareStatement</span>(<span class="variable">sql</span>)</span></span><br></pre></td></tr></table></figure></li><li>执行存储过程的对象  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">CallableStatement</span> <span class="function"><span class="title">prepareCall</span>(<span class="variable">sql</span>)</span></span><br></pre></td></tr></table></figure></li></ul></li><li>管理事务<ul><li>MYSQL 事务管理  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启事务：begin<span class="comment">;</span></span><br><span class="line">提交事务：commit<span class="comment">;</span></span><br><span class="line">回滚事务：rollback<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">MYSQL自动提交事务</span><br></pre></td></tr></table></figure></li><li>JDBC 事务管理  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启事务：<span class="function"><span class="title">setAutoCommit</span>(<span class="variable">boolean</span> <span class="variable">autoCommit</span>):<span class="variable"><span class="literal">true</span></span>为自动提交，<span class="variable"><span class="literal">false</span></span>为手动提交，即为开始事务</span></span><br><span class="line"><span class="function">提交事务：<span class="title">commit</span>()</span></span><br><span class="line">回滚事务：<span class="function"><span class="title">rollback</span>()</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><ul><li>作用<ul><li>执行SQL语句<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> execute<span class="constructor">Update(<span class="params">sql</span>)</span>; <span class="comment">//执行DML DDL语句</span></span><br><span class="line">返回值：<span class="number">1</span> DML语句影响的行数 <span class="number">2</span> DDL语句执行后，执行成功也可能返回<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ResultSet</span> executeQuery(sql): 执行DQL语句</span><br><span class="line">返回值：<span class="keyword">ResultSet</span> 结果集对象</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><ul><li>作用<ul><li>封装了DQL查询语句的结果<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet stmt.execute<span class="constructor">Query(<span class="params">sql</span>)</span>; <span class="comment">//执行DQL语句，返回ResultSet对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li>获取查询结果<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">boolean</span> <span class="keyword">next</span>(): <span class="number">1</span> 将光标从当前位置向前移动一行 <span class="number">2</span> 判断当前行是否为有效行</span><br><span class="line">返回值</span><br><span class="line">  <span class="literal">true</span> ：有效行，当前行有数据</span><br><span class="line">  <span class="literal">false</span> ： 无效行，当前行没有数据</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xxx getXxx(参数)  <span class="comment">//获取数据</span></span><br><span class="line">  xxx 数据类型 如<span class="built_in">int</span> getInt（参数）</span><br><span class="line">  参数  </span><br><span class="line">      <span class="built_in">int</span> 列的编号 从<span class="number">1</span>开始</span><br><span class="line">      <span class="built_in">String</span> 列的名称</span><br></pre></td></tr></table></figure></li></ul><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><ul><li><p>作用</p><ul><li>预编译SQL语句并执行：预防SQL注入问题</li></ul></li><li><p>SQL注入</p><ul><li>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</li></ul></li><li><p>获取 PreparedStatement 对象</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">SQL</span> 语句中的参数值，使用？占位符替代</span><br><span class="line">String <span class="keyword">sql</span> = &quot;select * from username = ? and password = ?&quot;;</span><br><span class="line"></span><br><span class="line">//通过<span class="keyword">Connection</span> 对象获取，并传入对应的<span class="keyword">SQL</span>语句</span><br><span class="line">PreparedStatement pstmt = conn.prepareStatement(<span class="keyword">sql</span>);</span><br></pre></td></tr></table></figure></li><li><p>设置参数值</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement对象：<span class="keyword">set</span>Xxx（参数1，参数2）：给 ？ 赋值</span><br><span class="line">Xxx：数据类型</span><br><span class="line">参数：</span><br><span class="line">  参数1：？的位置编号，从1开始</span><br><span class="line">  参数2：？的值</span><br></pre></td></tr></table></figure></li><li><p>执行SQL</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executeUpdate<span class="comment">()</span>;/executeQuery<span class="comment">()</span>; : 不需要再传递SQL</span><br></pre></td></tr></table></figure></li><li><p>好处</p><ul><li>预编译SQL 性能更高</li><li>防止SQL注入，将敏感字符转义</li></ul></li><li><p>原理</p><ul><li>在获取PreparedStatement对象时，将SQL语句发送给MYSQL服务器进行检查，编译</li><li>执行时就不用再进行这些步骤，速度更快</li><li>如果SQL模板一样，则只需要进行一次检查，编译</li></ul></li></ul><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul><li>数据库连接池是个容器，负责分配，管理数据库连接</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</li><li>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</li><li>好处<ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li></ul><h2 id="数据库连接池实现"><a href="#数据库连接池实现" class="headerlink" title="数据库连接池实现"></a>数据库连接池实现</h2><ul><li>标准接口 ：DataSource<ul><li>官方(SUN)提供的数据库连接池标准接口，由第三方组织实现此接口。</li><li>功能： 获取连接<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Connection</span> <span class="function"><span class="title">getConnection</span>()</span></span><br></pre></td></tr></table></figure></li></ul></li><li>常见的数据库连接池：<ul><li>D8CP</li><li>C3P0</li><li>Druid</li></ul></li><li>Druid(德鲁伊)<ul><li>Druid连接池是阿里巴巴开源的数据库连接池项目</li><li>功能强大，性能优秀，是Java语言最好的数据库连接池之一</li></ul></li></ul><h2 id="Druid-使用步骤"><a href="#Druid-使用步骤" class="headerlink" title="Druid 使用步骤"></a>Druid 使用步骤</h2><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//druid.properties</span><br><span class="line"><span class="attribute">driverClassName</span> <span class="operator">=</span> com.mysql.jdbc.Driver</span><br><span class="line"><span class="attribute">url</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="attribute">username</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="attribute">password</span> <span class="operator">=</span> ...</span><br><span class="line">//初始话连接数量</span><br><span class="line"><span class="attribute">initialSize</span> <span class="operator">=</span> ...</span><br><span class="line">//最大连接数量</span><br><span class="line"><span class="attribute">maxActive</span> <span class="operator">=</span> ...</span><br><span class="line">// 最大等待时间</span><br><span class="line"><span class="attribute">maxWait</span> <span class="operator">=</span> ...</span><br></pre></td></tr></table></figure></li><li>加载配置文件<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>));</span><br></pre></td></tr></table></figure></li><li>获取数据库连接池对象<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = <span class="module-access"><span class="module"><span class="identifier">DruidDataSourceFactory</span>.</span></span>create<span class="constructor">DataSource(<span class="params">prop</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获取连接<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection <span class="operator">=</span> dataSource.getConnection()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL---(3)</title>
      <link href="/2022/07/06/MYSQL-3/"/>
      <url>/2022/07/06/MYSQL-3/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>  SQL（Structured Query Language）,结构化查询语言，一门操作关系型数据库的编程语言，定义操作所有<a href="https://cn.bing.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&qs=SC&pq=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&sk=SC1&sc=8-6&cvid=959A8ABF9CB1416DB320362EC1B3BA5A&FORM=QBRE&sp=2">关系型数据库</a>的统一标准。不同数据库操作的方式可能存在一些不一样的地方</p><span id="more"></span><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>约束是作用于表中列上的规则，用于限制加入表的数据</li><li>约束的存在保证了数据库中数据的正确性，有效性和完整性</li></ul><h2 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h2><table><thead><tr><th>约束名称</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>保证列中数据不能有null值</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证列中所有数据各不相同</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>检查约束</td><td>保证列中的值满足某一条件</td><td>CHECK</td></tr><tr><td>默认约束</td><td>保存数据时，未指定值则采用默认值</td><td>DEFAULT</td></tr><tr><td>外键约束</td><td>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>MYSQL不支持检查约束</li><li>多个约束并排写中间空格</li><li>auto_increment 自增长 (当列是数字并且唯一约束)</li></ul><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3></li><li>添加约束  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加外键约束</span></span><br><span class="line">creat <span class="keyword">table</span> 表名(</span><br><span class="line">列名 数据类型;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key(外键列名) refereinces 主表(主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表后添加外键约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key （外键字段名称） <span class="keyword">references</span> 主表名称（主表列名称）;</span><br></pre></td></tr></table></figure></li><li>删除约束  <figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> 外键名称;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h3><ul><li>先建主表后建从表才能添加外键</li><li>外键名称一般为fk开头链接两关联主表的字段名称</li></ul><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ul><li>根据业务系统的具体需求，结合所选用的DBMS，为这个业务系统构造出最优的数据存储模型。</li><li>建立数据库中的表结构以及表与表之间的关联关系的过程。</li></ul><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><ul><li>需求分析 </li><li>逻辑分析</li><li>物理设计</li><li>维护设计</li></ul><h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h2><ul><li>一对一<ul><li>用户和用户详情</li><li>用于表拆分和提升查询性能</li><li><strong>实现方式</strong>：唯一外键</li></ul></li><li>一对多<ul><li>部门和员工</li><li><strong>实现方式</strong> ： 在多的一方建立外键，指向一的一方的主键</li></ul></li><li>多对多<ul><li>商品和订单</li><li><strong>实现方式</strong> ： 建立第三张中间表，中间表至少包含两个外键，分别对应两方主键</li></ul></li></ul><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><pre><code>相当于查询A B表交集数据</code></pre><ul><li><p>语法</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式内连接</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>，表<span class="number">2.</span>.. <span class="keyword">where</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示外连接</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> [<span class="keyword">inner</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3></li><li><p>语法</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 左外连接</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件;</span><br><span class="line"></span><br><span class="line">-- 右外连接</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure></li><li><p>左外连接</p><blockquote><p>相当于查询A表所有数据和交集部分数据</p></blockquote></li><li><p>右外连接</p><blockquote><p>相当于查询B表所有数据和交集部分数据</p></blockquote><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2></li><li><p>概念</p><blockquote><p>查询中嵌套查询 称为子查询</p></blockquote></li><li><p>根据查询结果不同，作用不同</p><ul><li>单行单列  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表 <span class="keyword">where</span> 字段名 = （子查询）;</span><br></pre></td></tr></table></figure></li><li>多行单列  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表 <span class="keyword">where</span> 字段名 <span class="keyword">in</span> （子查询）;</span><br></pre></td></tr></table></figure></li><li>多行多列 ： 作为虚拟表  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> （子查询） <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>数据库的事务(Transaction) 是一种机制 一个操作序列，包含了一组数据库操作命令</li><li>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败</li><li>事务是一个不可分割的工作逻辑单元</li></ul><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 回滚事务 </span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h2 id="事务的四大特征"><a href="#事务的四大特征" class="headerlink" title="事务的四大特征"></a>事务的四大特征</h2><ul><li>原子性(Atomictity): 事务是不可分割的最小操作单位，要么同时成功，要么同时失败</li><li>一致性(Consistency): 事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性(Isolation): 多个事务之间，操作的可见性</li><li>持久性(Durability): 事务一但提交或回滚，它对数据库中的数据的该表就是永久的</li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL---(2)</title>
      <link href="/2022/07/05/MYSQL-2/"/>
      <url>/2022/07/05/MYSQL-2/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>  SQL（Structured Query Language）,结构化查询语言，一门操作关系型数据库的编程语言，定义操作所有<a href="https://cn.bing.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&qs=SC&pq=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&sk=SC1&sc=8-6&cvid=959A8ABF9CB1416DB320362EC1B3BA5A&FORM=QBRE&sp=2">关系型数据库</a>的统一标准。不同数据库操作的方式可能存在一些不一样的地方</p><span id="more"></span><h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><blockquote><p>Data Query Language 数据查询语言，用于查询数据库中表的数据</p></blockquote><h2 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  字段列表</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  表名列表</span><br><span class="line"><span class="keyword">where</span>      <span class="comment">-- 条件查询 </span></span><br><span class="line">  条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>   <span class="comment">--分组查询</span></span><br><span class="line">  分组字段</span><br><span class="line"><span class="keyword">having</span> </span><br><span class="line">  分组后条件</span><br><span class="line">orded <span class="keyword">by</span>   <span class="comment">--排序查询</span></span><br><span class="line">  排序字段</span><br><span class="line"><span class="keyword">limit</span>      <span class="comment">--分页查询</span></span><br><span class="line">  分页限定</span><br></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><ul><li>去除重复记录<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> distinct <span class="params">...</span> from <span class="params">...</span></span><br></pre></td></tr></table></figure></li><li>起别名<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 <span class="keyword">as</span> （可省略用空格隔开） 别名</span><br></pre></td></tr></table></figure></li></ul><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ul><li><p>语法</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span>条件列表;</span><br></pre></td></tr></table></figure></li><li><p>条件</p><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>between…and…</td><td>在某个范围之间</td></tr><tr><td>in(…)</td><td>多选一</td></tr><tr><td>like 占位符</td><td>模糊查询，_表示任意单个字符，%表示多个任意字符</td></tr><tr><td>is NULL</td><td>是NULL</td></tr><tr><td>is not NULL</td><td>不是NULL</td></tr><tr><td>and</td><td>并且</td></tr><tr><td>or</td><td>或者</td></tr><tr><td>nor</td><td>非</td></tr></tbody></table></li></ul><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><ul><li><p>语法</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 排序字段名<span class="number">1</span> 排序方式<span class="number">1</span>，...;</span><br></pre></td></tr></table></figure></li><li><p>排序方式</p><ul><li>ASC : 升序排列 （默认）</li><li>DESC : 降序排列</li></ul><p><em><strong>如果有多个排序条件，当前边条件值一样时，才根据第二条件进行排序</strong></em></p></li></ul><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ul><li>语法<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 分组前条件限定] <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名 [<span class="keyword">having</span> 分组后条件过滤];</span><br></pre></td></tr></table></figure><strong>分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</strong></li></ul><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><blockquote><p>将一列数据作为一个整体，进行纵向计算</p></blockquote><ul><li><p>分类</p><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>count(列名)</td><td>统计数量(一般选用不为null的列)</td></tr><tr><td>max(列名)</td><td>最大值</td></tr><tr><td>min(列名)</td><td>最小值</td></tr><tr><td>sum(列名)</td><td>求和</td></tr><tr><td>avg(列名)</td><td>平均值</td></tr></tbody></table></li><li><p>语法</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 聚合函数名（列名） <span class="keyword">from</span> 表;</span><br></pre></td></tr></table></figure></li></ul><p><em><strong>null值不参与所有聚合函数运算</strong></em></p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ul><li>语法<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">limit</span> 起始索引，查询条目数;</span><br></pre></td></tr></table></figure><strong>起始索引从0开始</strong><br><strong>计算公式：起始索引 &#x3D; （当前页码-1）* 每页显示的条数</strong></li><li>tips<ul><li>分页查询limit是MYSQL数据库特有</li><li>Oracle 分页查询使用 rownumber</li><li>SQL Sever 使用top</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL---(1)</title>
      <link href="/2022/07/04/MYSQL-1/"/>
      <url>/2022/07/04/MYSQL-1/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>  SQL（Structured Query Language）,结构化查询语言，一门操作关系型数据库的编程语言，定义操作所有<a href="https://cn.bing.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&qs=SC&pq=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&sk=SC1&sc=8-6&cvid=959A8ABF9CB1416DB320362EC1B3BA5A&FORM=QBRE&sp=2">关系型数据库</a>的统一标准。不同数据库操作的方式可能存在一些不一样的地方</p><span id="more"></span><h1 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h1><ul><li><p>SQL语句可以多行或者单行书写，以分号结尾。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">database</span>;   </span><br></pre></td></tr></table></figure></li><li><p>MySQL 数据库的SQL语句不区分大小写，关键字建议大写</p></li><li><p>注释</p><ul><li>单行注释： – 注释内容 或者 #注释内容（MYSQL特有）</li><li>多行注释：&#x2F;* 注释 *&#x2F;</li></ul></li></ul><h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><blockquote><p>Data Definition Language  数据定义语言，用来定义数据库对象；数据库，表，列等</p></blockquote><h2 id="操作库"><a href="#操作库" class="headerlink" title="操作库"></a>操作库</h2><ul><li><p>查询</p>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据库</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>创建数据库（判断，如果不存在则创建）</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>删除数据库</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>查看当前使用的数据库</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">database</span>()</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用数据库</p>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名称<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><ul><li>查询表<ul><li>查询当前数据库下所有表名称  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure></li><li>查询表结构  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名称</span><br></pre></td></tr></table></figure></li></ul></li><li>创建表  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    字段名<span class="number">1</span> 数据类型<span class="number">1</span>，</span><br><span class="line">    字段名<span class="number">2</span> 数据类型<span class="number">2</span>，</span><br><span class="line">    <span class="comment">----</span></span><br><span class="line">    字段名n 数据类型n  <span class="comment">/*最后不加逗号*/</span></span><br><span class="line">)；</span><br></pre></td></tr></table></figure></li><li>删除表  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> 表名称;</span><br></pre></td></tr></table></figure></li><li>修改表<ul><li>修改表名  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">rename</span> <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure></li><li>添加一列  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 数据类型;</span><br></pre></td></tr></table></figure></li><li>修改数据类型  <figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 列名 新数据类型;</span><br></pre></td></tr></table></figure></li><li>修改列名和数据类型  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter <span class="keyword">table</span> 表名 change 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure></li><li>删除列  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><blockquote><p>Data Manipulation Language 数据操作语言，是指在SQL语言中，负责对数据库对象运行数据访问工作的指令集。</p></blockquote><ul><li>添加数据<ul><li>给指定列表添加数据  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">insert</span> into 表名（列名<span class="number">1</span>，列名<span class="number">2</span>，...） values(值<span class="number">1</span>，值<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li>给全部列添加数据  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span> ...);<span class="comment">-- 按照列的顺序添加值;</span></span><br></pre></td></tr></table></figure></li><li>批量添加数据  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">insert</span> into 表名(列<span class="number">1</span>，列<span class="number">2</span>，...) values(值<span class="number">1</span>，值<span class="number">2</span>，...),(值<span class="number">1</span>，值<span class="number">2</span>，...)...;</span><br><span class="line"></span><br><span class="line"><span class="attribute">insert</span> into 表名 values(值<span class="number">1</span>，值<span class="number">2</span>...),(值<span class="number">1</span>，值<span class="number">2</span>...);</span><br></pre></td></tr></table></figure></li></ul></li><li>修改数据  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 <span class="keyword">set</span> 列名<span class="number">1</span> = 值<span class="number">1</span>，列名<span class="number">2</span> = 值<span class="number">2</span>，...[<span class="keyword">where</span> 条件]<span class="punctuation">;</span><span class="comment">(***不加条件，所有数据都会修改！***)</span></span><br></pre></td></tr></table></figure></li><li>删除数据  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]<span class="punctuation">;</span><span class="comment">(***不加则所有数据都会被删除***)</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 注解</title>
      <link href="/2022/05/07/Java-%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/05/07/Java-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是注解-Annotation"><a href="#什么是注解-Annotation" class="headerlink" title="什么是注解(Annotation)"></a>什么是注解(Annotation)</h1><blockquote><p>代码的特殊标识，可以在编译，类加载，运行时被读取，并执行相对应的处理，以便于其他工具补充信息或者进行部署</p></blockquote><span id="more"></span><h1 id="内注解"><a href="#内注解" class="headerlink" title="内注解"></a>内注解</h1><ul><li><p>@Override - 检查该方法是否是重写方法，如果发现其父类，或者是应用的接口中并没有该方法时，会报编译错误</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//将会报编译错误</span></span><br><span class="line">    void say()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Deprecated - 标记过时方法。如果使用该方法，将会报编译警告</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">     son s = <span class="keyword">new</span> <span class="title function_">son</span>();</span><br><span class="line">     <span class="comment">//使用时会显示已废弃 </span></span><br><span class="line">     s.<span class="title function_">say</span>();</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@SuppressWarnings - 指示编译器忽略注解中声明的警告 该注解需要传入参数</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">    deprecation:</span> 使用了不赞成使用的类或方法时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    unchecked:</span> 执行了未检查的转换时的警告，例如当使用了集合时没有用泛型(Generics)来指定集合保存的类型</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    fallthrough:</span> 当switch程序块直接通往下一种情况而没有使用break时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    path:</span> 在类路径 源文件路径等中有不存在的路径时的警告</span><br><span class="line"><span class="symbol">   </span></span><br><span class="line"><span class="symbol">    serial:</span> 当在可序列化的类上缺少serialVersionUID定义时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    finally:</span> 任何finally子句不能正常完成时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    all:</span> 关于以上所有情况的警告</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">// 消除了age没有使用的警告</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">son</span>();</span><br><span class="line">    s.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><blockquote><p>作用在其他注解的注解</p></blockquote><ul><li><p>@Retention - 标识这个注解如何保存，是在代码中，还是编译进class中，或者实在运行时可以通过反射访问</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation</span><br><span class="line"><span class="keyword">public</span> enum RetentionPolicy &#123;</span><br><span class="line">   <span class="comment">//Annotation信息仅存在于编译器处理期间</span></span><br><span class="line">   <span class="comment">//编译器处理完之后就没有该Annotation信息</span></span><br><span class="line">    <span class="keyword">SOURCE</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Annotation信息存储于类对应的class文件之中 (默认)</span></span><br><span class="line">    <span class="keyword">CLASS</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Annotation信息存储于class文件中，并且可由JVM读入</span></span><br><span class="line">    <span class="keyword">RUNTIME</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Documented - 标记这个注解是否包含在用户文档中</p></li><li><p>Target - 标记这个注解一个是哪种java成员</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package java.lang.annotation</span><br><span class="line">public enum ElementType &#123;</span><br><span class="line">      <span class="regexp">//</span>类，接口(包括注释类型) 枚举 </span><br><span class="line">      TYPE,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>字段声明(包括枚举变量)</span><br><span class="line">      FIELD,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>方法声明</span><br><span class="line">      METHOD,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>参数声明</span><br><span class="line">      PARAMETER,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>构造方法声明</span><br><span class="line">      CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>局部变量声明</span><br><span class="line">      LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>注释类型声明</span><br><span class="line">      ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>包声明</span><br><span class="line">      PACKAGE,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>@Inherited - 标记这个注解是继承于哪个注解类(默认注解并没有继承于任何子类)</p></li></ul><h1 id="Annotation的通用定义"><a href="#Annotation的通用定义" class="headerlink" title="Annotation的通用定义"></a>Annotation的通用定义</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Target</span>(ElementType TYPE)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> MyAnnotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@interface 使用@interface 定义注解时，意味着它实现了java.lang.annotation.Annotation 接口，即该注解就是一个Anonotation<br></li><li>定义注解时，@interface 时必须的</li><li>Annotation 接口的实现细节都由编译器完成 通过@interface 定义注解后，该注解不能继承其他注解或接口</li></ul><h1 id="新增接口-java-7-后"><a href="#新增接口-java-7-后" class="headerlink" title="新增接口(java 7 后)"></a>新增接口(java 7 后)</h1><ul><li>SafeVarargs - 忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告</li><li>FunctionalInterface - 标识一个匿名函数或者函数式接口</li><li>Repeatable - 标识某注解可以在同一个声明上使用多次</li></ul><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://www.runoob.com/w3cnote/java-annotation.html">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射</title>
      <link href="/2022/05/04/Java-%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/05/04/Java-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射概述（Reflection）"><a href="#反射概述（Reflection）" class="headerlink" title="反射概述（Reflection）"></a>反射概述（Reflection）</h1><blockquote><p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。</p></blockquote><span id="more"></span><h1 id="反射机制的作用"><a href="#反射机制的作用" class="headerlink" title="反射机制的作用"></a>反射机制的作用</h1><blockquote><ul><li>在运行程序时构造任意一个已知类名称的对象</li><li>在运行时获取或调用类的属性和方法</li><li>生成动态代理</li></ul></blockquote><h2 id="获取类名的三种方式"><a href="#获取类名的三种方式" class="headerlink" title="获取类名的三种方式"></a>获取类名的三种方式</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">package</span> test01;</span><br><span class="line">    <span class="keyword">class</span> test&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">//第一种 通过对象的getClass()方法        Person p1 = new Person();</span></span><br><span class="line">        <span class="keyword">Class</span> c1 = p1.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种 通过类名.class的方式得到，最安全，性能最高，说明每个类都有一个隐藏的静态成员变量class</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">Class</span> c2 = Person.<span class="keyword">class</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种 通过Class对象的forName()静态方法获取，最常用，需要抛出ClassNotFound 异常</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">Class</span> c3 = <span class="keyword">Class</span>.forName(<span class="string">&quot;test01.Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>注意</strong></em>：一个类在JVM中只存在一个Class实例，所以以上c1&#x3D;c2&#x3D;c3</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//共有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    Person()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Person(String name,<span class="built_in">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class中的各种方法"><a href="#Class中的各种方法" class="headerlink" title="Class中的各种方法"></a>Class中的各种方法</h2><p><img src="/../../themes/next/source/images/ClassFunction.png"><br></p><ul><li>getName()：获得类的完整名字。</li><li>getFields()：获得类的public类型的属性。</li><li>getDeclaredFields()：获得类的所有属性。包括private 声明的和继承类</li><li>getMethods()：获得类的public类型的方法。</li><li>getDeclaredMethods()：获得类的所有方法。包括private 声明的和继承类</li><li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。</li><li>getConstructors()：获得类的public类型的构造方法。</li><li>getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。</li><li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</li></ul><h2 id="所获取的方法激活以及属性的修改"><a href="#所获取的方法激活以及属性的修改" class="headerlink" title="所获取的方法激活以及属性的修改"></a>所获取的方法激活以及属性的修改</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Class c1 = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;Person&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">//通过构造方法实例化对象</span></span><br><span class="line">    Person p1 = (Person)(c1.get<span class="constructor">Constructor()</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取方法 第二个参数为形参的类 比如String.class</span></span><br><span class="line">    Method <span class="keyword">method</span> = c1.get<span class="constructor">Method(<span class="string">&quot;say&quot;</span>, <span class="params">null</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数激活，第一个参数为对象，第二个参数为传入的形参</span></span><br><span class="line">    <span class="keyword">method</span>.invoke(p1, null);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//通过构造方法实例化对象</span></span><br><span class="line">    Person p2 = (Person)(c1.get<span class="constructor">Constructor()</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取属性</span></span><br><span class="line">    Field name = c1.get<span class="constructor">DeclaredField(<span class="string">&quot;name&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置是否自检 true为取消访问检查 私有类型的修改不关闭检查则会报错</span></span><br><span class="line">    name.set<span class="constructor">Accessible(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置属性 第一个参数为对象，第二个参数为值</span></span><br><span class="line">    name.set(p2,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h1><pre><code>待续</code></pre><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://www.cnblogs.com/mikechenshare/p/15796381.html">mikechen</a><br><br><a href="https://www.w3cschool.cn/java/java-reflex.html">W3Cschool</a><br><br><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">敬业小码哥</a><br><br><a href="https://www.cnblogs.com/ysocean/p/6516248.html">IT可乐</a><br><br><a href="https://www.bilibili.com/video/BV1p4411P7V3?p=17">狂神说Java(视频)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java I/O</title>
      <link href="/2022/05/02/Java-I-O/"/>
      <url>/2022/05/02/Java-I-O/</url>
      
        <content type="html"><![CDATA[<h1 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h1><p>流：代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象</p><p>流的本质:数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p><p>作用：为数据源和目的地建立一个输送通道</p><span id="more"></span><h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ul><li><p>流向不同 分为输入输出流<br></p><ul><li><p><strong>输出</strong>：把程序(内存)中的内容输出到磁盘、光盘等存储设备中</p></li><li><p><strong>输入</strong>：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中</p></li></ul></li><li><p>处理的数据类型不同 分为字节流和字符流<br></p><ul><li><strong>字节流</strong>： 可以用于读写二进制文件及任意类型文件（如图片 等），读取时一字节为单位（8 bit），同时字节流在操作时不会将数据读取到缓冲区，而是对文件本身进行直接操作，通常情况下采取这种方式</li><li><strong>字符流</strong>： 可以用于读取文本文件。在java中，字符采取Unicode标准，一个字符为16位，所以字符流通常用于处理字符类型的数据，字符流操作时会将数据先读取到缓冲区，只有在流关闭时或者使用flush才能对文件进行操作，一般只在处理纯文本数据时使用。</li></ul></li><li><p>根据功能不同 分为节点流和处理流<br></p><ul><li><strong>节点流</strong>： 可以从或向一个特定的地方(节点)读写数据。如FileInputStream，FileReader，节点流是直接作用在文件上的流，可以理解为一个管道，文件在管道中传输。</li><li><strong>处理流</strong>：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接，处理流是作用在已有的节点流基础上，是包在节点流的外面的管道(可多层)，其目的是让管道内的流可以更快的传输</li></ul></li></ul><h1 id="IO流的五类一接口"><a href="#IO流的五类一接口" class="headerlink" title="IO流的五类一接口"></a>IO流的五类一接口</h1><ul><li>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等</li><li>InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征</li><li>OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征</li><li>Reader（文件格式操作）：抽象类，基于字符的输入操作</li><li>Writer（文件格式操作）：抽象类，基于字符的输出操作</li><li>RandomAccessFile（p随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作</li><li>Serializable： 一个空接口，为对象提供标准的序列化与反序列化操作</li></ul><h1 id="IO流整体框架"><a href="#IO流整体框架" class="headerlink" title="IO流整体框架"></a>IO流整体框架</h1><p><a href="https://img-blog.csdnimg.cn/img_convert/ff708c54547127a831997b01789f07ea.png">javaIO</a><br><br><a href="https://img-blog.csdnimg.cn/img_convert/9092b53635a76155b8189d96e2f866be.png">javaIO</a></p><h1 id="Java-IO流对象介绍"><a href="#Java-IO流对象介绍" class="headerlink" title="Java IO流对象介绍"></a>Java IO流对象介绍</h1><h2 id="字节输入流InputStream"><a href="#字节输入流InputStream" class="headerlink" title="字节输入流InputStream"></a>字节输入流InputStream</h2><ul><li><p>InputStream：字节输入流基类，是所有的字节输入流的父类，它是一个抽象类。</p></li><li><p>FileInputSream：文件输入流。它通常用于对文件进行读取操作。</p></li><li><p>FilterInputStream ：过滤流。作用是为基础流提供一些额外的功能。装饰者模式中处于装饰者，具体的装饰者都要继承它，所以在该类的子类下都是用来装饰别的流的，也就是处理类。</p></li><li><p>BufferedInputStream：缓冲流。对处理流进行装饰，增强，内部会有一个缓存区，用来存放字节，每次都是将缓存区存满然后发送，而不是一个字节或两个字节这样发送。效率更高。</p></li><li><p>DataInputStream：数据输入流。它是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。</p></li><li><p>PushbakInputStream：回退输入流。java中读取数据的方式是顺序读取,如果某个数据不需要读取，需要程序处理。PushBackInputStream就可以将某些不需要的数据回退到缓冲中。</p></li><li><p>ObjectInputStream：对象输入流。用来提供对“基本数据或对象”的持久存储。通俗点讲，也就是能直接传输对象(反序列化中使用)。</p></li><li><p>PipedInputStream：管道字节输入流。它和PipedOutputStream一起使用，能实现多线程间的管道通信。</p></li><li><p>SequenceInputStream:合并输入流。依次将多个源合并成一个源。</p></li><li><p>StringBufferInputStream:字符相关流。已经过时。</p></li><li><p>ByteArrayInputStream：字节数组输入流，该类的功能就是从字节数组(byte[])中进行以字节为单位的读取，也就是将资源文件都以字节的形式存入到该类中的字节数组中去，我们拿也是从这个字节数组中拿。</p></li></ul><h2 id="字节输出流OutputStream"><a href="#字节输出流OutputStream" class="headerlink" title="字节输出流OutputStream"></a>字节输出流OutputStream</h2><ul><li><p>OutputStream：字节输出流基类，是所有的字节输出流的父类，它是一个抽象类。</p></li><li><p>FileOutputStream：文件输出流。该类实现了一个输出流，将数据输出到文件。</p></li><li><p>FilterOutputStream ：过滤流。用来封装其它的输出流，并为它们提供额外的功能(序列化中使用)。它主要包括BufferedOutputStream, DataOutputStream和PrintStream。</p></li><li><p>BufferedOutputStream：缓冲输出流。给输出流提供缓冲功能。</p></li><li><p>DataOutputStream：是用来装饰其它输出流，将DataOutputStream和DataInputStream输入流配合使用，“允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型”。</p></li><li><p>PrintStream：是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p></li><li><p>ObjectOutputStream：对象输出流。该类将实现了序列化的对象序列化后写入指定地方。</p></li><li><p>PipedOutputStream：管道字节输出流。它和PipedInputStream一起使用，能实现多线程间的管道通信，是管道的发送端。</p></li><li><p>ByteArrayOutputStream：字节数组输出流。该类实现了一个输出流，其数据被写入由byte数组充当的缓冲区，缓冲区会随着数据的不断写入而自动增长</p></li></ul><h2 id="字符输入流Reader"><a href="#字符输入流Reader" class="headerlink" title="字符输入流Reader"></a>字符输入流Reader</h2><ul><li><p>Reader：是所有的输入字符流的父类，它是一个抽象类。</p></li><li><p>CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。</p></li><li><p>PipedReader 是从与其它线程共用的管道中读取数据。</p></li><li><p>BufferedReader是一个装饰器，它和其子类LineNumberReader负责装饰其它Reader对象。</p></li><li><p>InputStreamReader：是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。</p></li><li><p>FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader对象进行装饰，会增加一个行号</p></li></ul><h2 id="字符输出流Writer"><a href="#字符输出流Writer" class="headerlink" title="字符输出流Writer"></a>字符输出流Writer</h2><ul><li><p>Writer：是所有的输出字符流的父类，它是一个抽象类。</p></li><li><p>CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据，</p></li><li><p>BufferedWriter 是一个装饰器为Writer 提供缓冲功能。</p></li><li><p>PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。</p></li><li><p>OutputStreamWriter：是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类(具体可以研究一SourceCode)。功能和使用和OutputStream 极其类似。</p></li></ul><h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><p><a href="https://blog.csdn.net/weixin_33602738/article/details/114146995">塔塔君Minkun</a><br><br><a href="https://blog.csdn.net/i6223671/article/details/89041879">Junieson</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的ArrayList</title>
      <link href="/2022/04/15/java%E4%B8%AD%E7%9A%84ArrayList/"/>
      <url>/2022/04/15/java%E4%B8%AD%E7%9A%84ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的ArrayList"><a href="#Java中的ArrayList" class="headerlink" title="Java中的ArrayList"></a>Java中的ArrayList</h1><blockquote><p>ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。<br>ArrayList 继承了 AbstractList ，并实现了 List 接口。</p></blockquote><span id="more"></span><h2 id="引入以及初始化"><a href="#引入以及初始化" class="headerlink" title="引入以及初始化"></a>引入以及初始化</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">ArrayList</span>; <span class="comment">//引入</span></span><br><span class="line">    <span class="built_in">ArrayList</span>&lt;E&gt; objectName = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;&gt;(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">ArrayList</span>&lt;E&gt; objectName = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;&gt;(<span class="type">int</span> initalCapacity); <span class="comment">// 初始化容量</span></span><br><span class="line">    <span class="built_in">ArrayList</span>&lt;E&gt; objectName = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;&gt;(Collection c);</span><br><span class="line">    <span class="comment">//使用集合类的对象进行初始化（set, list,map）等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-ArrayList常用方法"><a href="#Java-ArrayList常用方法" class="headerlink" title="Java  ArrayList常用方法"></a>Java  ArrayList常用方法</h2><ul><li><p>add(int index, E element)<br></p><blockquote><p>将指定元素插入到指定位置,如果无参则默认从末尾插入</p></blockquote><hr></li><li><p>addAll(int index,Collection<E> c)</E></p><blockquote><p>将集合类对象全部插入到指定位置，如果无参则默认从末尾插入</p></blockquote><hr></li><li><p>clear()</p><blockquote><p>清空链表</p></blockquote><hr></li><li><p>clone()</p><blockquote><p>克隆链表 用链表接收返回值</p></blockquote><hr></li><li><p>contains(Object o)</p><blockquote><p>判断链表中是否包含某一元素 返回一个boolean 类型的值</p></blockquote><hr></li><li><p>containsAll(Collection&lt;&gt; o)</p><blockquote><p>判断是否全部包含Collection中的元素</p></blockquote><hr></li><li><p>get(int index)</p><blockquote><p>获得该下标的元素</p></blockquote><hr></li><li><p>indexOf(Object o)</p><blockquote><p>获得在链表中该元素的下标位置</p></blockquote><hr></li><li><p>remove(int index || Object o)</p><blockquote><p>去除链表中该下标位置的元素或与o相同的元素</p></blockquote></li><li><p>subList(int fromIndex,int toIndex)</p><blockquote><p>截取从fromIndex到toIndex的元素 返回值为list</p></blockquote><hr></li><li><p>set(int index,Object element)</p><blockquote><p>替换 arraylist 中指定索引的元素</p></blockquote><hr></li><li><p>sort(Comparator c)</p><blockquote><p>对 arraylist 元素进行排序<br><br>  Comparator 顺序方式 <br><br>  Comparator.naturalOrder() 升序<br>  Comparator.reverseOrder() 降序</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://www.runoob.com/java/java-arraylist.html">菜鸟教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql语句的执行顺序以及流程</title>
      <link href="/2022/04/02/sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/04/02/sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="sql语句的执行顺序以及流程"><a href="#sql语句的执行顺序以及流程" class="headerlink" title="sql语句的执行顺序以及流程"></a>sql语句的执行顺序以及流程</h1><blockquote><p>程序员对sql语句的执行顺序的透彻掌握，是避免编程中各种bug和错误，歧义语句的不二法则。</p></blockquote><span id="more"></span><h1 id="SQL-Select-语句完整的执行顺序："><a href="#SQL-Select-语句完整的执行顺序：" class="headerlink" title="SQL Select 语句完整的执行顺序："></a>SQL Select 语句完整的执行顺序：</h1><p>1、from 子句组装来自不同数据源的数据；<br><br>2、where 子句基于指定的条件对记录行进行筛选； <br><br>3、group by 子句将数据划分为多个分组； <br><br>4、使用聚集函数进行计算； <br><br>5、使用 having 子句筛选分组；<br><br>6、计算所有的表达式；<br>7、select 的字段；<br><br>8、使用 order by 对结果集进行排序。<br></p><p>SQL 语言不同于其他编程语言的最明显特征是处理代码的顺序。 在大多数据库语言中，代码按编码顺序被处理。但在 SQL 语句中，第一个被处理的子句式 FROM，而不是第一出现的 SELECT。</p><h1 id="SQL-查询处理的步骤序号："><a href="#SQL-查询处理的步骤序号：" class="headerlink" title="SQL 查询处理的步骤序号："></a>SQL 查询处理的步骤序号：</h1><p>(1) FROM <left_table> <br><br>(2) <join_type> JOIN <right_table> <br><br>(3) ON <join_condition> <br><br>(4) WHERE <where_condition> <br><br>(5) GROUP BY <group_by_list><br><br>(6) WITH {CUBE | ROLLUP} <br><br>(7) HAVING <having_condition> <br><br>(8) SELECT (9) DISTINCT <br><br>(9) ORDER BY <order_by_list> <br><br>(10) <TOP_specification> <select_list><br></select_list></TOP_specification></order_by_list></having_condition></group_by_list></where_condition></join_condition></right_table></join_type></left_table></p><p>以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者(客户端应 用程序或者外部查询)不可用。只有最后一步生成的表才会会给调用者。如果没有在查询中指定某一个子句， 将跳过相应的步骤。</p><h1 id="逻辑查询处理阶段简介："><a href="#逻辑查询处理阶段简介：" class="headerlink" title="逻辑查询处理阶段简介："></a>逻辑查询处理阶段简介：</h1><p>1、 FROM：对 FROM 子句中的前两个表执行笛卡尔积(交叉联接)，生成虚拟表 VT1。</p><p>2、 ON：对 VT1 应用 ON 筛选器，只有那些使为真才被插入到 TV2。 </p><p>3、 OUTER (JOIN):如果指定了 OUTER JOIN(相对于 CROSS JOIN 或 INNER JOIN)，保留表中未找到 匹配的行将作为外部行添加到 VT2，生成 TV3。如果 FROM 子句包含两个以上的表，则对上一个联接生成的 结果表和下一个表重复执行步骤 1 到步骤 3，直到处理完所有的表位置。</p><p>4、 WHERE：对 TV3 应用 WHERE 筛选器，只有使为 true 的行才插入 TV4。 </p><p>5、 GROUP BY：按 GROUP BY 子句中的列列表对 TV4 中的行进行分组，生成 TV5。 </p><p>6、 CUTE|ROLLUP：把超组插入 VT5，生成 VT6。 </p><p>7、 HAVING：对 VT6 应用 HAVING 筛选器，只有使为 true 的组插入到 VT7。 </p><p>8、 SELECT：处理 SELECT 列表，产生 VT8。 </p><p>9、 DISTINCT：将重复的行从 VT8 中删除，产品 VT9。</p><p>10、 ORDER BY：将 VT9 中的行按 ORDER BY 子句中的列列表顺序，生成一个游标(VC10)。 </p><p>11、 TOP：从 VC10 的开始处选择指定数量或比例的行，生成表 TV11，并返回给调用者。 where 子句中的条件书写顺序</p><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="https://cloud.tencent.com/developer/article/1600323">小马哥</a></p><p>侵权联系删除 email：<a href="mailto:&#50;&#x36;&#x36;&#56;&#x33;&#x38;&#48;&#48;&#x36;&#52;&#x40;&#113;&#113;&#46;&#99;&#111;&#x6d;">&#50;&#x36;&#x36;&#56;&#x33;&#x38;&#48;&#48;&#x36;&#52;&#x40;&#113;&#113;&#46;&#99;&#111;&#x6d;</a></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Morris 中序遍历</title>
      <link href="/2022/04/01/Morris-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2022/04/01/Morris-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote><p>morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，morris遍历可以将非递归遍历中的空间复杂度降为O(1),并且避免了对栈的依赖。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。</p></blockquote><span id="more"></span><h1 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h1><p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 x）：</p><ul><li>如果 x 无左孩子，先将 x 的值加入答案数组，再访问 x 的右孩子，即 x &#x3D; x..right。</li><li>如果 x 有左孩子，则找到 x 左子树上最右的节点（即左子树中序遍历的最后一个节点，x 在中序遍历中的前驱节点），我们记为 predecessor。根据 predecessor 的右孩子是否为空，进行如下操作。</li><li>如果 predecessor 的右孩子为空，则将其右孩子指向 x，然后访问 x 的左孩子，即 x &#x3D; x.left。</li><li>如果 predecessor 的右孩子不为空，则此时其右孩子指向 x，说明我们已经遍历完 x 的左子树，我们将predecessor 的右孩子置空，将 x 的值加入答案数组，然后访问 x 的右孩子，即 x &#x3D; x.right。</li><li>重复上述操作，直至访问完整棵树。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        TreeNode *predecessor = nullptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != nullptr) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (root-&gt;</span>left != nullptr) &#123;</span><br><span class="line">                <span class="comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                <span class="function"><span class="title">predecessor</span> = root-&gt;</span>left;</span><br><span class="line">                <span class="function"><span class="title">while</span> (predecessor-&gt;</span><span class="function"><span class="title">right</span> != nullptr &amp;&amp; predecessor-&gt;</span>right != root) &#123;</span><br><span class="line">                    <span class="function"><span class="title">predecessor</span> = predecessor-&gt;</span>right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="function"><span class="title">if</span> (predecessor-&gt;</span>right == nullptr) &#123;</span><br><span class="line">                    <span class="function"><span class="title">predecessor</span>-&gt;</span>right = root;</span><br><span class="line">                    <span class="function"><span class="title">root</span> = root-&gt;</span>left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="function"><span class="title">res</span>.push_back(root-&gt;</span>val);</span><br><span class="line">                    <span class="function"><span class="title">predecessor</span>-&gt;</span>right = nullptr;</span><br><span class="line">                    <span class="function"><span class="title">root</span> = root-&gt;</span>right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">res</span>.push_back(root-&gt;</span>val);</span><br><span class="line">                <span class="function"><span class="title">root</span> = root-&gt;</span>right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">LeetCode-Solution</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析hexo的原理</title>
      <link href="/2022/03/30/%E6%B5%85%E6%9E%90hexo%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/30/%E6%B5%85%E6%9E%90hexo%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析hexo的原理"><a href="#浅析hexo的原理" class="headerlink" title="浅析hexo的原理"></a>浅析hexo的原理</h1><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><span id="more"></span><h2 id="github的pages服务"><a href="#github的pages服务" class="headerlink" title="github的pages服务"></a>github的pages服务</h2><ul><li><p>github pages 支持静态页面的解析</p></li><li><p>Hexo 用来生成HTML，生成的HTML上传到服务器进行解析</p></li></ul><h2 id="如何用-hexo-生成HTML"><a href="#如何用-hexo-生成HTML" class="headerlink" title="如何用 hexo 生成HTML"></a>如何用 hexo 生成HTML</h2><h3 id="Hexo的工作原理"><a href="#Hexo的工作原理" class="headerlink" title="Hexo的工作原理"></a>Hexo的工作原理</h3><ul><li><p>hexo g : 生成静态文件。将我们的数据和界面相结合生成静态文件的过程。会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 publid 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。</p></li><li><p>hexo d：部署文件。部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 public 文件上传至 github 或者 coding 中。然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 public 文件上传至你自己的服务器上。</p></li></ul><h3 id="hexo的模板引擎"><a href="#hexo的模板引擎" class="headerlink" title="hexo的模板引擎"></a>hexo的模板引擎</h3><ul><li>source 文件夹理解为数据库，而主题文件夹相当于 界面。然后我们 hexo g 就将我们的数据和界面相结合生成静态文件 public。</li></ul><br><ul><li><p>Hexo 的模板引擎是默认使用 ejs 编写的。hexo首先会解析 md 文件，然后根据 layout 判断布局类型，再调用其他的文件，这样每一块的内容都是独立的，提高代码的复用性。最终会生成一个 html 页面。</p></li><li><p>hexo new [layout] &lt;title&gt;就会使用对应的模板。</p><br>其中 _layout.swig 是通用模板，里面引入了 head、footer 等公共组件，然后在其他的模板中会引入这个 _layout.swig 通用模板，比如 post.swig 模板</li></ul><h3 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h3><ul><li>数据填充主要是 hexo -g 的时候将数据传递给swig 模板，然后由swig模板填充到HTML中</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><br>    非要说 Hexo 是什么的话，我觉得就是生成静态页面的工具，可以将我们使用 markdown 编写的内容与主题模板相结合，生成 HTML 静态文件。并且可以和 github 的 pages 或者其他可以将静态页面展现出来的服务（例如 coding 的 pages 服务）相结合，一键部署。<p>再深入一点讲 Hexo 的原理的话，那就应该是使用 yaml 语言 做配置文件，使用 ejs 或者 swig 作为主题模板，与使用 markdown 书写的内容结合，生成静态 HTML 文件。</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><h3 id="如何使用git工具对hexo文章进行版本控制"><a href="#如何使用git工具对hexo文章进行版本控制" class="headerlink" title="如何使用git工具对hexo文章进行版本控制"></a>如何使用git工具对hexo文章进行版本控制</h3><blockquote><p>1.在github或gitee上创建一个私有仓<br><br>2.在hexo文件夹下执行git init <br><br>3.添加远程仓库地址，git remote add github repository_path(github是远程仓库别名，可以另取，repository_path是远程仓库地址)<br><br>4.先拉一下远程仓库的代码，git fetch github<br><br>5.将自己主题的配置复制一份，重命名放到hexo&#x2F;下<br><br>6.填写.gitignore忽略一些不需要进行管理的文件或文件夹，下面是我的配置<br><br>7.将自己的代码提交并push到github上即可<br></p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="meta">    .DS_Store</span></span><br><span class="line">    Thumbs<span class="number">.</span><span class="built_in">db</span></span><br><span class="line">    <span class="built_in">db</span><span class="number">.</span>json</span><br><span class="line">    *.log</span><br><span class="line">    node_modules/</span><br><span class="line">    <span class="meta">public</span>/</span><br><span class="line"><span class="meta">    .deploy</span>*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考  ：<br><br> <a href="https://juejin.cn/post/6844903490930622471">sunshine小小倩</a><br><br> <a href="https://blog.wangx.me/2019/01/12/git-upload-subfolder/">Wangx</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2022/03/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/03/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><strong>正则表达式</strong>：又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</p><span id="more"></span><hr><h2 id="常用字符"><a href="#常用字符" class="headerlink" title="常用字符"></a>常用字符</h2><ul><li><p>\</p><p>  将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</p></li></ul><hr><ul><li><p>^</p><p>  匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</p></li></ul><hr><ul><li><p>$    </p><p>  匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</p></li></ul><hr><ul><li><p>*    </p><p>  匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</p></li></ul><hr><ul><li><p>+</p><p>  匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</p></li></ul><hr><ul><li><p>?</p><p>  匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</p></li></ul><hr><ul><li><p>{n}</p><p>  n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</p></li></ul><hr><ul><li><p>{n,}    </p><p>  n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</p></li></ul><hr><ul><li><p>{n,m}    </p><p>  m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</p></li></ul><hr><ul><li><p>?    </p><p>  当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</p></li></ul><hr><ul><li><p>.    </p><p>  匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.|\n)”的模式。</p></li></ul><hr><ul><li><p>[xyz]    </p><p>  字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</p></li></ul><hr><ul><li><p>[^xyz]</p><p>  负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</p></li></ul><hr><ul><li><p>[a-z]    </p><p>  字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</p></li></ul><hr><ul><li><p>[^a-z]</p><p>  负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</p></li></ul><hr><ul><li><p>\b    </p><p>  匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</p></li></ul><hr><ul><li><p>\B    </p><p>  匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</p></li></ul><hr><ul><li><p>\d</p><p>  匹配一个数字字符。等价于 [0-9]。</p></li></ul><hr><ul><li><p>\D</p><p>  匹配一个非数字字符。等价于 [^0-9]。</p></li></ul><hr><ul><li><p>\r</p><p>  匹配一个回车符。等价于 \x0d 和 \cM。</p></li></ul><hr><ul><li><p>\s</p><p>  匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</p></li></ul><hr><ul><li><p>\S    </p><p>  匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</p></li></ul><hr><ul><li><p>\w    </p><p>  匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</p></li></ul><hr><ul><li><p>\W    </p><p>  匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</p></li></ul><hr><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul><li><p>i</p><p>不区分大小写</p></li><li><p>g</p><p>全局匹配  查找所有的匹配项</p></li><li><p>m</p><p>多行匹配</p></li></ul><br><p>参考   <a href="https://www.runoob.com/regexp/regexp-flags.html">菜鸟教程-正则表达式</a></p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/08/hello-world/"/>
      <url>/2022/03/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
