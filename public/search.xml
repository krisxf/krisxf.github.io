<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2022/10/09/SpringMVC/"/>
      <url>/2022/10/09/SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SpringMVC 是一种基于 Java 的实现 MVC(Model-View-Controller) 设计模型的请求驱动类型的轻量级 Web 框架 </p><span id="more"></span><h1 id="创建SpringMVC对象"><a href="#创建SpringMVC对象" class="headerlink" title="创建SpringMVC对象"></a>创建SpringMVC对象</h1><ul><li><p>声明springmvc核心对象DispatcherServlet</p></li><li><p>需要在tomcat启动后创建DispatcherServlet的实例</p></li><li><p>DispatcherServlet 在创建过程中 会同时创建springmvc对象</p></li><li><p>读取springmvc的配置文件 把这个配置文件中的对象都创建好 当用户发送请求时就可以直接使用对象了</p></li><li><p>处理用户提交的请求  springmvc中使用方法来处理<br>方法是自定义的 可以有多种返回值  多种参数 方法名称自定义</p></li><li><p>servlet的初始化会执行init 方法 </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DispatcherServlet 在init方法中&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建容器对象  读取配置文件</span></span><br><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;springmvc.xml&quot;</span>);</span><br><span class="line"><span class="comment">//把容器中的对象放入到ServletContext中</span></span><br><span class="line">getServletContext().setAttribute(key,cxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="web-xml的配置"><a href="#web-xml的配置" class="headerlink" title="web.xml的配置"></a>web.xml的配置</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      在tomcat启动后 创建servlet对象</span></span><br><span class="line"><span class="comment">      load-on-startup 表示tomcat 启动后创建对象的顺序  值为整数 数值越小</span></span><br><span class="line"><span class="comment">      创建对象越早   是个大于等于0的整数</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--        自定义springmvc的配置文件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--            springmvc的配置文件的位置属性--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--            指定自定义文件的位置--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      使用框架的时候  url-pattern 可以使用两种值</span></span><br><span class="line"><span class="comment">      - 使用扩展名方式  语法  ***.do</span></span><br><span class="line"><span class="comment">      - 使用斜杠 &quot;/&quot;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      当项目中使用了 / 时  它会替代tomcat中的default</span></span><br><span class="line"><span class="comment">       导致所有的静态资源 都给DispatcherServlet 处理  默认情况下  DispatcherServlet 没有处理静态资源的能力</span></span><br><span class="line"><span class="comment">       所以静态资源将无法访问</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="SpringMVC-注解"><a href="#SpringMVC-注解" class="headerlink" title="SpringMVC 注解"></a>SpringMVC 注解</h1><ul><li>@RequestMapping  请求映射  作用是把一个请求地址和一个方法绑定在一起一个请求指定一个方法处理<ul><li>属性<ul><li>value  是一个string  表示请求的url地址（some.do）<br> value 的值必须是一致的  不能重复</li><li>method  表示请求的方式  它的值RequestMethod类枚举值例如表示get请求方式 RequestMethod.Get or  Post</li></ul></li><li>位置<ul><li>在方法的上面   </li><li>在类的上面  所有请求地址的公共部分  叫做模块名称</li></ul></li><li>使用@RequestMapping 修饰的方法叫做处理器方法 该方法可以处理请求 类似doGet doPost</li></ul></li><li>返回值<ul><li>Model  数据  请求处理完成后  要显示给用户的数据</li><li>View  视图   比如jsp等等</li></ul></li></ul><h1 id="SpringMVC-接收参数"><a href="#SpringMVC-接收参数" class="headerlink" title="SpringMVC 接收参数"></a>SpringMVC 接收参数</h1><ul><li><p>逐个接受用户的请求参数</p><ul><li>要求<ul><li>处理器方法的形参名与请求中参数名一致</li><li>同名的参数赋值给同名的形参</li></ul></li></ul></li><li><p>框架接受请求参数</p><ul><li>使用request 对象接受请求参数<blockquote><p>String strName &#x3D; request.getParameter(“name”)</p></blockquote></li><li>框架通过DisoatcherServlet 调用方法  调用方法时按名称对应将接受的参数赋值给形参并进行相应的类型转换</li></ul></li><li><p>请求中参数名称和处理器方法形参不一样时</p><ul><li>使用@RequestParam 给变量起别名<ul><li>属性   <ul><li>value   请求中参数名称(别名)</li><li>required  是一个Boolean  默认是true  表示请求中必须包含此参数</li></ul></li><li>位置<br>在处理器方法的形参定义的前面</li></ul></li></ul></li><li><p>处理器方法是java对象  </p><ul><li>要求这个对象的属性名与请求中参数名一致<br>框架会创建形参的java对象  并调用set方法对属性赋值</li></ul></li></ul><h1 id="SpringMVC-返回值"><a href="#SpringMVC-返回值" class="headerlink" title="SpringMVC 返回值"></a>SpringMVC 返回值</h1><ul><li>处理器方法返回String    表示逻辑视图名称或数据  需要配置视图解析器<ul><li>区分返回值string是不是数据  看有没有@ResponseBody注解 有则是数据 否则是视图</li><li>当charset默认为ISO-8859-1 时  会出现中文乱码  在@RequestMapping中设置   produces &#x3D; “text&#x2F;plain;charset &#x3D; utf-8”</li></ul></li><li>放回值是void 不能表示数据 也不能表示视图<ul><li>在处理ajax的时候  可以使用void返回值  通过HttpServletResponse输出数据  响应ajax请求</li><li>ajax请求服务器返回的就是数据  和视图无关</li></ul></li><li>返回值是Object   返回的对象是数据  和视图无关<br>可以使用对象表示的数据  响应ajax请求<ul><li>实现步骤<ul><li>加入处理json的的工具库依赖 springmvc默认使用的是jackjson</li><li>在spring配置文件之间加入<a href="mvc:annotation-driven">mvc:annotation-driven</a>注解驱动<br>  json &#x3D; om.writeValueString(Object);<br>  注解驱动完成的功能  完成java对象到json xml  text  二进制等数据的转换</li><li>在处理器方法上加入@ResponseBody注解<br>  response.setContextType(“”application&#x2F;json;charset &#x3D; utf-8)<br>  PrintWriter pw &#x3D; response.getWriter();<br>  pw.println(json);</li></ul></li></ul></li></ul><h1 id="SpringMVC-处理静态资源"><a href="#SpringMVC-处理静态资源" class="headerlink" title="SpringMVC 处理静态资源"></a>SpringMVC 处理静态资源</h1><ul><li>第一种处理静态资源的方式<br><ul><li>需要在springmvc的配置文件中加入<a href="mvc:default-servlet-handler">mvc:default-servlet-handler</a></li><li>加入该标签后  框架会创建一个控制器对象DefaultServletHttpRequestHandler （类似自己创建的myController）</li><li>DefaultServletHttpRequestHandler这个对象可以把接收的请求 转发给 tomcat的default这个servlet  实现静态资源的访问</li></ul></li><li>第二种处理静态资源的方式<ul><li>mvc:resource 加入后框架会创建  ResourceHttpServletHandler 这个处理器对象</li><li>让这个对象处理静态资源的访问  不依赖tomcat服务器<ul><li>mapping 访问静态资源的url地址 可以使用通配符 **</li><li>location 静态资源在项目中的位置  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><strong>default-servlet-handler 与 @RequestMapping 有冲突  加上注解驱动解决</strong></p><h1 id="SpringMVC-Forward-and-Redirect"><a href="#SpringMVC-Forward-and-Redirect" class="headerlink" title="SpringMVC Forward and Redirect"></a>SpringMVC Forward and Redirect</h1><ul><li>处理器返回ModelAndView 实现转发forward<ul><li>语法 setViewName（“forward：视图文件的完整路径”）</li><li>forward  特点  不和视图解析器一同使用  就当项目中没有视图解析器</li></ul></li><li>处理器返回ModelAndView 实现转发redirect<ul><li>语法 setViewName（“redirect：视图文件的完整路径”）</li><li>redirect  特点  不和视图解析器一同使用  就当项目中没有视图解析器<br>进行重定向时加入模型的数据会拼接到地址的后面  类似get请求 可以通过获取param来获得数据<h1 id="SpringMVC-配置文件"><a href="#SpringMVC-配置文件" class="headerlink" title="SpringMVC 配置文件"></a>SpringMVC 配置文件</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    声明组件扫描器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kris.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    声明 视图解析器 帮助开发人员设置视图文件的路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        前缀  视图文件的路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        后缀   视图文件的拓展名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="SpringMVC-处理异常"><a href="#SpringMVC-处理异常" class="headerlink" title="SpringMVC 处理异常"></a>SpringMVC 处理异常</h1><ul><li>定义一个全局异常类 加上@ControllerAdvice注解<ul><li>@ControllerAdvice : 控制器增强（也就是说给控制器类增加功能–异常处理功能）<ul><li>位置：在类的上面。</li><li>特点：必须让框架知道这个注解所在的包名，需要在springmvc配置文件声明组件扫描器。<br>指定@ControllerAdvice所在的包名</li></ul></li></ul></li><li>处理异常的方法和控制器方法的定义一样， 可以有多个参数，可以有ModelAndView,<br>String, void,对象类型的返回值<ul><li>形参：Exception，表示Controller中抛出的异常对象。<br>通过形参可以获取发生的异常信息。</li><li>@ExceptionHandler(异常的class)：表示异常的类型，当发生此类型异常时，由当前方法处理</li></ul></li></ul><h1 id="SpringMVC-拦截器"><a href="#SpringMVC-拦截器" class="headerlink" title="SpringMVC 拦截器"></a>SpringMVC 拦截器</h1><ul><li><p>拦截器类需要实现HandlerInterceptor接口 接口中有 preHandle postHandle   afterCompletion 三个方法</p><ul><li><p>preHandle 预处理器对象</p><ul><li>参数<ul><li>Object  handle 被拦截的控制器对象</li></ul></li><li>返回值<ul><li>true  通过拦截器 可以执行控制器方法</li><li>false  无法通过拦截器  请求被拦截</li></ul></li></ul></li><li><p>特点</p><ul><li>方法在控制器方法之前先执行  用户的请求首先到达此方法</li><li>在这个方法中可以获取请求的信息  验证该请求是否符合要求</li><li>可以验证用户是否登录以及用户是否用权限访问某个连接地址</li><li>如果验证失败 可以截断请求 请求不能被处理</li><li>如果验证成功  可以放行请求  此时控制器方法才可以执行</li></ul></li><li><p>postHandle 后处理方法</p><ul><li>参数<ul><li>Object  被拦截的处理器对象</li><li>ModelAndView 处理器方法的返回值</li></ul></li><li>特点</li><li>在处理器方法之后执行的</li><li>能够获取到处理器方法的返回值ModelAndView  可以修改返回的视图和数据  可以影响到最后的执行结果</li><li>主要是对原来的执行结果进行二次修正</li></ul></li><li><p>afterCompletion 最后执行的方法</p><ul><li>参数<ul><li>Object handler 被拦截的处理器对象</li><li>Exception ex  程序中发生的异常</li></ul></li><li>特点<ul><li>在请求处理完成后执行  框架中规定是当你的视图处理完成后 对视图执行了forward 就认为请求处理完成</li><li>一般做资源回收工作的  程序请求过程中创建了一些对象  在这里可以删除  把占用的内存回收</li></ul></li></ul></li></ul></li><li><p>声明拦截器  拦截器可以有0个或多个</p></li><li><p>在框架中保存多个拦截器是ArrayList</p></li><li><p>按照声明的先后顺序放入到list中</p><h2 id="拦截器的声明"><a href="#拦截器的声明" class="headerlink" title="拦截器的声明"></a>拦截器的声明</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        声明第一个拦截器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            指定拦截的url地址</span></span><br><span class="line"><span class="comment">            path 就是url地址  可以使用通配符 **</span></span><br><span class="line"><span class="comment">                ** 表示任意字符  文件或者多级目录和目录下的文件</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            声明拦截器对象--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.handler.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        第二个拦截器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.handler.MyInterceptor2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="SpringMVC处理post请求参数乱码问题"><a href="#SpringMVC处理post请求参数乱码问题" class="headerlink" title="SpringMVC处理post请求参数乱码问题"></a>SpringMVC处理post请求参数乱码问题</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    注册声明过滤器  解决post请求参数乱码问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>character<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>foreResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>character<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树</title>
      <link href="/2022/09/17/HuffmanTree/"/>
      <url>/2022/09/17/HuffmanTree/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近</p><span id="more"></span><h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><p><strong>路径</strong>：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。</p><p><strong>路径长度</strong>：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。</p><p><strong>结点的权</strong>：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。</p><p><strong>结点的带权路径长度</strong>：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 &#x3D; 10 。</p><h1 id="构建哈夫曼树的过程"><a href="#构建哈夫曼树的过程" class="headerlink" title="构建哈夫曼树的过程"></a>构建哈夫曼树的过程</h1><ul><li>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</li><li>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；</li><li>重复 上述步骤 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;             </span><br><span class="line">        <span class="comment">//创建哈夫曼树</span></span><br><span class="line">        <span class="type">HNode</span> <span class="variable">root</span> <span class="operator">=</span> creatHuffmanTree(arr);</span><br><span class="line">        <span class="comment">//遍历哈夫曼树</span></span><br><span class="line">        traversal(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建赫夫曼树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 创建赫夫曼树需要的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回赫夫曼树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HNode <span class="title function_">creatHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//用于存储结点的链表</span></span><br><span class="line">        List&lt;HNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HNode&gt;();</span><br><span class="line">        <span class="comment">//循环数组 将其中的值创建为结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> it : arr) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">HNode</span>(it));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行循环创建哈夫曼树</span></span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//先进行排序</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到最小的结点</span></span><br><span class="line">            <span class="type">HNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//找到次小的结点</span></span><br><span class="line">            <span class="type">HNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建这两个结点的二叉树</span></span><br><span class="line">            <span class="type">HNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HNode</span>(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">//删除已经处理过的结点</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">            <span class="comment">//将其父节点加入链表</span></span><br><span class="line">            list.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回赫夫曼树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(HNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        System.out.println(root.value);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)</span><br><span class="line">            traversal(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)</span><br><span class="line">            traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HNode</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;HNode&gt;&#123;</span><br><span class="line">    <span class="comment">//结点的权</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">//结点的左右子节点</span></span><br><span class="line">    HNode left,right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HNode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(HNode o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.value &gt; o.value)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.value == o.value)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// public boolean equals(Object obj) &#123;</span></span><br><span class="line">    <span class="comment">//     Node node = (Node) obj;</span></span><br><span class="line">    <span class="comment">//     if(this.value == node.value)</span></span><br><span class="line">    <span class="comment">//         return true;</span></span><br><span class="line">    <span class="comment">//     return false;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://c.biancheng.net/view/3398.html">C语言中文网</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2022/09/16/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/09/16/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。</p><span id="more"></span><ul><li><p>堆排序是一种选择排序 它的最坏 最好 平均时间复杂度均为O(nlogn) 是一种不稳定排序</p></li><li><p>堆具有以下性质的完全二叉树 每个结点的值都大于或者等于其左右子节点值<br>称为大顶堆  <strong>没有要求结点的左子节点的值和右子节点的值的大小关系</strong></p></li><li><p>每个结点的值都小于或等于其左右子节点的值 称为小顶堆</p></li></ul><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性 使得每次从无序中选择最大记录(最小记录)变得简单</p><ul><li>将待排序的序列构造成一个最大堆 此时序列的最大值为根节点</li><li>一次将根节点与待排序序列的最后一个元素交换</li><li>再维护从根节点到该元素的前一个结点为最大堆 如此往复 最终得到一个递增序列</li></ul><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素。</li><li>再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys ≤ R[n-1].key</li><li>由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。</li><li>直到无序区只有一个元素为止。</li></ul><p><a href="http://www.rmboot.com/HeapSort.html">快速排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;             </span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr  排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//第一个非叶子结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> (len -<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//对非叶子结点逐个判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            adjustHeap(i,len,arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 进行堆处理的非叶子节点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len  数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> len,<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//非叶子节点的左子节点下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (index &lt;&lt; <span class="number">1</span>) +<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//非叶子节点的右子节点下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左右节点较大值的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果下标超出范围 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; len) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//获取较大数的下标</span></span><br><span class="line">        <span class="keyword">if</span>(right &lt;= len &amp;&amp; arr[right] &gt; arr[left])</span><br><span class="line">            maxIndex = right;</span><br><span class="line">        <span class="comment">//如果子节点的值大于根节点的值</span></span><br><span class="line">        <span class="comment">//将其交换  再检测交换后子树的堆</span></span><br><span class="line">        <span class="keyword">if</span>(arr[maxIndex] &gt; arr[index])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(maxIndex,index,arr);</span><br><span class="line">            adjustHeap(maxIndex, len, arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> maxIndex,<span class="type">int</span> index,<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[maxIndex];</span><br><span class="line">        arr[maxIndex] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/124885051">知乎-developer1024</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2022/08/13/HashTable/"/>
      <url>/2022/08/13/HashTable/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>哈希表也叫散列表，哈希表是一种数据结构，它提供了快速的插入操作和查找操作，无论哈希表总中有多少条数据，插入和查找的时间复杂度都是为O(1)，因为哈希表的查找速度非常快，所以在很多程序中都有使用哈希表，例如拼音检查器</p><span id="more"></span><p>哈希表采用的是一种转换思想，其中一个中要的概念是如何将「键」或者「关键字」转换成数组下标？在哈希表中，这个过程有哈希函数来完成，但是并不是每个「键」或者「关键字」都需要通过哈希函数来将其转换成数组下标，有些「键」或者「关键字」可以直接作为数组的下标。</p><h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><blockquote><p>哈希函数的作用是帮我们把非int的「键」或者「关键字」转化成int，可以用来做数组的下标</p></blockquote><p>哈希函数就是一种<strong>映射</strong>，是从关键字到存储地址的映射。 通常，包含哈希函数的算法的算法复杂度都假设为O(1)，这就是为什么在哈希表中搜索数据的时间复杂度会被认为是”平均为O(1)的复杂度”.</p><ul><li>哈希函数的定义域必须包括需要存储的全部关键码，而如果哈希表允许有m个地址时，其值域必须在0 到m-1之间</li><li>哈希函数计算出来的地址能均匀分布在整个空间中</li><li>哈希函数应该比较简单</li></ul><h2 id="除留余数法（最常用）"><a href="#除留余数法（最常用）" class="headerlink" title="除留余数法（最常用）"></a>除留余数法（最常用）</h2><p>函数：Hash（key）&#x3D;key MOD p （p&lt;&#x3D;m m为表长），求出来的hash(key)就为存储该key的下标</p><p>例如有一下数据{2, 4, 6, 8, 9}<br>表长为10，也就是数组容量为10</p><h2 id="直接定制法（常用）"><a href="#直接定制法（常用）" class="headerlink" title="直接定制法（常用）"></a>直接定制法（常用）</h2><p>取关键字的某个线性函数为散列地址(A、B为常数)：Hash（Key）&#x3D; A*Key + B<br>优点：简单、均匀<br>缺点：需要事先知道关键字的分布情况<br>适用场景：适合查找较小数据范围且连续的情况</p><h2 id="平方取中法（少）"><a href="#平方取中法（少）" class="headerlink" title="平方取中法（少）"></a>平方取中法（少）</h2><p>如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。<br>使用举例<br>比如key&#x3D;1234 1234^2&#x3D;1522756 取227作hash地址<br>比如key&#x3D;4321 4321^2&#x3D;18671041 取671作hash地址<br>适用场景：事先不知道数据并且数据长度较小的情况</p><h1 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h1><p>即不同的key通过同一哈希函数产生了相同的哈希位置，H（key1）&#x3D;H（key2），例如我们在除留余数法中的例子，如果此时插入一个12，其hash(12)为2，此时下标为2的位置已经有元素，此时就会产生哈希冲突</p><h1 id="处理哈希冲突"><a href="#处理哈希冲突" class="headerlink" title="处理哈希冲突"></a>处理哈希冲突</h1><h2 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h2><blockquote><p>从计算的哈希位置开始，往后找到第一个空闲的位置存放数据</p></blockquote><p><strong>待补充</strong></p><h2 id="开散列"><a href="#开散列" class="headerlink" title="开散列"></a>开散列</h2><blockquote><p>开散列方法又叫链地址法，哈希表中存储的是链表的头结点。具有相同的哈希地址会存放在同一链表中，每个链表中的元素都具有相同的哈希地址。</p></blockquote><p><img src="/2022/08/13/HashTable/%E5%BC%80%E6%95%A3%E5%88%97.png" alt="开散列"></p><p>该哈希表示由指针数组来组成的，每个数组中的元素都是一个链表的头指针。从该表中我们可以看出，产生哈希冲突的元素并不会占用其他元素的位置，每个链表中的元素都是哈希冲突的元素</p><ul><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHashTable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个哈希表</span></span><br><span class="line">        <span class="type">HashTab</span> <span class="variable">hashTab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTab</span>();</span><br><span class="line">        <span class="comment">// 创建几个数据</span></span><br><span class="line">        <span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">2</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">3</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">4</span>, <span class="string">&quot;l2&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">5</span>, <span class="string">&quot;l3&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">7</span>, <span class="string">&quot;l3&quot;</span>);</span><br><span class="line">        <span class="comment">// 加入数据</span></span><br><span class="line">        hashTab.add(p1);</span><br><span class="line">        hashTab.add(p2);</span><br><span class="line">        hashTab.add(p3);</span><br><span class="line">        hashTab.add(p4);</span><br><span class="line">        hashTab.add(p5);</span><br><span class="line">        hashTab.add(p6);</span><br><span class="line">        <span class="comment">// 遍历哈希表</span></span><br><span class="line">        hashTab.list();</span><br><span class="line">        <span class="comment">//查找数据</span></span><br><span class="line">        System.out.println(hashTab.search(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//删除数据</span></span><br><span class="line">        hashTab.delete(<span class="number">1</span>);</span><br><span class="line">        hashTab.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 编写哈希表 用于管理链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTab</span> &#123;</span><br><span class="line">    <span class="comment">// 初始容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 存储数据的链表数组</span></span><br><span class="line">    PeoLinkedList[] peoLinkedLists;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 无参构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashTab() &#123;</span><br><span class="line">        peoLinkedLists = <span class="keyword">new</span> <span class="title class_">PeoLinkedList</span>[capacity];</span><br><span class="line">        init(peoLinkedLists);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 有参构造方法 提供初始化容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashTab(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        peoLinkedLists = <span class="keyword">new</span> <span class="title class_">PeoLinkedList</span>[capacity];</span><br><span class="line">        init(peoLinkedLists);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始化链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(PeoLinkedList[] peoLinkedLists)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            peoLinkedLists[i] = <span class="keyword">new</span> <span class="title class_">PeoLinkedList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取存储链表的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getListNo</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(People p)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取存储链表的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getListNo(p.id);</span><br><span class="line">        <span class="comment">// 存储数据</span></span><br><span class="line">        peoLinkedLists[index].add(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 查找对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> People <span class="title function_">search</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取存储链表的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getListNo(id);</span><br><span class="line">        <span class="comment">// 查找数据</span></span><br><span class="line">        <span class="keyword">return</span> peoLinkedLists[index].search(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 删除对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取存储链表的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getListNo(id);</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        peoLinkedLists[index].delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 遍历哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; peoLinkedLists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (peoLinkedLists[i].getHead() == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            peoLinkedLists[i].list();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个类</span></span><br><span class="line"><span class="comment"> * 编写一个链表 往其中添加数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeoLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// 头指针 用于指向第一个数据</span></span><br><span class="line">    <span class="keyword">private</span> People head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用于往链表中添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(People p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">People</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span> (cur.next != <span class="literal">null</span>)</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            cur.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用于遍历该链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(cur.toString());</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> People <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 查找对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> People <span class="title function_">search</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">People</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.id == id)</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 删除对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">            <span class="type">People</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">            cur.next = head;</span><br><span class="line">            <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.next.id == id)</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个自定义类</span></span><br><span class="line"><span class="comment"> * 往哈希表中存储该类信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    People next;</span><br><span class="line">   </span><br><span class="line">    People()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    People(<span class="type">int</span> id, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">&quot; &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashTable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2022/08/12/BinarySearch/"/>
      <url>/2022/08/12/BinarySearch/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>二分查找是一个对<strong>有序列表</strong>进行查找的一个算法</p><span id="more"></span><p>二分查找的实现原理非常简单，首先要有一个有序的列表。但是如果没有，则该怎么办？可以使用排序算法进行排序。</p><p>以升序数列为例，比较一个元素与数列中的中间位置的元素的大小，如果比中间位置的元素大，则继续在后半部分的数列中进行二分查找；如果比中间位置的元素小，则在数列的前半部分进行比较；如果相等，则找到了元素的位置。每次比较的数列长度都会是之前数列的一半，直到找到相等元素的位置或者最终没有找到要找的元素</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li>递归<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">22</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">66</span>,<span class="number">88</span>&#125;;</span><br><span class="line">        <span class="comment">//查找函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> search(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,<span class="number">34</span>);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 二分查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获得中间下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>; <span class="comment">//防止整数型溢出</span></span><br><span class="line">        <span class="comment">//如果找到直接返回下标</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="comment">//如果中间值大于目标值 则左递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            <span class="keyword">return</span>  search(nums, left, mid-<span class="number">1</span>, target);</span><br><span class="line">        <span class="comment">//如果中间值小于目标值 则右递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            <span class="keyword">return</span> search(nums, mid+<span class="number">1</span>, right, target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基数排序</title>
      <link href="/2022/08/12/RadixSort/"/>
      <url>/2022/08/12/RadixSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数</p><span id="more"></span><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>找到最大数的位置 决定了循环几轮</li><li>将数组中的数每轮按照个,十,百等位数放入相应的数组(桶)中</li><li>在将其按顺序取出</li><li>循环结束时便排好了序</li></ul><p><a href="http://www.rmboot.com/RadixSort.html">基数排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基数排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//找到最大的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> findMax(nums);</span><br><span class="line">        <span class="comment">//获得最大数的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建二维数组 作为n个桶</span></span><br><span class="line">        <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用一维数组记录桶中元素的个数</span></span><br><span class="line">        <span class="type">int</span>[] numOfBucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行基数排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,n = <span class="number">1</span>;i &lt; maxLength;i++, n*=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="comment">//逐个获取数字的个位数 并存入桶中</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> nums[j]/n % <span class="number">10</span>;</span><br><span class="line">                bucket[digit][numOfBucket[digit]] = nums[j];</span><br><span class="line">                numOfBucket[digit]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从桶中挨个取出数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; numOfBucket.length;k++)&#123;</span><br><span class="line">                <span class="comment">//如果桶中数据不为0则取出</span></span><br><span class="line">                <span class="keyword">if</span>(numOfBucket[k] != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;l &lt; numOfBucket[k];l++)&#123;</span><br><span class="line">                        nums[index++] = bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                numOfBucket[k] = <span class="number">0</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 找到最大的数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max)</span><br><span class="line">                max = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2022/08/12/QuickSort/"/>
      <url>/2022/08/12/QuickSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法</p><span id="more"></span><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</p></li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">快速排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">//测试数组</span></span><br><span class="line">         <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">         <span class="comment">//排序函数</span></span><br><span class="line">         sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">         <span class="comment">//打印结果</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">             System.out.println(i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 快速排序</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//左下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//右下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="comment">//获取基准值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[(left+right) /<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="comment">//在左边找到一个大于基准值的值</span></span><br><span class="line">            <span class="keyword">while</span>(nums[l] &lt; pivot)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="comment">//在右边找到一个小于基准值的值</span></span><br><span class="line">            <span class="keyword">while</span>(nums[r] &gt; pivot)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="comment">//如果l大于r 则表示基准值左边都小于基准则 右边则都大于</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, l, r);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//避免与基准值相同的值一直交换</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] == pivot)</span><br><span class="line">                r--; </span><br><span class="line">            <span class="keyword">if</span>(nums[r] == pivot)</span><br><span class="line">                l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止栈溢出</span></span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; r)</span><br><span class="line">            sort(nums, left, r);</span><br><span class="line">        <span class="comment">//右递归</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; l)</span><br><span class="line">            sort(nums, l, right);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 交换两个数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        temp = nums[l];</span><br><span class="line">        nums[l] = nums[r];</span><br><span class="line">        nums[r] = temp;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2022/08/11/MergeSort/"/>
      <url>/2022/08/11/MergeSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用</p><span id="more"></span><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）</li><li>自下而上的迭代</li></ul><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p></li><li><p>重复步骤 3 直到某一指针达到序列尾；</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p></li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">归并排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序的辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] aux;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自底向上的归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> [] a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">//分配与数组相等的空间</span></span><br><span class="line">        aux = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">        <span class="comment">// sort(a,0,a.length-1);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> <span class="number">1</span>; sz &lt; N;sz = sz+sz)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>;lo &lt; N - sz;lo += sz+sz)&#123;</span><br><span class="line">                merge(a, lo, lo+sz-<span class="number">1</span>,Math.min(lo+sz+sz-<span class="number">1</span>, N));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 自顶向上的归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// private static void  sort(int[] a,int lo,int hi) &#123;</span></span><br><span class="line">    <span class="comment">//     if(hi &lt;= lo)</span></span><br><span class="line">    <span class="comment">//         return;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int mid = lo + (hi - lo)/2;</span></span><br><span class="line">    <span class="comment">//     //将左边排序</span></span><br><span class="line">    <span class="comment">//     sort(a, lo, mid);</span></span><br><span class="line">    <span class="comment">//     //将右边排序</span></span><br><span class="line">    <span class="comment">//     sort(a, mid+1, hi);</span></span><br><span class="line">    <span class="comment">//     merge(a, lo ,mid,hi);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> lo,<span class="type">int</span> mid,<span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将所有元素复制到辅助数组中 备份数据 在原数组中修改 避免数据丢失</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo;k &lt;= hi;k++)&#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo;k &lt;= hi;k++)&#123;</span><br><span class="line">            <span class="comment">//左边用尽取右边数组</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++];</span><br><span class="line">            <span class="comment">//右边用尽取左边数组</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi)     a[k] = aux[i++];</span><br><span class="line">            <span class="comment">//正常比较 取较小数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aux[j]  &lt; aux[i])   a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2022/08/11/ShellSort/"/>
      <url>/2022/08/11/ShellSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法</p><span id="more"></span><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1</li><li>按增量序列个数 k，对序列进行 k 趟排序</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度</li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">希尔排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellionSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 希尔排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 确定间隔 取3*x+1 分组 </span></span><br><span class="line">        <span class="keyword">while</span>(h &lt; <span class="number">3</span>/N) h = <span class="number">3</span>*h+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当 间隔减为1之前 对每个组进行组内排序</span></span><br><span class="line">        <span class="comment">//在减为1之前 对组内排序的结果是整个数组大致有序</span></span><br><span class="line">        <span class="comment">//最后对整个数组进行插入排序</span></span><br><span class="line">        <span class="comment">//希尔排序的本质是插入排序  插入排序在数组大致有序的情况下拥有最高性能</span></span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h;i &lt; N;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &gt;= h&amp;&amp;nums[j] &lt; nums[j-h];j-=h)&#123;</span><br><span class="line">                    swap(nums, j, j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums , <span class="type">int</span> index_1,<span class="type">int</span> index_2)</span>&#123;</span><br><span class="line">        <span class="comment">//交换值相同时  不交换</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index_1] == nums[index_2])</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index_1];</span><br><span class="line">        nums[index_1] = nums[index_2];</span><br><span class="line">        nums[index_2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2022/08/11/InsertionSort/"/>
      <url>/2022/08/11/InsertionSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p><span id="more"></span><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">插入排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">//测试数组</span></span><br><span class="line">         <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">         <span class="comment">//排序函数</span></span><br><span class="line">         sort(nums);</span><br><span class="line">         <span class="comment">//打印结果</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">             System.out.println(i);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="comment">// 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录要插入的数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从已经排序的序列最右边的开始比较，找到比其小的数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存在比其小的数，插入</span></span><br><span class="line">            <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2022/08/11/SelectionSort/"/>
      <url>/2022/08/11/SelectionSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好</p><span id="more"></span><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li><li>重复第二步，直到所有元素均排序完毕</li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">选择排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//一层循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            <span class="comment">//暂存目前下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[min])</span><br><span class="line">                    <span class="comment">//当前值小于之前的最小值时 更新下标</span></span><br><span class="line">                    min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从头到尾将最小值放置</span></span><br><span class="line">            swap(nums, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums , <span class="type">int</span> index_1,<span class="type">int</span> index_2)</span>&#123;</span><br><span class="line">        <span class="comment">//交换值相同时  不交换</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index_1] == nums[index_2])</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index_1];</span><br><span class="line">        nums[index_1] = nums[index_2];</span><br><span class="line">        nums[index_2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2022/08/11/BubbleSort/"/>
      <url>/2022/08/11/BubbleSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法</p><span id="more"></span><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><p>冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来<br>说并没有什么太大作用。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">冒泡排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//用于测试的数组</span></span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2022/08/11/Recursion/"/>
      <url>/2022/08/11/Recursion/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>递归(Recursion)是一种解决问题的有效方法 在递归过程中 函数将自身作为子例程调用</p></blockquote><span id="more"></span><p>递归的思想是把一个大型复杂问题层层转化为一个与原问题规模更小的问题，问题被拆解成子问题后，递归调用继续进行，直到子问题无需进一步递归就可以解决的地步为止。</p><p><img src="/2022/08/11/Recursion/Recursion.png" alt="Recursion"></p><h1 id="什么时候考虑递归"><a href="#什么时候考虑递归" class="headerlink" title="什么时候考虑递归"></a>什么时候考虑递归</h1><ul><li>当问题和子问题具有递推关系 比如杨辉三角 计算阶乘等</li><li>具有递归性质的数据结构 比如链表 树 图</li><li>反向性问题  比如取反</li></ul><h1 id="递归需要遵守的重要规则"><a href="#递归需要遵守的重要规则" class="headerlink" title="递归需要遵守的重要规则"></a>递归需要遵守的重要规则</h1><ul><li>执行一个方法时 就创建一个新的受保护的独立空间</li><li>方法的局部变量是独立的 不会相互影响</li><li>如果方法中使用的引用类型变量(数组等) 就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近 否则就是无限递归</li><li>当一个方法执行完毕 或者遇到return 就会返回 遵守谁调用 就将结果返回给谁 同时当方法执行完毕或者返回时 该方法也就执行完毕</li></ul><h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h1><blockquote><p>尾递归函数是递归函数的一种，其中递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用</p></blockquote><p>尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。可以理解为，在程序执行到递归函数最后一条递归调用指令时回收了当前的栈空间（其实是复用了当前的栈空间）</p><h1 id="采用递归解法的几个经典问题"><a href="#采用递归解法的几个经典问题" class="headerlink" title="采用递归解法的几个经典问题"></a>采用递归解法的几个经典问题</h1><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">factorial</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(fact(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n * fact(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="斐波纳契数"><a href="#斐波纳契数" class="headerlink" title="斐波纳契数"></a>斐波纳契数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(fib(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EightQueen</span> &#123;</span><br><span class="line">    <span class="comment">//定义皇后的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">QUEEN_NUM</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//定义一个数组 保存皇后放置位置的结果</span></span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[QUEEN_NUM];</span><br><span class="line">    <span class="comment">//总解法数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EightQueen</span> <span class="variable">eightQueen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EightQueen</span>();</span><br><span class="line">        <span class="comment">//从第一行开始放置</span></span><br><span class="line">        eightQueen.place(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//打印总解法数</span></span><br><span class="line">        System.out.println(eightQueen.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将皇后的位置输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//只有得到解时才会打印 所以count可以++</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : array)</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 查看我们放置第n个皇后 就去检测该皇后是否与前面已经摆放好了的皇后冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="comment">//判断竖直方向和斜向</span></span><br><span class="line">        <span class="keyword">if</span>(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 放置第n个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">place</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == QUEEN_NUM)&#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次放入皇后 并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; QUEEN_NUM;i++)&#123;</span><br><span class="line">            <span class="comment">//从第一列开始</span></span><br><span class="line">            array[n] = i;</span><br><span class="line">            <span class="comment">//判断是否冲突</span></span><br><span class="line">            <span class="keyword">if</span>(judge(n))&#123;</span><br><span class="line">                <span class="comment">//不冲突 放置下一个</span></span><br><span class="line">                place(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//冲突则i++ 将皇后放置到下一列再次判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2022/08/06/Stack/"/>
      <url>/2022/08/06/Stack/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>栈（stack）又名堆栈，是一个先入后出(FIFO-First In Last Out)的有序列表</p><span id="more"></span><ul><li>栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表 允许插入和删除的一端 为变化的一段 称为栈顶(Top) 另一端为固定的一段 称为栈底(Bottom)</li><li>最先放入栈中的元素在栈底 最后放入的元素在栈顶 而删除元素刚好相反 最后放入的元素最先删除 最先放入的元素最后删除</li></ul><p><img src="/2022/08/06/Stack/Stack.png" alt="Stack"></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>子程序的调用 在跳往子程序前 会将下一个指令的地址存到堆栈中 直到子程序执行完后再将地址取出 以回到原来的程序中</li><li>表达式的转换(中缀表达式转后缀表达式)与求值</li><li>双叉树的遍历</li><li>图形的深度优先搜索</li></ul><h1 id="使用数组实现栈"><a href="#使用数组实现栈" class="headerlink" title="使用数组实现栈"></a>使用数组实现栈</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">//指向栈顶</span></span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="comment">//用于存储数据的数组</span></span><br><span class="line">    <span class="type">int</span> arr[];</span><br><span class="line">    <span class="comment">//初始化容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">INIT_CAPACITY</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//记录数量</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 无参构造方法</span></span><br><span class="line"><span class="comment">     * 初始化变量</span></span><br><span class="line"><span class="comment">     * 将数组初始容量设为6 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MyStack()&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        top = -<span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[INIT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当前栈中元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> item)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())</span><br><span class="line">            addCapaty();</span><br><span class="line">        arr[++top] = item;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断栈满</span></span><br><span class="line"><span class="comment">     * 将其私有化</span></span><br><span class="line"><span class="comment">     * 仅用于内部判断其是否等于当前最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= INIT_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始容量不够时重新分配空间</span></span><br><span class="line"><span class="comment">     * 将原来的数组复制过来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCapaty</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;EMPTY!!!&quot;</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> arr[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 返回栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 测试方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyStack</span> <span class="variable">myStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStack</span>();</span><br><span class="line">        myStack.push(<span class="number">1</span>);</span><br><span class="line">        myStack.push(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回栈元素数量测试</span></span><br><span class="line">        System.out.println(myStack.capacity());</span><br><span class="line"></span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//返回栈顶元素测试</span></span><br><span class="line">        myStack.push(<span class="number">1</span>);</span><br><span class="line">        System.out.println(myStack.peek());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//栈空出栈测试</span></span><br><span class="line">        System.out.println(myStack.pop()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dijkstra-的双栈算术表达式求值算法"><a href="#Dijkstra-的双栈算术表达式求值算法" class="headerlink" title="Dijkstra 的双栈算术表达式求值算法"></a>Dijkstra 的双栈算术表达式求值算法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Dijkstra 的双栈算术表达式求值算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraDoubleStack</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;(1+((2+3)*(4*5)))&quot;</span>;</span><br><span class="line">        <span class="comment">//存储符号</span></span><br><span class="line">        Stack&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储数字与结果</span></span><br><span class="line">        Stack&lt;Double&gt; vals = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//如果是左括号 跳过</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="comment">//将符号压入栈中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;+&#x27;</span>) </span><br><span class="line">                ops.push(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                ops.push(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                ops.push(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                ops.push(s.charAt(i));</span><br><span class="line">            <span class="comment">//遇到右括号时将所需要的两个数弹出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//弹出符号 判断进行哪个运算</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> ops.pop();</span><br><span class="line">                <span class="type">double</span> <span class="variable">v</span> <span class="operator">=</span> vals.pop();</span><br><span class="line">                <span class="keyword">if</span>(ch == <span class="string">&#x27;+&#x27;</span>) v = vals.pop()+v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) v = vals.pop()-v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;*&#x27;</span>) v = vals.pop()*v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;/&#x27;</span>) v = vals.pop()/v;</span><br><span class="line">                <span class="comment">//计算好结果后将结果压入vals栈中</span></span><br><span class="line">                vals.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">//不是上述情况则是数字 将其压入vals栈中</span></span><br><span class="line">                vals.push(Double.parseDouble(s.charAt(i)+<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后剩下的就是结果</span></span><br><span class="line">        System.out.println(vals.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无括号的表达式则比较运算符的优先级</li><li>如果当前的操作符的优先级小于等于栈中的操作符</li><li>就pop出两个数和一个符号进行运算 否则直接入栈</li></ul><h1 id="前缀-中缀-后缀表达式"><a href="#前缀-中缀-后缀表达式" class="headerlink" title="前缀 中缀 后缀表达式"></a>前缀 中缀 后缀表达式</h1><h2 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h2><ul><li>前缀表达式又称波兰式 前缀表达式的运算符位于操作数之前</li><li>举例<ul><li>(3+4) x 5 - 6 对应的前缀表达式是- x + 3 4 5 6</li></ul></li><li>计算机求值时从右至左扫描表达式 遇到数字时 将数字压入栈中</li><li>遇到运算符时弹出栈顶的两个数 进行计算 并将结果入栈</li><li>重复以上操作</li></ul><h2 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h2><ul><li>中缀表达式就是常见的运算表达式 </li><li>举例 <ul><li>(3+4)x5-6</li></ul></li><li>中缀表达式的求值是人最熟悉的 但是对计算机来说缺不好操作因此在计算时往往会将其转成其他表达式来操作(一般转成后缀表达式)</li></ul><h2 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h2><ul><li>后缀表达式又称逆波兰表达式 与前缀表达式相似 知识运算符位于操作数之后</li><li>举例<ul><li>(3+4)x5-6 对应的后缀表达式是 34+5 x 6-</li></ul></li><li>计算机求值时 从左至右扫描表达式 遇到数字时 将数字压入堆栈 遇到运算符时 弹出栈顶的两个数 用运算符对他们进行相应的计算 将结果压入栈中 重复以上操作</li></ul><h2 id="中缀表达式转换成后缀表达式"><a href="#中缀表达式转换成后缀表达式" class="headerlink" title="中缀表达式转换成后缀表达式"></a>中缀表达式转换成后缀表达式</h2><ul><li>初始化两个栈 运算符栈s1和存储中间结果的栈s2</li><li>从左至右扫描中缀表达式</li><li>遇到操作数时 将其压入s2</li><li>遇到运算符时 比较其与s1 栈顶运算符的优先级<ul><li>如果s1为空 或栈顶运算符为左括号 则将其直接压入s1</li><li>否则 若优先级比栈顶运算符的高 也将运算符压入s1</li><li>否则 将s1栈顶的运算符弹出并压入s2中</li></ul></li><li>如果遇到括号<ul><li>如果是左括号 直接压入s1</li><li>如果是右括号 则依次弹出s1栈顶的运算符 并压入s2 直到遇到左括号为止 此时将这一对括号丢弃</li></ul></li><li>重复2~5 直到表达式的最右边</li><li>将s1中剩余的运算符依次弹出并压入s2</li><li>依次弹出s2中的元素并输出 结果的逆序即为中缀表达式对应的后缀表达式</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poland</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 给定中缀表达式 即正常的表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;1+((2+3)*4)-5&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转成后缀表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">subffixExpression</span> <span class="operator">=</span>  convert(expression);</span><br><span class="line"></span><br><span class="line">        System.out.println(subffixExpression);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 中缀表达书转换成后缀表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">convert</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 数字栈 由于全程没有出栈操作 且最后需要反转 可以用List</span></span><br><span class="line">        ArrayList&lt;String&gt; number = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 符号栈</span></span><br><span class="line">        Stack&lt;String&gt; signal = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 用于拼接数字的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">numberStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 用于遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历该中缀表达式</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            numberStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//如果第一个是数字</span></span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//获得该数字的字符串</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; str.length()&amp;&amp;str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    numberStr += str.charAt(i);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将其加入数组</span></span><br><span class="line">                <span class="keyword">if</span> (numberStr != <span class="string">&quot;&quot;</span>)</span><br><span class="line">                    number.add(numberStr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//是符号时 如果符号栈空 或者是左括号时 直接入符号栈</span></span><br><span class="line">                <span class="keyword">if</span>(signal.isEmpty())</span><br><span class="line">                    signal.push(str.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    signal.push(str.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果是右括号时 在遇到左括号之前将符号栈的弹出加入数组</span></span><br><span class="line">                    <span class="keyword">while</span>(!signal.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                        number.add(signal.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将括号去掉</span></span><br><span class="line">                    signal.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//当运算符的优先级更小时将符号栈弹出加入到数组</span></span><br><span class="line">                    <span class="keyword">while</span>(!signal.empty() &amp;&amp; Operation.getValue(signal.peek()) &gt;= Operation.getValue(str.charAt(i)+<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                        number.add(signal.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//再把运算符压入符号栈</span></span><br><span class="line">                    signal.push(str.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; str.length());</span><br><span class="line">        <span class="comment">//遍历完之后如果符号栈还有残留</span></span><br><span class="line">        <span class="comment">//全部弹出加入数组</span></span><br><span class="line">        <span class="keyword">while</span>(!signal.empty())</span><br><span class="line">            number.add(signal.pop());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> number.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 编写一个类 Operation  可以返回一个运算符 对应的优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SUB</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MUL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DIV</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(String operation)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(operation)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LeetCode-相关题目"><a href="#LeetCode-相关题目" class="headerlink" title="LeetCode 相关题目"></a>LeetCode 相关题目</h1><ul><li>Easy<br><a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a><br><br><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列</a><br><br><a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素</a><br><br><a href="https://leetcode.cn/problems/min-stack/">最小栈</a><br></li><li>Medium</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2022/08/03/Queue/"/>
      <url>/2022/08/03/Queue/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>队列(Queue) 是一种采用先进先出(FIFO)策略的抽象数据结构</p><span id="more"></span><ul><li>队列是一个有序列表 可以用数组或是链表来实现</li><li>遵循先入先出的原则 即:先存入队列的数据 要先取出 后存入的要后取出</li><li>通常队列使用链表来进行实现 这样不会有大小的限制</li><li>使用数组实现时可以对下标取余达到对前面出队以后空出的数组空间进行重复利用的效果</li></ul><p><img src="/2022/08/03/Queue/Queue.png" alt="Queue"></p><h1 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a>数组实现队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="comment">//初始化容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="comment">//头指针 用于输出数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">//尾指针 记录末尾数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">//用于实现的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> arr[];</span><br><span class="line">    <span class="comment">//记录存储数据大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> maxSize)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往队列中添加数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">int</span> item)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())</span><br><span class="line">            <span class="comment">//可以抛出异常 直接返回会导致多余的数据忽略</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//添加时的数组下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (++rear) % maxSize;</span><br><span class="line">        arr[index] = item;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队头的数据弹出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        count--; </span><br><span class="line">        <span class="comment">//出队时的数组下标</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (++front) % maxSize;</span><br><span class="line">         <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayQueue</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//将数据加满</span></span><br><span class="line">        arrayQueue.enqueue(<span class="number">1</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">2</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">3</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">4</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//判断isFull函数是否有用</span></span><br><span class="line">        System.out.println(arrayQueue.isFull());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//全部出队 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(arrayQueue.dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断isEmpty函数是否可用</span></span><br><span class="line">        System.out.println(arrayQueue.isEmpty());</span><br><span class="line">        <span class="comment">//再次入队 判断其循环可用性</span></span><br><span class="line">        arrayQueue.enqueue(<span class="number">6</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">7</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue</span>&lt;Item&gt;&#123;</span><br><span class="line">    <span class="comment">//指向最早添加的结点</span></span><br><span class="line">    <span class="keyword">private</span> Node  first;</span><br><span class="line">    <span class="comment">//指向最近添加的结点</span></span><br><span class="line">    <span class="keyword">private</span> Node  last;</span><br><span class="line">    <span class="comment">//队列中的元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="comment">//定义了结点的嵌套类</span></span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">//表尾添加元素</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldlast</span> <span class="operator">=</span> last;</span><br><span class="line">        last = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        last.item = item;</span><br><span class="line">        last.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) first = last;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            oldlast.next = last;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//表头删除元素</span></span><br><span class="line">        <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> first.item;</span><br><span class="line">        first = first.next;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) last = <span class="literal">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组</title>
      <link href="/2022/08/02/spraseArray/"/>
      <url>/2022/08/02/spraseArray/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当一个数组中大部分元素为同一个值时 可以使用稀疏数组来保存该数组</p><span id="more"></span><ul><li>稀疏数组的处理方法<ul><li>记录数组一共有几行几列 有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中 从而缩小程序的规模</li></ul></li></ul><p><img src="/2022/08/02/spraseArray/spraseArray.png" alt="spraseArray"></p><ul><li>第一行 保存整个数组的信息 <ul><li>row 有多少行</li><li>col 有多少列</li><li>val 有多少个有效值</li></ul></li><li>其余行分别存储其他有效数的位置<ul><li>row 所在行</li><li>col 所在列</li><li>val 有效值</li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">spraseArray</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个原始数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ROW</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">COL</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[ROW][COL];</span><br><span class="line">        <span class="comment">//设置有效值</span></span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">        arr[<span class="number">6</span>][<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">6</span>] = <span class="number">5</span>;</span><br><span class="line">        arr[<span class="number">5</span>][<span class="number">2</span>] = <span class="number">9</span>;</span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">7</span>;</span><br><span class="line">        arr[<span class="number">6</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//输出原始的二维数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] row : arr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> item : row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,item);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组 获取数组中的有效值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//有效值个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ROW;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; COL;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建稀疏数组</span></span><br><span class="line">        <span class="type">int</span> spraseArray[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">        spraseArray[<span class="number">0</span>][<span class="number">0</span>] = ROW;</span><br><span class="line">        spraseArray[<span class="number">0</span>][<span class="number">1</span>] = COL;</span><br><span class="line">        spraseArray[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存取有效值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 用于递增存值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ROW;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; COL;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    spraseArray[count][<span class="number">0</span>] = i;</span><br><span class="line">                    spraseArray[count][<span class="number">1</span>] = j;</span><br><span class="line">                    spraseArray[count][<span class="number">2</span>] = arr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印稀疏数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] row : spraseArray)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> item : row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,item);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将稀疏数组恢复成二维数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取行和列</span></span><br><span class="line">        ROW = spraseArray[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        COL = spraseArray[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//new 一个新的数组</span></span><br><span class="line">        <span class="type">int</span> arr2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[ROW][COL];</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; spraseArray.length;i++)&#123;</span><br><span class="line">            arr2[spraseArray[i][<span class="number">0</span>]][spraseArray[i][<span class="number">1</span>]] = spraseArray[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] row : arr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> item : row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,item);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2022/07/27/Spring-1/"/>
      <url>/2022/07/27/Spring-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring使Java编程对每个人来说都更快，更轻松，更安全。Spring对速度，简单性和生产力的关注使其成为全球最受欢迎的Java框架<br><a href="https://spring.io/">官网</a></p><span id="more"></span><h1 id="Spring-Framework-系统架构"><a href="#Spring-Framework-系统架构" class="headerlink" title="Spring Framework 系统架构"></a>Spring Framework 系统架构</h1><blockquote><p>Spring Framework 是Spring生态圈中最基础的项目 是其他项目的根基</p></blockquote><p><img src="/2022/07/27/Spring-1/SpringFramework%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Spring Framework系统架构图"></p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><blockquote><p>Inversion of Control  控制反转</p></blockquote><ul><li><p>使用对象时，由主动new产生对象转换为由外部提供对象，对象的创建控制权由程序转移到外部 这种思想称为控制反转</p></li><li><p>Spring 技术对Ioc思想进行了实现</p><ul><li>Spring提供了一个容器 称为IoC容器 用来充当IoC思想中的外部</li><li>IoC容器负责对象的创建 初始化等一系列工作 被创建或被管理的对象在IoC中统称Bean<!-- IoC是如何返回用户所需要的对象的呢？ --></li></ul></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>导入spring的坐标spring-context </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Spring配置文件 </p><ul><li>在resources下new一个applicationContext.xml文件</li></ul></li><li><p>配置bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    告诉spring创建对象</span></span><br><span class="line"><span class="comment">    声明bean</span></span><br><span class="line"><span class="comment">    id  对象的自定义名称 唯一值  spring通过这个名称找到对象</span></span><br><span class="line"><span class="comment">    class 类的全限定名称 不能是接口 因为要通过反射机制创建对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    spring 把创建好的对象放入map中 spring框架中有一个map存放对象</span></span><br><span class="line"><span class="comment">    key值是id</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    一个bean标签声明一个对象 </span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    对于非自定义的类 spring也能创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置service与 dao的关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">    name属性表示配置哪一个具体的属性</span></span><br><span class="line"><span class="comment">    ref属性表示参照哪一个bean--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>获取IoC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>获取bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Obejct</span> <span class="variable">o</span> <span class="operator">=</span> (Object)ctx.getBean(id)</span><br></pre></td></tr></table></figure></li></ul><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><blockquote><p>Dependency Injection  依赖注入</p></blockquote><ul><li>在容器中建立bean与bean之间的依赖关系的整个过程 称为依赖注入</li></ul><h3 id="set注入"><a href="#set注入" class="headerlink" title="set注入"></a>set注入</h3><h4 id="简单类型的set注入"><a href="#简单类型的set注入" class="headerlink" title="简单类型的set注入"></a>简单类型的set注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;xx&quot;</span> <span class="attr">class</span> = <span class="string">&quot;yy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;属性名字&quot;</span>  <span class="attr">value</span> = <span class="string">&quot;此属性的值&quot;</span>/&gt;</span></span><br><span class="line">        一个property只能给一个属性赋值</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义类型的set注入"><a href="#自定义类型的set注入" class="headerlink" title="自定义类型的set注入"></a>自定义类型的set注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">class</span>=<span class="string">&quot;yyy&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;属性名称&quot;</span> <span class="attr">ref</span> = <span class="string">“bean的id”/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><ul><li><p>构造注入 spring调用有参数构造方法  在创建对象的同时  在构造方法中给属性赋值</p></li><li><p>构造注入使用  <constructor-arg> 标签</constructor-arg></p></li><li><p>标签属性</p><ul><li>name 表示构造方法的形参名</li><li>index 表示构造方法的参数的位置 参数从左往右位置是0.1.2的顺序</li><li>value 构造方法的形参类型是简单类型 使用value</li><li>ref  构造方法的形参类型是引用类型 使用ref<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.pa_03.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;myName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;myAge&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;mySchool&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--   使用index标志--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.pa_03.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    声明school对象--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mySchool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.pa_03.School&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;beijingdaxue&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h3></li></ul></li><li><p>引用类型的自动注入  spring框架根据某些规则可以给引用类型给引用类型赋值</p></li><li><p>使用的规则常用是 byName  byType</p></li><li><p>byName  </p><ul><li>java类中引用类型的属性名和spring容器中<bean> 的id名称一样<br>且数据类型是一致的 这样的容器中的bean spring能够赋值给引用类型</bean></li></ul></li><li><p>语法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span> id = &quot;xx&quot; class = &quot;yyy&quot; autowire = &quot;byName&quot;&gt;</span><br><span class="line">  简单类型属性赋值</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>byType  </p><ul><li>java类中引用类型的数据类型和spring容器中 <bean>的class属性<br>是同源关系的 这样的bean能够赋值给引用类型<br>在byType中 声明bean只能右一个符合条件的</bean></li></ul></li><li><p>同源就是一类的意思</p><ul><li>java中引用类型的数据类型和bean的class的值是一样的</li><li>java类中引用类型的数据类型和bean的class的值是父子类型的</li><li>java类中引用类型的数据类型和bean的class的值是接口和实现类的关系的</li></ul></li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><blockquote><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方<br>式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个<br>热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑<br>的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高<br>了开发的效率。</p></blockquote><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</li><li>Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</li><li>Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</li><li>Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</li><li>Target（目标对象）：织入 Advice 的目标对象.。</li><li>Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</li></ul><h3 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/<span class="strong">**</span></span><br><span class="line"><span class="strong">  <span class="emphasis">* 定义方法  方法是实现切面功能的</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">  *</span> 方法的定义要求</span></span><br><span class="line"><span class="strong">  <span class="emphasis">*      公共方法  public</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">  *</span>      方法没有返回值</span></span><br><span class="line"><span class="strong">  <span class="emphasis">*      方法名称自定义</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">  *</span>      方法可以有参数 也可以没有</span></span><br><span class="line"><span class="strong">  <span class="emphasis">*          如果有 参数不是自定义的  有几个参数可以使用</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">  *</span>/</span></span><br><span class="line"><span class="strong">/**</span></span><br><span class="line"><span class="bullet">  *</span> execution(&lt;修饰符模式&gt;?&lt;返回类型模式&gt;&lt;方法名模式&gt;(&lt;参数模式&gt;)&lt;异常模式&gt;?)</span><br><span class="line"><span class="bullet">  *</span> https://blog.csdn.net/zhuanglicheng/article/details/109110176</span><br><span class="line">  <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis">/<span class="strong">**</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">  <span class="emphasis">* 指定通知方法中的参数 JoinPoint</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  *</span> JoinPoint  业务方法 要加入切面功能的业务方法</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">  <span class="emphasis">*      作用   可以在通知方法中获取方法执行时的信息  例如方法名称  方法的实参</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  *</span>      如果你的切面功能中需要用到方法的信息 就加入JointPoint</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">  <span class="emphasis">*      这个JoinPoint参数的值是由框架赋予  必须是第一个位置的参数</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  *</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis">  <span class="emphasis">*/</span></span></span></span><br></pre></td></tr></table></figure><ul><li><p>@Aspect  是aspectj框架中的注解</p><ul><li>作用  表示当前类是切面类</li><li>切面类  是用来给业务方法增加功能的类  在这个类中有切面的功能代码</li><li>位置  在类定义的上面</li></ul></li><li><p>@Before 前置通知注解</p><ul><li>属性 value 是切入点表达式 表示切面的功能执行的位置</li><li>位置 在方法上面</li><li>特点<ul><li>在目标方法之前先执行的</li><li>不会改变目标方法的执行结果</li><li>不会影响目标方法的执行</li></ul></li></ul></li><li><p>@AfterReturning 后置通知 方法有参数  推荐Object  参数名自定义</p><ul><li>属性 <ul><li>value 切入点表达式</li><li>returning 自定义的变量  表示目标方法的返回值的 自定义变量名必须和通知方法的形参名一样</li></ul></li><li>位置   方法的上面</li><li>特点<ul><li>在目标方法之后执行的</li><li>能够获取到目标方法的返回值 可以根据这个返回值做不同的处理功能</li><li>可以修改这个返回值  只有当传递的是引用的参数是才会改变  值传递不会改变原有的参数</li></ul></li></ul></li><li><p>@Around 环绕通知 方法必须有一个返回值  推荐使用Object 方法有参数  固定的参数 ProceedingJoinPoint</p><ul><li>属性 value  切入点表达式</li><li>位置 在方法的定义上面</li><li>特点<ul><li>是功能最强的通知</li><li>在目标方法的前和后都能增强功能</li><li>控制目标方法是否被调用执行</li><li>修改原来的目标方法的执行结果 影响最后的调用结果</li></ul></li><li>参数<ul><li>ProceedingJoinPoint  等同于jdk动态代理参数中的Method</li><li>作用  执行目标方法的</li></ul></li><li>返回值  就是目标方法的执行结果 可以被修改<br>环绕通知经常做事务  在目标方法之前开启事务  执行目标方法后提交事务</li></ul></li></ul><h1 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h1><h2 id="bean-配置"><a href="#bean-配置" class="headerlink" title="bean 配置"></a>bean 配置</h2><h3 id="bean-基础配置"><a href="#bean-基础配置" class="headerlink" title="bean 基础配置"></a>bean 基础配置</h3><p><img src="/2022/07/27/Spring-1/bean%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.png" alt="bean基础配置"></p><h3 id="bean-别名配置"><a href="#bean-别名配置" class="headerlink" title="bean 别名配置"></a>bean 别名配置</h3><p><img src="/2022/07/27/Spring-1/bean%E7%9A%84%E5%88%AB%E5%90%8D%E9%85%8D%E7%BD%AE.png" alt="bean的别名配置"></p><h3 id="bean-作用范围配置"><a href="#bean-作用范围配置" class="headerlink" title="bean 作用范围配置"></a>bean 作用范围配置</h3><p><img src="/2022/07/27/Spring-1/bean%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.png" alt="bean基础配置"></p><ul><li>适合交给容器进行管理的bean<ul><li>表现层对象</li><li>业务层对象</li><li>数据层对象</li><li>工具对象</li></ul></li><li>不适合交给容器进行管理的bean<ul><li>封装实体的域对象</li></ul></li></ul><h2 id="bean-实例化"><a href="#bean-实例化" class="headerlink" title="bean 实例化"></a>bean 实例化</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>提供可访问的构造方法</li><li>spring通过反射获得该方法的无参构造方法用以创建对象</li><li>如果无无参构造方法将会报错</li></ul><h3 id="使用静态工厂"><a href="#使用静态工厂" class="headerlink" title="使用静态工厂"></a>使用静态工厂</h3><ul><li>静态工厂  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态工厂创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">id</span> = <span class="string">&quot;orderDao&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.kris.factory.OrderDaoFactory&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-method</span>=<span class="string">&quot;getOrderDao&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用实例化工厂"><a href="#使用实例化工厂" class="headerlink" title="使用实例化工厂"></a>使用实例化工厂</h3><ul><li><p>实例工厂</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.factory.UserDaoFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实例化工厂运行的顺序是:</p><ul><li><p>创建实例化工厂对象,对应的是第一行配置</p></li><li><p>调用对象中的方法来创建bean，对应的是第二行配置</p><ul><li><p>factory-bean:工厂的实例对象</p></li><li><p>factory-method:工厂对象中的具体创建对象的方法名</p></li></ul></li></ul></li></ul><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><ul><li>FactoryBean  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回所创建类的Class对象</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>配置  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.factory.UserDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="bean-生命周期"><a href="#bean-生命周期" class="headerlink" title="bean 生命周期"></a>bean 生命周期</h2><ul><li><p>提供生命周期控制方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean初始化对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean销毁前对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置生命周期控制方法</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实现 InitializingBean DisposableBean 接口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bean-的执行流程"><a href="#bean-的执行流程" class="headerlink" title="bean 的执行流程"></a>bean 的执行流程</h3></li><li><p>初始化容器</p><ul><li>创建对象</li><li>执行构造方法</li><li>执行属性注入(set操作)</li><li>执行bean初始化方法</li></ul></li><li><p>使用bean</p><ul><li>执行业务操作</li></ul></li><li><p>关闭&#x2F;销毁容器</p><ul><li>执行bean销毁方法</li></ul></li></ul><h3 id="bean-销毁时机"><a href="#bean-销毁时机" class="headerlink" title="bean 销毁时机"></a>bean 销毁时机</h3><ul><li>容器关闭前触发bean的小销毁</li><li>关闭容器方式<ul><li>手工关闭容器<br>ConfigurableApplicationContext接口close()操作</li><li>注册关闭钩子 在虚拟机退出前先关闭容器再退出虚拟机<br>ConfigurableApplicationContext接口registerShutdownHook()操作</li></ul></li></ul><h2 id="使用注解创建bean"><a href="#使用注解创建bean" class="headerlink" title="使用注解创建bean"></a>使用注解创建bean</h2><ul><li><p>@Component  创建对象的  等同于<bean> 标签的功能</bean></p><ul><li>属性 value 就是对象的名称   也就是bean的id值</li><li>value的值是唯一的 创建的对象在整个spring容器中就一个</li></ul></li><li><p>@Respository  放在dao的实现类上面表示创建dao对象  dao对象是能访问数据库的</p></li><li><p>@Service       放在service的实现类上 创建service对象  </p><ul><li>service对象是做业务处理的 可以有事务等功能的</li></ul></li><li><p>@Controller     放在控制器类上面  创建控制器对象</p><ul><li>控制器对象  能够接受用户参数 显示请求的处理结果</li></ul></li><li><p>@Value  简单类型的属性赋值</p><ul><li>属性  <ul><li>value 是String类型的  表示简单类型的属性值</li></ul></li><li>位置  <ul><li>在属性定义的上面  无需set方法  推荐使用</li><li>在set方法上面</li></ul></li></ul></li><li><p>@AutoWire  spring框架提供的注解  实现引用类型的赋值</p><ul><li>spring 通过注解给引用类型赋值  使用的是自动注入原理  支持byName  </li><li>byType<ul><li>属性requird bool 默认为  true</li><li>requird &#x3D; true 表示引用类型赋值失败 程序报错 并终止执行</li><li>requird &#x3D; false  引用类型如果赋值失败 程序正常执行 引用类型null </li><li>默认为byType自动注入</li><li>使用byName  需要在属性上面加入@Qualifier(value &#x3D; “bean的id”) 表示使用指定名称的bean完成精准赋值</li></ul></li></ul></li><li><p>@Resource  来自jdk中的注解 spring框架提供了对这个注解的功能支持 可以使用它给引用类型赋值</p><ul><li>使用的也是自动注入原理  支持byName  byType  默认是byName</li><li>位置  <ul><li>在属性定义上面  无需set方法  推荐使用</li><li>在set方法上面</li></ul></li></ul></li></ul><h1 id="关于配置文件"><a href="#关于配置文件" class="headerlink" title="关于配置文件"></a>关于配置文件</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    当项目中有许多类时  可以将配置文件按模块进行分类</span></span><br><span class="line"><span class="comment">    创建一个主配置文件  包含其他的配置文件 主配置文件一般不定义对象</span></span><br><span class="line"><span class="comment">    语法</span></span><br><span class="line"><span class="comment">        &lt;import resource = &quot;其他配置文件的路径&quot;/&gt;</span></span><br><span class="line"><span class="comment">        关键字 classpath  表示类路径（class文件所在的目录）</span></span><br><span class="line"><span class="comment">        在配置文件中要指定其他文件的位置 需要使用classpath 告诉spring到哪去加载读取配置文件</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    在包含关系的配置文件中 可以通配符(* ；表示任意字符)</span></span><br><span class="line"><span class="comment">    注意  主的配置文件名称不能包含在通配符的范围内 不然会造成死循环</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:pa_04/applicationContext.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    声明组件扫描器</span></span><br><span class="line"><span class="comment">    base-package 指定注解在你的项目中的包名</span></span><br><span class="line"><span class="comment">    component-scan工作方式  spring 会扫描遍历base-package指定的包</span></span><br><span class="line"><span class="comment">        把包中和子包中的所有类 找到类中的注解 按照注解的功能创建对象  或给属性赋值</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    指定多个包</span></span><br><span class="line"><span class="comment">        - 使用多次组件扫描器</span></span><br><span class="line"><span class="comment">        - 使用分割符(;或,) 分割多个包名</span></span><br><span class="line"><span class="comment">            base-package = &quot;com.kris.pa_01; com.kris.pa_02&quot;</span></span><br><span class="line"><span class="comment">        - 指定父包</span></span><br><span class="line"><span class="comment">            base-package = &quot;com.kris&quot;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">&quot;com.kris.pa_04&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用配置文件 在注解的value中即可使用  &#123;键名&#125;  来表示对应的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:test.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        声明自动代理生成器 使用aspectj框架内部的功能 创建目标的代理对象</span></span><br><span class="line"><span class="comment">        创建代理对象是在内存中实现的  修改目标对象的内存中的结构 创建为代理对象</span></span><br><span class="line"><span class="comment">        所以目标对象就是被修改后的代理对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        aspectj-autoproxy  会把spring容器中的所有目标对象一次性都生成代理对象</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/07/26/Git-1/"/>
      <url>/2022/07/26/Git-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到非常大的项目的所有内容。</p><span id="more"></span><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li><p>实现跨区域多人协同开发</p></li><li><p>追踪和记载一个或者多个文件的历史记录</p></li><li><p>组织和保护你的源代码和文档</p></li><li><p>统计工作量</p></li><li><p>并行开发、提高开发效率</p></li><li><p>跟踪记录整个软件的开发过程</p></li><li><p>减轻开发人员的负担，节省时间，同时降低人为错误</p></li></ul><h2 id="常见版本控制"><a href="#常见版本控制" class="headerlink" title="常见版本控制"></a>常见版本控制</h2><ul><li><p>Git</p></li><li><p>SVN（Subversion）</p></li><li><p>CVS（Concurrent Versions System）</p></li><li><p>VSS（Micorosoft Visual SourceSafe）</p></li><li><p>TFS（Team Foundation Server）</p></li><li><p>Visual Studio Online</p></li></ul><p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p><h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><h3 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><h3 id="集中版本控制"><a href="#集中版本控制" class="headerlink" title="集中版本控制"></a>集中版本控制</h3><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改<br>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p>每个人都拥有全部的代码！安全隐患！</p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><h3 id="Git-和-SVN的主要区别"><a href="#Git-和-SVN的主要区别" class="headerlink" title="Git 和 SVN的主要区别"></a>Git 和 SVN的主要区别</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><h1 id="Git-环境配置"><a href="#Git-环境配置" class="headerlink" title="Git 环境配置"></a>Git 环境配置</h1><h2 id="常用Linux命令"><a href="#常用Linux命令" class="headerlink" title="常用Linux命令"></a>常用Linux命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>cd</td><td>改变目录</td></tr><tr><td>cd..</td><td>回退到上个目录，直接cd进入默认目录</td></tr><tr><td>pwd</td><td>显示当前所在的目录路径</td></tr><tr><td>ls(ll)</td><td>都是列出当前目录中的所有文件 只不过ll列出的内容更为详细</td></tr><tr><td>touch</td><td>新建一个文件</td></tr><tr><td>rm</td><td>删除一个文件</td></tr><tr><td>mkdir</td><td>新建一个文件夹</td></tr><tr><td>rm-r</td><td>删除一个文件夹</td></tr><tr><td>rm-rf</td><td>强制删除</td></tr><tr><td>mv</td><td>移动文件  mv 移动文件 目标文件夹</td></tr><tr><td>reset</td><td>重新初始化终端</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>history</td><td>查看命令历史</td></tr><tr><td>help</td><td>帮助</td></tr><tr><td>exit</td><td>退出</td></tr><tr><td>#</td><td>注释</td></tr></tbody></table><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看配置</span></span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统config</span></span><br><span class="line">git config <span class="params">--system</span> <span class="params">--list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前用户(global)配置</span></span><br><span class="line">git config <span class="params">--global</span> <span class="params">--list</span></span><br></pre></td></tr></table></figure><h2 id="Git配置相关文件"><a href="#Git配置相关文件" class="headerlink" title="Git配置相关文件"></a>Git配置相关文件</h2><ul><li><p>Git\etc\gitconfig  ：Git 安装目录下的 gitconfig     –system 系统级</p></li><li><p>C:\Users\Administrator\ .gitconfig    只适用于当前登录用户的配置  –global 全局</p></li></ul><h2 id="设置用户名和邮箱"><a href="#设置用户名和邮箱" class="headerlink" title="设置用户名和邮箱"></a>设置用户名和邮箱</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git config --global <span class="literal">user</span>.<span class="keyword">name</span> <span class="string">&quot;username&quot;</span>  <span class="comment">#名称</span></span><br><span class="line">git config --global <span class="literal">user</span>.email email   <span class="comment">#邮箱</span></span><br></pre></td></tr></table></figure><p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p><h1 id="Git-基本理论"><a href="#Git-基本理论" class="headerlink" title="Git 基本理论"></a>Git 基本理论</h1><h2 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage&#x2F;Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。</p><ul><li><p>Workspace：工作区，就是你平时存放项目代码的地方</p></li><li><p>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</p></li><li><p>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</p></li><li><p>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p></li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul><li><p>在工作目录中添加、修改文件；</p></li><li><p>将需要进行版本管理的文件放入暂存区域；</p></li><li><p>将暂存区域的文件提交到git仓库。</p></li></ul><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="/2022/07/26/Git-1/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Git工作流程"></p><h1 id="Git-项目搭建"><a href="#Git-项目搭建" class="headerlink" title="Git 项目搭建"></a>Git 项目搭建</h1><h2 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h2><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><ul><li><p>创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="variable">$ </span>git init</span><br></pre></td></tr></table></figure></li><li><p>执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p></li></ul><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><ul><li>另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line">$ git <span class="keyword">clone</span> <span class="title">[url</span>]  <span class="comment"># https://gitee.com/kuangstudy/openclass.git</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Git-文件操作"><a href="#Git-文件操作" class="headerlink" title="Git 文件操作"></a>Git 文件操作</h1><h2 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h2><blockquote><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p></blockquote><ul><li><p>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p></li><li><p>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</p></li><li><p>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</p></li><li><p>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</p></li></ul><h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看指定文件状态</span></span><br><span class="line"><span class="attribute">git</span> status<span class="meta"> [filename]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看所有文件状态</span></span><br><span class="line"><span class="attribute">git</span> status</span><br><span class="line"></span><br><span class="line"><span class="comment"># git add .                  添加所有文件到暂存区</span></span><br><span class="line"><span class="comment"># git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span></span><br></pre></td></tr></table></figure><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><blockquote><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等<br>在主目录下建立”.gitignore”文件，此文件有如下规则：</p></blockquote><ul><li><p>忽略文件中的空行或以井号（#）开始的行将会被忽略。</p></li><li><p>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</p></li><li><p>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</p></li><li><p>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</p></li><li><p>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为注释</span></span><br><span class="line">*.txt        <span class="comment">#忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span></span><br><span class="line">!lib.txt     <span class="comment">#但lib.txt除外</span></span><br><span class="line">/temp        <span class="comment">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span></span><br><span class="line">build<span class="regexp">/       #忽略build/</span>目录下的所有文件</span><br><span class="line">doc<span class="regexp">/*.txt    #会忽略 doc/</span>notes.txt 但不包括 doc<span class="regexp">/server/</span>arch.txt</span><br></pre></td></tr></table></figure><h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><p>git分支常用指令</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-<span class="keyword">name</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-<span class="keyword">name</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git <span class="keyword">push</span> origin --<span class="keyword">delete</span> [branch-<span class="keyword">name</span>]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p><p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Element</title>
      <link href="/2022/07/19/Element/"/>
      <url>/2022/07/19/Element/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一套基于Vue 的网站组件库 用于快速构建网页</p><p><a href="https://element.eleme.cn/#/zh-CNListener">官网</a></p><span id="more"></span><h1 id="Element-快速入门"><a href="#Element-快速入门" class="headerlink" title="Element 快速入门"></a>Element 快速入门</h1><ul><li>引入Element的css js 文件 和Vue.js<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;element-ui/lib/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>创建Vue核心对象<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>官网复制Element组件代码<h1 id="Element-布局"><a href="#Element-布局" class="headerlink" title="Element 布局"></a>Element 布局</h1></li><li>Element 中有两种布局方式<ul><li><p>Layout布局 通过基础的24分栏 迅速简便的创建布局<br><img src="/2022/07/19/Element/Layout%E5%B8%83%E5%B1%80.png" alt="Layout布局"></p></li><li><p>Container 布局容器 用于布局的容器组件 方便快速的搭建页面的基本结构</p><p><img src="/2022/07/19/Element/Container%E5%B8%83%E5%B1%80.png" alt="Container布局"></p></li></ul></li></ul><h1 id="Element-组件"><a href="#Element-组件" class="headerlink" title="Element 组件"></a>Element 组件</h1>]]></content>
      
      
      <categories>
          
          <category> Element </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2022/07/18/Vue/"/>
      <url>/2022/07/18/Vue/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Vue 是一套前端框架 免除原生JS中的DOM操作 简化书写<br>基于MVVM(Model-View-ViewModel) 思想 实现数据的双向绑定 将编程的关注点放在数据上<br><a href="https://cn.vuejs.org/">官网</a></p></blockquote><span id="more"></span><h1 id="Vue-快速入门"><a href="#Vue-快速入门" class="headerlink" title="Vue 快速入门"></a>Vue 快速入门</h1><ul><li><p>新建HTML页面 引入Vue.js文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在JS代码区域 创建Vue核心对象 进行数据绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>&#123;</span><br><span class="line">          <span class="attr">username</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>编写视图</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span> = <span class="string">&quot;username&quot;</span> <span class="attr">v-model</span> = <span class="string">&quot;username&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123;<span class="name">username</span>&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="Vue-常用指令"><a href="#Vue-常用指令" class="headerlink" title="Vue 常用指令"></a>Vue 常用指令</h1></li><li><p>指令 HTML标签上带有v-前缀的特殊属性 不同指令具有不同含义</p></li><li><p>常用指令</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>v-bind</td><td>为HTML标签绑定属性值 如设置href css样式等</td></tr><tr><td>v-model</td><td>在表单元素上创建双向数据绑定</td></tr><tr><td>v-on</td><td>为HTML标签绑定事件</td></tr><tr><td>v-show</td><td>根据条件展示某元素 区别在于切换的是display属性的值</td></tr><tr><td>v-for</td><td>列表渲染 遍历容器的元素或者对象的属性</td></tr><tr><td>v-if v-else v-else-if</td><td>条件性的渲染某元素，判定为true时渲染 否则不渲染</td></tr></tbody></table><h1 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h1></li><li><p>生命周期有八个阶段 每触发一个生命周期事件 会自动执行一个生命周期方法</p><table><thead><tr><th>状态</th><th>阶段周期</th></tr></thead><tbody><tr><td>beforeCreate</td><td>创建前</td></tr><tr><td>created</td><td>创建后</td></tr><tr><td>beforeMount</td><td>载入前</td></tr><tr><td>mounted</td><td>挂载完成</td></tr><tr><td>beforeUpdate</td><td>更新前</td></tr><tr><td>updated</td><td>更新后</td></tr><tr><td>beforeDestroy</td><td>销毁前</td></tr><tr><td>destroyed</td><td>销毁后</td></tr></tbody></table></li><li><p>mounted 挂载完成 Vue初始化成功 HTML页面渲染成功</p><ul><li>发送异步请求 加载数据<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;vue 挂载完毕 发送异步请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="/2022/07/18/Vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Vue生命周期"></p><p><a href="https://www.bilibili.com/video/BV1Qf4y1T7Hx?p=147&vd_source=12da55ab9dd7741612032a6f327c8c9d">图片来源</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AJAX</title>
      <link href="/2022/07/17/AJAX/"/>
      <url>/2022/07/17/AJAX/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AJAX(Asynchronous JavaScript And XML) : 异步的JavaScript和XML</p><span id="more"></span><ul><li>AJAX 作用<ul><li>与服务器进行数据交换 通过AJAX 可以给服务器发送请求 并获取服务器响应的数据 </li><li>异步交互 可以在不重新加载整个页面的情况下 与服务器交换数据并更新部分网页的技术</li></ul></li></ul><h1 id="AJAX-快速入门"><a href="#AJAX-快速入门" class="headerlink" title="AJAX 快速入门"></a>AJAX 快速入门</h1><ul><li>编写AjaxServlet 并使用response输出字符串</li><li>创建XMLHttpRequest 对象 用于和服务器交换数据<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span>(window.XMLHttpRequest)&#123;</span><br><span class="line">  xmlhttp = <span class="keyword">new</span> <span class="type">XMLHttpRequest</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  xml = <span class="keyword">new</span> <span class="type">ActiveObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>向服务器发送请求<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;<span class="keyword">GET</span>&quot;</span>,<span class="string">&quot;url&quot;</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure></li><li>获取服务器响应数据<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xmlhttp.readyState == <span class="number">4</span> &amp;&amp; xmlhttp.<span class="keyword">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">      elert(xmlhttp.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Axios-异步框架"><a href="#Axios-异步框架" class="headerlink" title="Axios 异步框架"></a>Axios 异步框架</h1><blockquote><p>Axios 对原生的AJAX进行封装 简化书写</p></blockquote></li><li><a href="https://www.axios-http.cn/">官网</a></li></ul><h2 id="Axios-快速入门"><a href="#Axios-快速入门" class="headerlink" title="Axios 快速入门"></a>Axios 快速入门</h2><ul><li>引入 axios 的  js文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用axios发送请求 并获取响应结果<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">axios</span>(&#123;</span><br><span class="line">  method:&quot;get&quot;,</span><br><span class="line">  url:&quot;...&quot;</span><br><span class="line">&#125;)<span class="selector-class">.then</span>(function(resp)&#123;</span><br><span class="line">  <span class="built_in">alert</span>(resp.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> axios(<span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">  method:</span><span class="string">&quot;post&quot;</span>,</span><br><span class="line"><span class="symbol">  url:</span><span class="string">&quot;...&quot;</span>,</span><br><span class="line"><span class="symbol">  data:</span><span class="string">&quot;username = zhangsan&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span>).then(function(resp)<span class="punctuation">&#123;</span></span><br><span class="line">  alert(resp.data)<span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;</span>)<span class="punctuation">;</span></span><br></pre></td></tr></table></figure><h2 id="Axios-请求方式别名"><a href="#Axios-请求方式别名" class="headerlink" title="Axios 请求方式别名"></a>Axios 请求方式别名</h2><img src="/2022/07/17/AJAX/Axios%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%88%AB%E5%90%8D.png" alt="Axios请求方式别名"></li><li>发送get请求<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">axios.get</span>(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">  .then(<span class="function"><span class="title">function</span>(<span class="variable">resp</span>)&#123;</span></span><br><span class="line"><span class="function">      <span class="title">alert</span>(<span class="variable">resp.data</span>);</span></span><br><span class="line"><span class="function">  &#125;)</span></span><br></pre></td></tr></table></figure></li><li>发送post请求<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">axios</span>.<span class="property">post</span>(<span class="string">&quot;url&quot;</span>,<span class="string">&quot;参数&quot;</span>)</span><br><span class="line">  .<span class="property">then</span>(<span class="title function_">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="variable">resp</span>.<span class="property">data</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><blockquote><p>JavaScript Object Notation JavaScript 对象表示法 其语法简单 层次鲜明 多用于作为数据载体 在网络中进行数据传输</p></blockquote></li></ul><h2 id="JSON-基础语法"><a href="#JSON-基础语法" class="headerlink" title="JSON 基础语法"></a>JSON 基础语法</h2><ul><li><p>定义</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 = &#123;</span><br><span class="line">  <span class="string">&quot;key1&quot;</span> : <span class="type">value1</span>,</span><br><span class="line">  <span class="string">&quot;key2&quot;</span> : <span class="type">value2</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>value的数据类型<ul><li>数字(整数或者浮点数)</li><li>字符串(在双引号中)</li><li>逻辑值(true or false)</li><li>数组(在方括号中)</li><li>对象(在花括号中) </li><li>null</li></ul></li><li>实例  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> json = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">23</span>,</span><br><span class="line">    <span class="string">&quot;addr&quot;</span>:<span class="selector-attr">[<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;上海&quot;</span>]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取数据</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名.<span class="built_in">key</span></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">json.<span class="built_in">key</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="JSON-数据和Java对象转换"><a href="#JSON-数据和Java对象转换" class="headerlink" title="JSON 数据和Java对象转换"></a>JSON 数据和Java对象转换</h2><ul><li>Fastjson是阿里巴巴提供的一个Java语言编写的高性能功能完善的JSON库 是目前Java 语言中最快的JSON库 可以实现Java对象和JSON字符串的相互转换</li><li>使用<ul><li>导入坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependency&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Java对象转JSON<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String jsonStr = <span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span><span class="keyword">to</span><span class="constructor">JSONString(<span class="params">obj</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>JSON 字符串转Java对象<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">User</span> <span class="keyword">user</span> = <span class="type">JSON</span>.parseObject(jsonStr,<span class="keyword">User</span>,<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> AJAX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter&amp;Listener</title>
      <link href="/2022/07/16/Filter/"/>
      <url>/2022/07/16/Filter/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Filter表示过滤器 可以把对资源的请求拦截下来 实现一些特殊的功能 如 权限控制 统一编码处理 敏感字符处理等<br>Listener 表示监听器可以监听就是在appliction session request 三个对象创建 销毁 或往其中添加修改删除属性时自动执行代码的功能组件</p><span id="more"></span><h1 id="Filter-快速入门"><a href="#Filter-快速入门" class="headerlink" title="Filter 快速入门"></a>Filter 快速入门</h1><ul><li>定义类 实现Filter 接口 并重写其所有方法<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">FileterDemo</span> <span class="selector-tag">implements</span> <span class="selector-tag">Filter</span> &#123;</span><br><span class="line">  <span class="variable">@Override</span></span><br><span class="line">  public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">@Override</span></span><br><span class="line">  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">@Override</span></span><br><span class="line">  public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>配置Filter拦截资源路径 在类上定义@WebFilter 注解<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(<span class="string">&quot;/*&quot;</span>)</span></span><br></pre></td></tr></table></figure></li><li>在doFilter方法中编写代码 并放行<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">public void <span class="keyword">do</span><span class="constructor">Filter(ServletRequest <span class="params">servletRequest</span>, ServletResponse <span class="params">servletResponse</span>, FilterChain <span class="params">filterChain</span>)</span> throws IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">// 放行</span></span><br><span class="line">    filterChain.<span class="keyword">do</span><span class="constructor">Filter(<span class="params">servletRequest</span>,<span class="params">servletResponse</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Filter-执行流程"><a href="#Filter-执行流程" class="headerlink" title="Filter 执行流程"></a>Filter 执行流程</h1></li><li>执行放行前逻辑</li><li>放行</li><li>访问资源</li><li>执行放行后逻辑<h1 id="Filter-使用细节"><a href="#Filter-使用细节" class="headerlink" title="Filter 使用细节"></a>Filter 使用细节</h1><h2 id="Filter-拦截路径配置"><a href="#Filter-拦截路径配置" class="headerlink" title="Filter 拦截路径配置"></a>Filter 拦截路径配置</h2></li><li>Filter 可以根据需求 配置不同的拦截资源路径<ul><li>拦截具体的资源 &#x2F;index.jsp 只有访问index.jsp时才会被拦截</li><li>目录拦截 &#x2F;user&#x2F;* 访问&#x2F;user 下的所有资源都会被拦截</li><li>后缀名拦截 *.jsp 访问后缀名为jsp的资源 都会被拦截</li><li>拦截所有 &#x2F;* 访问所有资源 都会被拦截</li></ul></li></ul><h2 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h2><blockquote><p>一个Web应用 可以配置多个过滤器 这多个过滤器称为过滤器链</p></blockquote><ul><li>过滤器的执行顺序由字符串的排序决定</li></ul><h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><ul><li><p>Listener分类<br> <img src="/2022/07/16/Filter/Listener%E5%88%86%E7%B1%BB.png" alt="Listener分类"></p></li><li><p>使用</p><ul><li>定义类 实现对应的接口</li><li>在类上添加@WebListener是注解</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookies&amp;Session</title>
      <link href="/2022/07/15/Cookies-Session/"/>
      <url>/2022/07/15/Cookies-Session/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>会话跟踪是一种维护浏览器状态的方法 服务器需要识别多次请求是否来自于同一浏览器 以便在同一次会话的多次请求间共享数据</p></blockquote><span id="more"></span><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><blockquote><p>客户端会话跟踪技术</p></blockquote><h2 id="Cookie-基本使用"><a href="#Cookie-基本使用" class="headerlink" title="Cookie 基本使用"></a>Cookie 基本使用</h2><ul><li>Cookie：客户端会话技术 将数据保存到客户端 以后每次请求都携带Cookie数据进行访问</li><li>Cookie基本使用<ul><li>创建Cookie对象 设置数据<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cookie cookie</span> = new Cookie(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>发送Cookie到客户端 使用response对象<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.add<span class="constructor">Cookie(<span class="params">cookie</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获取客户端携带的所有Cookie 使用request对象<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies <span class="operator">=</span> request.getCookies()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>遍历数组 获取每一个Cookie对象</li><li>使用Cookie对象方法获取数据<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie.getName()<span class="comment">;</span></span><br><span class="line">cookie.getValue()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="Cookie-原理"><a href="#Cookie-原理" class="headerlink" title="Cookie 原理"></a>Cookie 原理</h2></li></ul></li><li>Cookie 的实现是基于HTTP协议的<ul><li>响应头 set-cookie</li><li>请求头 cookie<h2 id="Cookie-使用细节"><a href="#Cookie-使用细节" class="headerlink" title="Cookie 使用细节"></a>Cookie 使用细节</h2></li></ul></li><li>Cookie 存活时间<ul><li>默认情况下，Cookie 存储在浏览器内存中 当浏览器关闭 内存释放 则Cookie被销毁</li><li>setMaxAge(int seconds) 设置Cookie存活时间<ul><li>正数 将Cookie写入浏览器所在电脑的硬盘 持久化存储 到时间自动删除</li><li>负数 默认值 Cookie在当前浏览器内存中 当浏览器关闭 则Cookie被销毁</li><li>零 删除对应Cookie</li></ul></li></ul></li><li>Cookie 存储中文<ul><li>Cookie 不能直接存储中文</li><li>如需要存储 则需要进行转码 URL编码<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><blockquote><p>服务端会话跟踪技术</p></blockquote><h2 id="Session-基本使用"><a href="#Session-基本使用" class="headerlink" title="Session 基本使用"></a>Session 基本使用</h2></li></ul></li><li>服务端会话跟踪技术 将数据保存到服务端</li><li>JavaEE提供HttpSession接口 来实现一次会话的多次请求间数据共享功能</li><li>使用<ul><li>获取Session对象<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session <span class="operator">=</span> request.getSession()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>Session 对象功能<ul><li>void setAttribute(String name,Object o) 存储数据到session域中</li><li>Object getAttribute(String name) 根据key 获取值</li><li>void removeAttribute(String name) 根据key 删除该键值对<h2 id="Session-原理"><a href="#Session-原理" class="headerlink" title="Session 原理"></a>Session 原理</h2></li></ul></li></ul></li><li>用户第一次请求服务器时，服务器端会生成一个sessionid</li><li>服务器端将生成的sessionid返回给客户端，通过set-cookie</li><li>客户端收到sessionid会将它保存在cookie中，当客户端再次访问服务端时会带上这个sessionid</li><li>当服务端再次接收到来自客户端的请求时，会先去检查是否存在sessionid，不存在就新建一个sessionid重复1,2的流程，如果存在就去遍历服务端的session文件，找到与这个sessionid相对应的文件，文件中的键值便是sessionid，值为当前用户的一些信息</li><li>此后的请求都会交换这个 Session ID，进行有状态的会话。<h2 id="Session-使用细节"><a href="#Session-使用细节" class="headerlink" title="Session 使用细节"></a>Session 使用细节</h2></li><li>Session 钝化 活化<ul><li>钝化 在服务器正常关闭后 Tomcat会自动将Session数据写入硬盘的文件中</li><li>活化 再次启动服务器后 从文件中加载数据到Session中</li></ul></li><li>Session 销毁<ul><li>默认情况下 无操作 30分组后自动销毁<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>调用Session对象的invalidate()方法</li></ul></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>Cookie 和 Session 都是来完成一次会话内多次请求间数据共享的</li><li>区别<ul><li>存储位置 Cookie 是将数据存储在客户端 Session将数据存储在服务器端</li><li>安全性 Cookie 不安全 Seesion 安全</li><li>数据大小 Cookie 最大3KB Session 无大小限制</li><li>存储时间 Cookie可以长时间存储 Session默认30分钟</li><li>服务器性能 Cookie不占服务器资源 Session 占用服务器资源</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Request&amp;Response</title>
      <link href="/2022/07/13/Request-Response/"/>
      <url>/2022/07/13/Request-Response/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Request 获取请求数据<br>Response 设置响应数据</p></blockquote><span id="more"></span><h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><h2 id="Request-继承体系"><a href="#Request-继承体系" class="headerlink" title="Request 继承体系"></a>Request 继承体系</h2><p><img src="/2022/07/13/Request-Response/Request%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png" alt="Request 继承体系"></p><ul><li>TomCat 需要解析请求数据 封装为request对象 并且创建request对象传递到service方法中<h2 id="Request-获取请求数据"><a href="#Request-获取请求数据" class="headerlink" title="Request 获取请求数据"></a>Request 获取请求数据</h2><h3 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h3></li><li>请求数据分为3部分<ul><li>请求行 GET&#x2F;request-demo&#x2F;reql?username &#x3D; zhangsan HTTP&#x2F;1.1<ul><li>String getMethod() 获取请求方式  ： GET</li><li>String getContextPath() 获取虚拟目录(目录访问路径) :&#x2F;request-demo</li><li>StringBuffer getRequestURL() 获取URL ： <a href="http://localhost:8080/request-demo/req1">http://localhost:8080/request-demo/req1</a></li><li>String getRequestURL() 获取URI ： &#x2F;request-demo&#x2F;req1</li><li>String getQueryString() 获取请求参数(GET方式) username&#x3D; zhangsan&amp;password &#x3D; 123</li></ul></li><li>请求头 User-Agent:Mozilla&#x2F;5.0 Chrome&#x2F;91.0.4472.106<ul><li>String getHeader(String name) 根据请求头名称 获取值</li></ul></li><li>请求体 username &#x3D; kris&amp;password &#x3D; 111<ul><li>ServletInputStream getInputSatream() 获取字节输入流</li><li>BufferedReader getReader() 获取字符输入流</li></ul></li></ul></li></ul><h3 id="通用方式获取请求参数"><a href="#通用方式获取请求参数" class="headerlink" title="通用方式获取请求参数"></a>通用方式获取请求参数</h3><ul><li>请求参数获取方式<ul><li>GET 方式<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">String</span> <span class="function"><span class="title">getQueryString</span>()</span></span><br></pre></td></tr></table></figure></li><li>POST 方式<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">BufferedReader</span> <span class="function"><span class="title">getReader</span>()</span></span><br></pre></td></tr></table></figure></li></ul></li><li>Request 通用方式获取请求参数<ul><li>Map&lt;String,String[]&gt; getParameterMap(); 获取所有参数Map集合</li><li>String[] getParameterValues(String name) 根据名称获取参数值(数组)</li><li>String getParameter(String name) 根据名称获取参数值(单个值)</li></ul></li></ul><h3 id="请求参数中文乱码处理"><a href="#请求参数中文乱码处理" class="headerlink" title="请求参数中文乱码处理"></a>请求参数中文乱码处理</h3><ul><li><p>请求参数如果存在中文数据，则会乱码</p><ul><li>POST： 设置输入流的编码<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>GET  先编码 再解码<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">String(<span class="params">username</span>.<span class="params">getBytes</span>(<span class="string">&quot;ISO-8859-1&quot;</span>)</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>URL 编码<ul><li>将字符串按照编码方式转为二进制</li><li>每个字节转为2个16进制数并在前边加上%<h2 id="Request-请求转发"><a href="#Request-请求转发" class="headerlink" title="Request 请求转发"></a>Request 请求转发</h2><blockquote><p>一种在服务器内部的资源跳转方式</p></blockquote></li></ul></li></ul></li><li><p>实现方式</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.getRequestDispatcher(<span class="string">&quot;资源B路径&quot;</span>).forward(req.resp)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>请求转发资源间共享数据 使用Requset 对象</p><ul><li>void setAttribute(String name,Object o) 存储数据到request域中</li><li>Object getAttribute(String name) 根据key 获取值</li><li>void removeAttribute(String name)根据key 删除该键值对</li></ul></li><li><p>请求转发特点</p><ul><li>浏览器地址栏路径不发生变化</li><li>只能转发到当前服务器的内部资源</li><li>一次请求 可以在转发的资源间使用request共享数据</li></ul></li></ul><h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><h2 id="Response-设置响应数据功能介绍"><a href="#Response-设置响应数据功能介绍" class="headerlink" title="Response 设置响应数据功能介绍"></a>Response 设置响应数据功能介绍</h2><ul><li><p>响应行 </p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure><ul><li>void setStatus(int sc) 设置响应状态码</li></ul></li><li><p>响应头</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>:<span class="type">text</span>/html</span><br></pre></td></tr></table></figure><ul><li>void setHeader(String name,String value) 设置响应头键值对</li></ul></li><li><p>响应体</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;html&gt;</span><span class="section">&lt;head&gt;</span><span class="section">&lt;/head&gt;</span><span class="section">&lt;body&gt;</span><span class="section">&lt;/body&gt;</span><span class="section">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><ul><li>PrintWrite getWriter() 获取字符输出流</li><li>ServletOutputStream getOutputStream() 获取字节输出流<h2 id="Response-完成重定向"><a href="#Response-完成重定向" class="headerlink" title="Response 完成重定向"></a>Response 完成重定向</h2><blockquote><p>重定向(Redirect) 一种资源跳转方式</p></blockquote></li></ul></li><li><p>实现方式</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp.set<span class="constructor">Status(302)</span>;</span><br><span class="line">resp.set<span class="constructor">Header(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;另一资源的路径&quot;</span>)</span>;</span><br><span class="line"><span class="comment">//简化版</span></span><br><span class="line">resp.send<span class="constructor">Redirect(<span class="string">&quot;另一资源的路径&quot;</span>)</span></span><br></pre></td></tr></table></figure></li><li><p>重定向特点</p><ul><li>浏览器地址栏发生变化</li><li>可以重定向到任意位置的资源(服务器内部，外部均可)</li><li>两次请求，不能在多个资源使用request共享数据<h2 id="Response-响应字符数据"><a href="#Response-响应字符数据" class="headerlink" title="Response 响应字符数据"></a>Response 响应字符数据</h2></li></ul></li><li><p>使用</p><ul><li>通过Response对象获取字符输出流<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter writer <span class="operator">=</span> resp.getWriter()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>写数据<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.write(<span class="string">&quot;kris&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>设置编码<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset = utf-8&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>该流不需要关闭 随着响应结束 response 对象销毁 由服务器关闭<h2 id="Response-响应字节数据"><a href="#Response-响应字节数据" class="headerlink" title="Response 响应字节数据"></a>Response 响应字节数据</h2></li></ul></li><li><p>使用</p><ul><li>通过Response对象获取字符输出流<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletOutputStream outputStream <span class="operator">=</span> resp.getOutputStream()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>写数据<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputStream.write(字节数据)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>IOUtils工具类的使用</p><ul><li>导入坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOUtils.<span class="keyword">copy</span>(输入流,输出流);</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="/2022/07/12/Servlet/"/>
      <url>/2022/07/12/Servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Servlet 是JavaEE规范之一，就是一个接口 我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</p></blockquote><span id="more"></span><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><ul><li>创建web项目 导入Servlet依赖坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>创建 定义一个类 实现Servlet接口 并重写接口中的所有方法 并在service方法中输入一句话<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ServletDemo</span> <span class="symbol">implements</span> <span class="symbol">Servlet</span></span><br></pre></td></tr></table></figure></li><li>配置 在类上使用@WebServlet 注解 配置Servlet的访问路径<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(<span class="string">&quot;/demo1&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ServletDemo</span> <span class="symbol">implements</span> <span class="symbol">Servlet</span></span><br></pre></td></tr></table></figure><ul><li>注解中的loadOnStartip参数<ul><li>若为负整数(默认-1) 第一次被访问时创建Servlet对象</li><li>0或正整数 服务器启动时创建Servlet对象，数字越小优先级越高</li></ul></li></ul></li><li>访问 启动TomCat 浏览器输入URL访问该Servlet<h1 id="Servlet-执行流程"><a href="#Servlet-执行流程" class="headerlink" title="Servlet 执行流程"></a>Servlet 执行流程</h1></li><li>当Servlet第一次被调用的时候会触发init函数，该函数会把servlet实例加载到内存。该函数只会被调用一次</li><li>web服务器把接收到的http请求封装成一个Request对象，作为service函数的参数传递进去。</li><li>service函数会被调用多次，每访问一次Servlet，它的service函数就会被调用一次</li><li>返回的结果封装在response对象，web服务器先将response的信息拆解出来<br>形成http响应格式。然后将这个结果返回给浏览器。</li><li>浏览器得到结果之后会自己能识别的格式进行解析<h1 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h1></li><li>对象的生命周期指一个对象从被创建到销毁的整个过程</li><li>Servlet 运行在Servlet容器(web服务器)中，其生命周期由容器来管理 分为4个阶段<ul><li>加载和实例化 默认情况下 当Servlet第一次被访问时，由容器创建Servlet对象</li><li>初始化 在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象 完成一些如加载配置文件 创建连接等初始化的工作 该方法只调用一次</li><li>请求处理 每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理</li><li>服务终止 当需要释放内存或者容器关闭时 容器就会调用Servlet实例的destroy()方法完成资源的释放，在destroy()方法调用之后 容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</li></ul></li></ul><h1 id="Servlet-体系结构"><a href="#Servlet-体系结构" class="headerlink" title="Servlet 体系结构"></a>Servlet 体系结构</h1><blockquote><p>开发B&#x2F;S架构的web项目，都是针对HTTP协议 所以自定义的Servlet 会继承HttpServlet</p></blockquote><p><img src="/2022/07/12/Servlet/Servlet%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="Servlet体系结构"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@WebServlet</span>(<span class="string">&quot;/demo2&quot;</span>)</span><br><span class="line">    public <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doGet(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doPost(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Servlet-urlPattern配置"><a href="#Servlet-urlPattern配置" class="headerlink" title="Servlet urlPattern配置"></a>Servlet urlPattern配置</h1><ul><li>Servlet 要想被访问 必须配置其访问路径(urlPattern)<ul><li>一个Servlet 可以配置多个urlPattern<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPattern = &#123;<span class="string">&quot;/demo1&quot;</span>,<span class="string">&quot;/demo2&quot;</span>&#125;)</span></span><br></pre></td></tr></table></figure></li><li>urlPattern 配置规则<ul><li>精确匹配  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">配置路径  <span class="variable">@WebServlet</span>(&quot;/user/select&quot;)</span><br><span class="line">访问路径 localhost:<span class="number">8080</span><span class="operator">/</span>web<span class="operator">-</span>demo<span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span><span class="keyword">select</span></span><br></pre></td></tr></table></figure></li><li>目录匹配  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置路径  @WebServlet(<span class="string">&quot;/user/*&quot;</span>)</span><br><span class="line">访问路径 localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/aaa</span><br><span class="line">         localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/bbb</span><br></pre></td></tr></table></figure></li><li>扩展名匹配  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置路径  @WebServlet(<span class="string">&quot;*.do&quot;</span>)</span><br><span class="line">访问路径 localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/aaa.<span class="keyword">do</span></span><br><span class="line">         localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/bbb.<span class="keyword">do</span></span><br></pre></td></tr></table></figure></li><li>任意匹配  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置路径  <span class="variable">@WebServlet</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">          <span class="variable">@WebServlet</span>(<span class="string">&quot;/*&quot;</span>)</span><br><span class="line">访问路径 <span class="attribute">localhost</span>:<span class="number">8080</span>/web-demo/haha</span><br></pre></td></tr></table></figure></li><li>优先级<br>  精确&gt;目录&gt;扩展名&gt;&#x2F;*&gt;&#x2F;<h1 id="XML-配置方式编写-Servlet"><a href="#XML-配置方式编写-Servlet" class="headerlink" title="XML 配置方式编写 Servlet"></a>XML 配置方式编写 Servlet</h1></li></ul></li></ul></li><li>Servlet 从3.0版本后开始支持使用注解配置 3.0之前只支持XML配置文件的配置方式</li><li>步骤<ul><li>编写Servlet类</li><li>在web.xml中配置Servelt<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;demo&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.kris.servletDemo&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;demo&lt;/servlet&gt;</span><br><span class="line">    &lt;url-pattern&gt;/demo&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TomCat</title>
      <link href="/2022/07/12/TomCat/"/>
      <url>/2022/07/12/TomCat/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Web 服务器是一个应用程序 对HTTP协议的操作进行封装，使的程序员不必直接对协议进行操作，让Web开发更加便捷 </p></blockquote><span id="more"></span><h1 id="TomCat-目录结构"><a href="#TomCat-目录结构" class="headerlink" title="TomCat 目录结构"></a>TomCat 目录结构</h1><ul><li>bin 可执行文件存放目录</li><li>conf 配置文件存放目录</li><li>lib tomcat依赖的jar包</li><li>logs 日志文件</li><li>temp 临时文件</li><li>webapps 应用发布目录</li><li>work 工作目录<h1 id="TomCat-基本使用"><a href="#TomCat-基本使用" class="headerlink" title="TomCat 基本使用"></a>TomCat 基本使用</h1></li><li>配置<ul><li>修改启动端口号: conf&#x2F;server.xml<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port<span class="operator">=</span><span class="string">&quot;8080&quot;</span> protocol<span class="operator">=</span><span class="string">&quot;HTTP/1.1&quot;</span></span><br><span class="line">  connectionTimeout<span class="operator">=</span><span class="string">&quot;20000&quot;</span></span><br><span class="line">  redirectPort<span class="operator">=</span><span class="string">&quot;8443&quot;</span> /&gt;</span><br><span class="line">  //默认为 <span class="number">8080</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>HTTP协议默认端口号为80，如果将TomCat端口号改为80，则将来访问时将不用输入端口号</strong></p><ul><li>启动时可能出现的问题<ul><li>端口号冲突 找到对应程序 将其关闭</li><li>闪退 检查JAVA_HOME 环境变量是否正确配置</li></ul></li><li>TonCat 部署项目<ul><li>将项目放置到webapps 目录下，即部署完成</li></ul></li><li>一般JavaWeb项目会被打成war包 然后将war包放到webapps目录下,TomCat会自动解压缩war文件</li></ul><h1 id="IDEA中创建Maven-Web-项目"><a href="#IDEA中创建Maven-Web-项目" class="headerlink" title="IDEA中创建Maven Web 项目"></a>IDEA中创建Maven Web 项目</h1><ul><li>使用骨架(项目模板)<ul><li>选择web项目骨架，创建项目</li><li>删除pom.xml中多余的坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">以下到<span class="tag">&lt;/<span class="name">project</span>&gt;</span>以上的部分都可删除</span><br></pre></td></tr></table></figure></li><li>补齐缺失的目录结构<ul><li>java</li><li>resources</li></ul></li></ul></li><li>不使用<ul><li>新建maven模板  </li><li>将打包方式改为war</li><li>补齐缺失的目录结构<ul><li>webapp 以及其子目录</li></ul></li></ul></li></ul><h1 id="IDEA中使用TomCat"><a href="#IDEA中使用TomCat" class="headerlink" title="IDEA中使用TomCat"></a>IDEA中使用TomCat</h1><ul><li>pom.xml 添加TomCat插件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用Maven Helper 插件启动项目 选中项目 右键-&gt; Run Maven –&gt; tomcat7:run</li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2022/07/11/JS-1/"/>
      <url>/2022/07/11/JS-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>JavaScript 是一门跨平台，面向对象的脚本语言，来控制网页行为的，它能使网页可交互</p></blockquote><span id="more"></span><h1 id="JS-引入方式"><a href="#JS-引入方式" class="headerlink" title="JS 引入方式"></a>JS 引入方式</h1><ul><li>内部脚本 将JS代码定义在HTML页面中<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  JS代码</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在HTML文档中可以在任意地方，放置任意数量的&lt;script&gt;</li><li>一般把脚本置于&lt;body&gt;元素的底部，可以改善显示速度，因为脚本执行会拖慢显示</li></ul></li><li>外部脚本 将JS代码定义在外部JS文件中，然后引入到HTML页面中<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">script</span> src = <span class="string">&quot;xxx.js&quot;</span>&gt;&lt;\<span class="keyword">script</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>外部脚本不能包含&lt;script&gt;标签</li><li>&lt;script&gt; 标签不能自闭合<h1 id="JS-基础语法"><a href="#JS-基础语法" class="headerlink" title="JS 基础语法"></a>JS 基础语法</h1><h2 id="书写语法"><a href="#书写语法" class="headerlink" title="书写语法"></a>书写语法</h2></li></ul></li><li>区分大小写 与Java一样 变量名 函数名 以及其他一切东西都是区分大小写的</li><li>每行结尾的分号可有可无</li><li>注释<ul><li>单行  &#x2F;&#x2F;</li><li>多行  &#x2F;**&#x2F;</li></ul></li><li>大括号表示代码块<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  代码</span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h2></li><li>使用 window.alert()写入警告框</li><li>使用document.write()写入HTML输出</li><li>使用console.log()写入浏览器控制台<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li><li>JS 中用var关键字来声明变量 相当于全局变量 并且可以重复定义</li><li>JS是一门弱类型语言，变量可以存放不同类型的值<ul><li>组成字符可以是任何字母 数字 下划线 或者美元符号($)</li><li>数字不能开头</li><li>建议使用驼峰命名</li></ul></li><li>ECMAScript 6 新增let关键字来定义变量，用法类似var 但是所声明的变量只在let关键字所在的代码块内有效，且不允许重复声明</li><li>ECMAScript 6 新增了const 关键字 用来声明一个只读的常量，一旦声明，常量的值就不能改变<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2></li><li>原始类型<ul><li>number 数字(整数 小数 NaN(Not a Number))</li><li>string 字符 字符串 单双引皆可</li><li>boolean 布尔 </li><li>null 对象为空</li><li>undefined 当声明的变量未初始化时 该变量的默认值时undefined</li></ul></li></ul><p><strong>使用typeof运算符可以获取数据类型</strong></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>&#x3D;&#x3D; 会先判断数据类型 然后进行转换，在比较值，如 整数20会&#x3D;&#x3D; 字符串20</li><li>&#x3D;&#x3D;&#x3D; 不会进行类型转换，类型不一样返回false</li><li>类型转换<ul><li>字符串的字面值转成整数，如果字符串字母值时字符，会转换成NaN，布尔类型 true 1 false 0</li><li>0或者NaN会转成false 其他则为 true</li><li>空字符串转成false 其他为true</li><li>null 和 undefined都转为false<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2></li></ul></li><li>JS 函数通过function关键词进行定义 语法为<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">定义方式一</span><br><span class="line"><span class="keyword">function</span> 函数名(<span class="params">参数<span class="number">1</span>，参数<span class="number">2</span>，...</span>)&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br><span class="line">定义方式二</span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="keyword">function</span>(<span class="params">参数列表</span>)&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>形参不需要类型 因为JS时弱类型语言</li><li>返回值也不需要定义类型 可以在函数内部直接使用return返回即可</li><li>JS 中，函数调用可以传递任意个数参数<h1 id="JS-常用对象"><a href="#JS-常用对象" class="headerlink" title="JS 常用对象"></a>JS 常用对象</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2></li><li>定义<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="built_in">Array</span>（元素列表）;<span class="comment">//方式 一</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = [元素列表];<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure></li><li>访问<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[索引] <span class="operator">=</span> 值</span><br></pre></td></tr></table></figure></li></ul><p><strong>JS类似于Java集合 长度和类型都可变</strong></p><ul><li>push()  添加元素</li><li>splice() 删除<ul><li>参数一 从哪开始山</li><li>参数二 删几个</li></ul></li></ul><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_array.asp">JS Array</a></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>定义<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="built_in">String</span>(s);<span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = s；<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure></li><li>属性<ul><li>length  字符串长度</li><li>…</li></ul></li><li>方法<ul><li>charAt()  返回指定位置的字符</li><li>indexOf()   检索字符串</li><li>trim() 去除首位的空格</li><li>…</li></ul></li></ul><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_string.asp">JS String</a></p><h2 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h2><ul><li>格式<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名称 <span class="operator">=</span> &#123;</span><br><span class="line">  属性名称<span class="number">1</span>:属性值<span class="number">1</span>，</span><br><span class="line">  属性名称<span class="number">2</span>:属性值<span class="number">2</span>，</span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">  函数名称:<span class="title function_">function</span>(形参列表)&#123;&#125;</span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1></li><li>Brower Object Model 浏览器对象模型</li><li>JavaScript 将浏览器的各个组成部分封装为对象</li></ul><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><ul><li><p>Window 浏览器窗口对象</p></li><li><p>获取 直接使用window 其中window. 可以省略</p></li><li><p>属性 获取其他BOM对象</p><ul><li>history  对History 对象的只读引用</li><li>Navigator  对<a href="https://www.w3school.com.cn/jsref/obj_navigator.asp">Navigator</a>对象的只读引用</li><li>Screen  对<a href="https://www.w3school.com.cn/jsref/obj_screen.asp">Screen</a>对象的只读引用</li><li>location 用于窗口或框架的Location对象</li></ul></li><li><p>方法</p><ul><li>alert() 显示带有一段信息和一个确认按钮的警告框</li><li>confirm() 显示带有一段信息以及确认按钮和取消按钮的对话框 <ul><li>返回flag 确认为true 取消 false</li></ul></li><li>setInterval() 按照指定的周期(以毫秒计)来调用函数或计算表达式 <ul><li>参数一 function</li><li>参数二 毫秒值</li></ul></li><li>setTimeout() 在指定的毫秒数后调用函数或者计算表达式<ul><li>参数一 function</li><li>参数二 毫秒值<h2 id="History-历史记录对象"><a href="#History-历史记录对象" class="headerlink" title="History 历史记录对象"></a>History 历史记录对象</h2></li></ul></li></ul></li><li><p>History 历史记录</p></li><li><p>获取 使用window.history获取 </p></li><li><p>方法</p><ul><li>back()  加载history列表中的前一个URL</li><li>forward()  加载history列表中的下一个URL <h2 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h2></li></ul></li><li><p>Location 地址栏对象</p></li><li><p>获取 使用window.location获取</p></li><li><p>属性</p><ul><li>href  设置或返回完整的URL<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1></li></ul></li><li><p>Document Object Model 文档对象模型</p></li><li><p>将标记语言的各个组成部分封装为对象</p><ul><li>Document 整个文档对象</li><li>Element  元素对象</li><li>Attribute   属性对象</li><li>Text   文本对象</li><li>Comment   注释对象</li></ul></li><li><p>JS 通过 DOM 能对HTML进行操作</p><ul><li>改变HTML元素的内容</li><li>改变HTML元素的样式</li><li>对HTML DOM 事件做出反应</li><li>添加和删除HTML元素<h2 id="获取Element对象"><a href="#获取Element对象" class="headerlink" title="获取Element对象"></a>获取Element对象</h2></li></ul></li><li><p>获取 使用Document 对象的方法来获取</p><ul><li>getElementById 根据id值获取 返回一个Element对象</li><li>getElementByName  根据name属性值获取 返回Element对象数组</li><li>getElementByTagName 根据标签名获取 返回Element对象数组</li><li>getElementByClassName 根据class属性值获取 返回Element对象数组</li></ul></li></ul><h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><ul><li><p>事件 HTML事件是发生在HTML元素上的“事情” 例如</p><ul><li>按钮被点击</li><li>鼠标移动到元素上</li></ul></li><li><p>事件监听 JS可以在事件被侦测到时执行代码</p></li></ul><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><ul><li>方式一 通过HTML标签中的事件属性进行绑定<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">&quot;button&quot;</span> onclick = <span class="string">&#x27;on()&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">on</span><span class="params">()</span></span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;点击&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方式二 通过DOM元素属性绑定<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type<span class="operator">=</span><span class="string">&quot;button&quot;</span> id <span class="operator">=</span> <span class="string">&quot;btn&quot;</span>&gt;</span><br><span class="line">document.getElementById(<span class="string">&quot;btn&quot;</span>).onclick <span class="operator">=</span> function()&#123;</span><br><span class="line">  alert(<span class="string">&quot;点击&quot;</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h2><table><thead><tr><th>事件名</th><th>说明</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标点击事件</td></tr><tr><td>onblur</td><td>元素失去焦点</td></tr><tr><td>onfocus</td><td>元素获得焦点</td></tr><tr><td>onload</td><td>某个页面或图像被完成加载</td></tr><tr><td>onsubmit</td><td>当表单提交时触发该事件</td></tr><tr><td>onkeydown</td><td>某个键盘的键被按下</td></tr><tr><td>onmouseover</td><td>鼠标被移到某元素上</td></tr><tr><td>onmouseout</td><td>鼠标从某元素移开</td></tr></tbody></table><p><a href="https://www.w3school.com.cn/jsref/dom_obj_event.asp">DOM 事件</a></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2022/07/11/CSS/"/>
      <url>/2022/07/11/CSS/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>CSS(Cascading Style Sheet) 层叠样式表 用于控制网页表现</p></blockquote><span id="more"></span><h1 id="CSS-导入方式"><a href="#CSS-导入方式" class="headerlink" title="CSS 导入方式"></a>CSS 导入方式</h1><ul><li>内联样式 在标签内部使用style属性 属性值是css属性键值对<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> style = <span class="string">&quot;color:red&quot;</span>&gt; Hello World&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></li><li>内部样式 使用&lt;style&gt;标签 在标签内部定义css样式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span> = <span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  &lt;\style&gt;</span></span><br></pre></td></tr></table></figure></li><li>外部样式 定义link标签 引入外部的css文件<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel <span class="operator">=</span> <span class="string">&quot;stylesheet&quot;</span> href <span class="operator">=</span> <span class="string">&quot;demo.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h1></li><li>概念 选择器是选取需设置样式的元素（标签）</li><li>分类<ul><li>元素选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素名称&#123;<span class="attribute">color</span> : red;&#125;</span><br></pre></td></tr></table></figure></li><li>id 选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span>属性值&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></li><li>类选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span>属性值&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><h1 id="CSS-属性"><a href="#CSS-属性" class="headerlink" title="CSS 属性"></a>CSS 属性</h1><a href="https://www.w3school.com.cn/cssref/index.asp">CSS参考手册</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2022/07/10/HTML/"/>
      <url>/2022/07/10/HTML/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>HTML(HyperText Markup Language) 超文本标记语言，除了文字信息还可以定义图片 音频 视频等内容，HTML 运行在浏览器上，其标签由浏览器来解析</p></blockquote><span id="more"></span><h1 id="HTML-快速入门"><a href="#HTML-快速入门" class="headerlink" title="HTML 快速入门"></a>HTML 快速入门</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        页面内容</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>HTML 文件以.html 或者 .htm为扩展名</li><li>HTML标签不区分大小写</li><li>HTML 标签属性值 单双引皆可</li><li>HTML 语法松散<h1 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;h1&gt; &lt;h6&gt;</td><td>定义标题，h1最大，h2最小</td></tr><tr><td>&lt;font&gt;</td><td>定义文本的字体 字体尺寸 字体颜色</td></tr><tr><td>&lt;b&gt;</td><td>定义粗体文本</td></tr><tr><td>&lt;i&gt;</td><td>定义斜体文本</td></tr><tr><td>&lt;u&gt;</td><td>定义文本下划线</td></tr><tr><td>&lt;center&gt;</td><td>定义文本居中</td></tr><tr><td>&lt;p&gt;</td><td>定义段落</td></tr><tr><td>&lt;br&gt;</td><td>定义折行</td></tr><tr><td>&lt;hr&gt;</td><td>定义水平线</td></tr></tbody></table></li></ul><h1 id="图片-视频-音频-标签"><a href="#图片-视频-音频-标签" class="headerlink" title="图片 视频 音频 标签"></a>图片 视频 音频 标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;img&gt;</td><td>定义图片</td></tr><tr><td>&lt;audio&gt;</td><td>定义音频</td></tr><tr><td>&lt;video&gt;</td><td>定义视频</td></tr></tbody></table><ul><li><p>img 定义图片</p><ul><li>src 规定显示图片的URL(统一资源定位符)</li><li>height 定义图像的高度 尺寸单位 px 和 %</li><li>width 定义图像的宽度 尺寸单位 px 和 %</li></ul></li><li><p>audio 定义音频 支持 MP3 WAV OGG</p><ul><li>src 规定音频的URL</li><li>controls 显示播放控件</li></ul></li><li><p>video 定义视频 支持 MP4 WebM OGG</p><ul><li>src 规定视频的URL</li><li>controls 显示播放控件<h1 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;a&gt;</td><td>定义超标签，用于链接到另一个资源</td></tr></tbody></table></li></ul></li><li><p>href 指定访问资源的URL</p></li><li><p>target 指定打开资源的方式</p><ul><li>_self 默认值  在当前也页面打开</li><li>_blank 在空白页打开<h1 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;ol&gt;</td><td>定义有序列表</td></tr><tr><td>&lt;ul&gt;</td><td>定义无序列表</td></tr><tr><td>&lt;li&gt;</td><td>定义列表项</td></tr></tbody></table></li></ul></li><li><p>type 设置项目符号 <strong>不建议使用 一般在css中设置</strong></p></li><li><p>有序列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.内容    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">2.内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容 <span class="tag">&lt;/<span class="name">li</span>&gt;</span>   </span><br><span class="line">3.内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span>          </span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;/<span class="name">ol</span>&gt;</span>       </span><br></pre></td></tr></table></figure></li><li><p>无序列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">· 内容    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">· 内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容 <span class="tag">&lt;/<span class="name">li</span>&gt;</span>   </span><br><span class="line">· 内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span>          </span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">ol</span>&gt;</span>     </span><br></pre></td></tr></table></figure><h1 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;table&gt;</td><td>定义表格</td></tr><tr><td>&lt;tr&gt;</td><td>定义行</td></tr><tr><td>&lt;td&gt;</td><td>定义单元格</td></tr><tr><td>&lt;th&gt;</td><td>定义表头单元格</td></tr></tbody></table></li><li><p>table 定义表格</p><ul><li>border 规定表格边框的宽度</li><li>width 规定表格的宽度</li><li>cellspacing 规定单元格之间的空白</li></ul></li><li><p>tr 定义行</p><ul><li>align 定义表格行的内容对齐方式</li></ul></li><li><p>td 定义单元格</p><ul><li>rowspan 规定单元格可横跨的行数</li><li>colspan 规定单元格可横跨的列数</li></ul></li></ul><h1 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;div&gt;</td><td>定义HTML文档中的一个区域部分，经常与css一起使用，用来布局网页</td></tr><tr><td>&lt;span&gt;</td><td>用于组合行内元素</td></tr></tbody></table><p><strong>与CSS一起使用</strong></p><h1 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;form&gt;</td><td>定义表单</td></tr><tr><td>&lt;input&gt;</td><td>定义表单项，通过type属性控制输入形式</td></tr><tr><td>&lt;label&gt;</td><td>为表单项定义标注</td></tr><tr><td>&lt;select&gt;</td><td>定义下拉列表</td></tr><tr><td>&lt;option&gt;</td><td>定义下拉列表的列表项</td></tr><tr><td>&lt;textarea&gt;</td><td>定义文本域</td></tr></tbody></table><ul><li>表单 在网页中只要负责数据采集功能 使用&lt;form&gt;标签定义表单</li><li>表单项(元素)：不同类型的input元素，下拉列表，文本域等</li><li>form 定义表单<ul><li>action 规定当提交表单时向何处发送表单数据 URL</li><li>method 规定发送表单数据的方式<ul><li>get 浏览器会将数据直接附在表单的action URL之后，大小会有限制</li><li>post 浏览器会将数据放到http请求信息体中。大小无限制</li></ul></li></ul></li></ul><table><thead><tr><th>type取值</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>默认值 定义单行的输入字段</td></tr><tr><td>password</td><td>定义密码字段</td></tr><tr><td>radio</td><td>定义单选按钮</td></tr><tr><td>checkbox</td><td>定义复选框</td></tr><tr><td>file</td><td>定义文件上传按钮</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段</td></tr><tr><td>submit</td><td>定义提交按钮 提交按钮会把表单数据发送到服务器</td></tr><tr><td>reset</td><td>定义重置按钮 该按钮会清除表达中的所有数据</td></tr><tr><td>button</td><td>定义可点击按钮</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis---(1)</title>
      <link href="/2022/07/09/MyBatis-1/"/>
      <url>/2022/07/09/MyBatis-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>MyBatis 是一款优秀的持久层框架，用于简化JDBC开发</p></blockquote><span id="more"></span><ul><li><p>持久层</p><ul><li>负责将数据保存到数据库的那一层代码</li><li>JavaEE三层架构：表现层，业务层，持久层</li></ul></li><li><p>框架</p><ul><li>框架就是一个半成品软件，是一套可重用的，通用的 软件基础代码模型</li><li>在框架的基础之上构建软件编写更加高效 规范 通用 可扩展</li></ul></li></ul><h1 id="JDBC-缺点"><a href="#JDBC-缺点" class="headerlink" title="JDBC 缺点"></a>JDBC 缺点</h1><ul><li>硬编码        <ul><li>注册驱动，获取连接</li><li>SQL语句</li></ul></li><li>操作繁琐<ul><li>手动设置参数</li><li>手动封装结果集</li></ul></li></ul><p><strong>MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作，硬编码可通过配置文件的方式完成</strong></p><h1 id="MyBatis-快速入门"><a href="#MyBatis-快速入门" class="headerlink" title="MyBatis 快速入门"></a>MyBatis 快速入门</h1><h2 id="查询表中所有数据"><a href="#查询表中所有数据" class="headerlink" title="查询表中所有数据"></a>查询表中所有数据</h2><ul><li>创建表  添加数据</li><li>创建模块 导入坐标</li><li>编写MyBatis 核心配置文件 –&gt; 替换连接信息 解决硬编码问题</li><li>编写SQL映射文件 –&gt; 统一管理sql语句 解决硬编码问题</li><li>编码<ul><li>定义POJO类</li><li>加载核心配置文件，获取SqlSessionFactory 对象</li><li>获取SqlSession 对象，执行SQL语句</li><li>释放资源<h2 id="解决SQL映射文件的警告提示"><a href="#解决SQL映射文件的警告提示" class="headerlink" title="解决SQL映射文件的警告提示"></a>解决SQL映射文件的警告提示</h2></li></ul></li><li>产生原因：Idea和数据库没有建立连接 不识别表信息</li><li>解决方式；在Idea中配置MySQL数据库连接 <h1 id="Mapper-代理开发"><a href="#Mapper-代理开发" class="headerlink" title="Mapper 代理开发"></a>Mapper 代理开发</h1></li><li>目的<ul><li>解决原生方式的硬编码</li><li>简化后期执行SQL<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2></li></ul></li><li>定义与SQL映射文件同名的Mapper接口，并将Mapper接口的SQL映射文件放置在同一目录下</li><li>设置SQL映射文件的namespace属性为Mapper接口全限定名</li><li>在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致</li><li>编码<ul><li>通过SqlSession的getMapper方法获取Mapper接口的代理对象</li><li>通过对应方法完成sql的执行</li></ul></li></ul><p><strong>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载</strong></p><h1 id="Mybatis-核心配置文件"><a href="#Mybatis-核心配置文件" class="headerlink" title="Mybatis 核心配置文件"></a>Mybatis 核心配置文件</h1><p><a href="https://mybatis.net.cn/configuration.html">MyBatis官方文档</a></p><h1 id="配置文件完成增删改查"><a href="#配置文件完成增删改查" class="headerlink" title="配置文件完成增删改查"></a>配置文件完成增删改查</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kris.dao.AccountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kris.domain.Account&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        select * from tb_account;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>id 执行sql的唯一标识  mybatis根据id 来找到需要执行的sql语句 可以自定义   建议使用接口中的方法名定义</li><li>resultType 表示结果类型 是sql 得到的ResultSet 遍历这个Result得到的java对象类型  写的是类型的全限定名称</li><li><a href="http://mybatis.org/dtd/mybatis-3-mapper.dtd">http://mybatis.org/dtd/mybatis-3-mapper.dtd</a>    约束文件</li><li>namespace 命名空间 dao接口的全限定名称</li></ul><h2 id="查询映射"><a href="#查询映射" class="headerlink" title="查询映射"></a>查询映射</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>resultMap id<span class="operator">=</span>&quot;无要求&quot; type<span class="operator">=</span>&quot;封装类名&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="comment">-- id 是主键字段的映射</span></span><br><span class="line">    <span class="comment">-- result 是其他字段的映射</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">result</span> <span class="keyword">column</span><span class="operator">=</span>&quot;列名&quot; property<span class="operator">=</span>&quot;别名&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">result</span> <span class="keyword">column</span><span class="operator">=</span>&quot;列名&quot; property<span class="operator">=</span>&quot;别名&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>resultMap<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;selectOne&quot; resultMap<span class="operator">=</span>&quot;无要求&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h2 id="MyBatisX插件"><a href="#MyBatisX插件" class="headerlink" title="MyBatisX插件"></a>MyBatisX插件</h2><blockquote><p>MyBatisX 是一款基于IDEA的快速开发插件 为效率而生</p></blockquote><ul><li>功能<ul><li>XML 和接口方法相互跳转</li><li>根据接口方法生成statement</li><li>安装<blockquote><p>在IDEA中的Plugin中搜索即可</p></blockquote></li></ul></li></ul><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ul><li>在定义的Mapper接口中写出需要实现的接口映射</li><li>利用插件的快捷方式在xml文件中编写对应的sql语句</li><li>id 需要与 接口名字相同</li><li>参数接收<ul><li>#{}   会将其替换为？，防止SQL注入</li><li>${}  拼sql 会有SQL注入问题</li></ul></li><li>转义<ul><li>CDATA 区  会将区域内的当作纯文本处理    CD提示</li><li>查询对应字符在xml的转义</li></ul></li><li>多个参数的接受<ul><li>散装参数：使用@Param(“SQL参数占位符名称”)</li><li>对象参数 对象的属性名称要和参数占位符名称一致</li><li>map map的key值要与参数占位符名称一致</li></ul></li><li>使用where 标签 并且 条件前都得加上and</li><li>默认开启事务 需要手动提交</li><li>获取主键id  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">useGeneratedKeys</span> <span class="operator">=</span> </span><br><span class="line">true<span class="string">&quot; keyProperty = &quot;</span>id<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li><li>删除 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delete <span class="keyword">from</span> 表名 <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (</span><br><span class="line">    &lt;foreach collection = <span class="string">&quot;arrays(或者用Param注解改变名称)&quot;</span> <span class="built_in">item</span> = <span class="string">&quot;id&quot;</span> separator=<span class="string">&quot;,&quot;</span>(分隔符)&gt;</span><br><span class="line">    <span class="comment">#&#123;id&#125;</span></span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h1 id="注解完成增删改查"><a href="#注解完成增删改查" class="headerlink" title="注解完成增删改查"></a>注解完成增删改查</h1><blockquote><p>注解用来完成简单的工作  配置文件用来完成复杂的工作</p></blockquote><ul><li>查询 @Select</li><li>添加 @Insert</li><li>修改 @Update</li><li>删除 @Delete<h1 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h1><a href="https://mybatis.net.cn/dynamic-sql.html">MyBatis官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven---(1)</title>
      <link href="/2022/07/08/Maven-1/"/>
      <url>/2022/07/08/Maven-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Apache Maven 是一个项目管理和构建工具，基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建，报告和文档</p></blockquote><span id="more"></span><ul><li>提供了一套标准的项目结构<blockquote><p>在不同的IDE中的项目结构并不相同，Maven提供了一套标准化的项目，以便在不同的IDE中通用</p></blockquote></li><li>提供了一套标准化的构建流程(编译，测试，打包，发布…)</li><li>提供了一套依赖管理机制<blockquote><p>依赖管理就是管理你项目所依赖的第三方资源(jar包。插件…)</p></blockquote></li></ul><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><ul><li><a href="http://maven.apache.org/">官网</a></li><li><a href="http://maven.apache.org/download.cgi">下载地址</a></li><li>解压 apache-maven-3.6.1.rar 即安装完成</li><li>配置环境变量 MAVEN_HOME 为安装路径的bin目录</li><li>配置本地仓库：修改conf&#x2F;settings.xml中的&lt;localRepository&gt;为一个指定目录</li><li>配置阿里云私服，修改conf&#x2F;settings.xml中的&lt;mirrors&gt;标签，为其添加如下子标签<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>compile 编译</li><li>clean 清理</li><li>test 测试</li><li>package 打包</li><li>install 安装<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2></li><li>Maven 构建项目生命周期描述是一次构建过程经历经历了多少个事件</li><li>Maven 对项目构建的生命周期划分为3套<ul><li>clean 清理工作</li><li>default 核心工作 例如编译 测试 打包 安装等</li><li>site 产生报告 发布站点</li></ul></li></ul><p><strong>同一生命周期内，执行后边的命令，前边的所有命令会自动执行</strong></p><h1 id="IDEA-配置Maven"><a href="#IDEA-配置Maven" class="headerlink" title="IDEA 配置Maven"></a>IDEA 配置Maven</h1><h2 id="IDEA-配置Maven-环境"><a href="#IDEA-配置Maven-环境" class="headerlink" title="IDEA 配置Maven 环境"></a>IDEA 配置Maven 环境</h2><ul><li>选择 IDEA 中 File –&gt; Settings</li><li>搜索 maven</li><li>设置 IDEA 使用本地安装的Maven，并修改配置文件路径<h2 id="Maven-坐标详解"><a href="#Maven-坐标详解" class="headerlink" title="Maven 坐标详解"></a>Maven 坐标详解</h2></li><li>什么是坐标 <ul><li>Maven 中的坐标是资源的唯一标识</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul></li><li>Maven 坐标主要组成<ul><li>groupId 定义当前Maven项目隶属组织名称(通常是域名反写 如: com.itheima)</li><li>artifactId 定义当前Maven项目名称(通常是模块名称 如 order-service goods-service)</li><li>version 定义当前项目版本号</li></ul></li></ul><h2 id="IDEA-创建-Maven-项目"><a href="#IDEA-创建-Maven-项目" class="headerlink" title="IDEA 创建 Maven 项目"></a>IDEA 创建 Maven 项目</h2><ul><li>创建模块 选择Maven 点击Next</li><li>填写模块名称 坐标信息 点击finish 创建完成</li><li>编写程序<h2 id="IDEA-导入-Maven-项目"><a href="#IDEA-导入-Maven-项目" class="headerlink" title="IDEA 导入 Maven 项目"></a>IDEA 导入 Maven 项目</h2></li><li>选择右侧Maven面板 点击 + 号</li><li>选中对应项目的pom.xml文件，双击即可</li><li>如果没有Maven面板 选择View -&gt; Appearance -&gt; Tool Window Bars</li></ul><h2 id="配置Maven-Helper-插件"><a href="#配置Maven-Helper-插件" class="headerlink" title="配置Maven-Helper 插件"></a>配置Maven-Helper 插件</h2><ul><li>选择IDEA 中 File -&gt; Settings</li><li>选择 Plugins</li><li>搜索 Maven</li><li>安装 Maven Helper </li><li>重启IDEA</li></ul><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><h2 id="使用坐标导入jar包"><a href="#使用坐标导入jar包" class="headerlink" title="使用坐标导入jar包"></a>使用坐标导入jar包</h2><ul><li>在pom.xml 中编写&lt;dependencies&gt;标签</li><li>在&lt;dependencies&gt; 标签中使用&lt;dependency&gt;引入坐标</li><li>定义坐标的 groupId artifactId version</li><li>点击刷新按钮 使坐标生效<h2 id="使用坐标导入jar包-快捷方式"><a href="#使用坐标导入jar包-快捷方式" class="headerlink" title="使用坐标导入jar包 -快捷方式"></a>使用坐标导入jar包 -快捷方式</h2></li><li>在pom.xml 中按alt + insert，选择Dependency</li><li>在弹出的面板中搜索对应坐标，双击选中</li><li>点击刷新按钮 使坐标生效</li></ul><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><ul><li><p>通过设置坐标的依赖范围(scope)，可以设置对jar包的作用范围：编译环境 测试环境 运行环境</p><table><thead><tr><th>依赖范围</th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例子</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td>system</td><td>Y</td><td>Y</td><td>-</td><td>存储在本地的jar包</td></tr></tbody></table></li><li><p>&lt;scope&gt; 默认值  compile</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2022/07/07/JDBC-1/"/>
      <url>/2022/07/07/JDBC-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>JDBC (Java DataBase Connectivity) 就是使用Java语言操作数据库的一套API</p></blockquote><span id="more"></span><h1 id="JDBC-快速入门"><a href="#JDBC-快速入门" class="headerlink" title="JDBC 快速入门"></a>JDBC 快速入门</h1><ul><li>创建工程，导入jar包</li><li>注册驱动<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获取连接<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = <span class="module-access"><span class="module"><span class="identifier">DriverManager</span>.</span></span>get<span class="constructor">Connection(<span class="params">url</span>,<span class="params">usename</span>,<span class="params">password</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>定义SQL语句<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql <span class="operator">=</span> <span class="string">&quot;update...&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>获取执行SQL对象<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt conn.createStatement()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>执行SQL<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt.execute<span class="constructor">Update(<span class="params">sql</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>处理返回结果</li><li>释放资源</li></ul><h1 id="API-详解"><a href="#API-详解" class="headerlink" title="API 详解"></a>API 详解</h1><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><ul><li>作用<ul><li>注册驱动<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">-- Driver 类源码</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="type">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>MYSQL 5之后的驱动包，可以省略注册驱动的步骤，会自动加载jar包中META-INF&#x2F;services&#x2F;java.sql.Driver文件中的驱动类</strong></li><li>获取数据库连接<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Connection   <span class="title">getConnection</span><span class="params">(<span class="type">String</span> url,<span class="type">String</span> user,<span class="type">String</span> password)</span></span></span><br></pre></td></tr></table></figure><ul><li>url : 连接路径<blockquote><p>语法：jdba:mysql:&#x2F;&#x2F;ip地址（域名）:端口号&#x2F;数据库名称？参数键值对1&amp;参数键值对2…<br><br>示例:jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;kris<br><br>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称？键值对<br>配置useSSL &#x3D; false 参数，禁用安全连接方式，解决警告提示</p></blockquote></li><li>user ：用户名</li><li>password ：密码</li></ul></li></ul></li></ul><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ul><li>作用<ul><li>获取执行SQL的对象<ul><li>执行普通SQL对象  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Statement</span> <span class="function"><span class="title">createStatement</span>()</span></span><br></pre></td></tr></table></figure></li><li>预编译SQL的执行SQL对象：防治SQL注入  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">PreparedStatement</span> <span class="function"><span class="title">prepareStatement</span>(<span class="variable">sql</span>)</span></span><br></pre></td></tr></table></figure></li><li>执行存储过程的对象  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">CallableStatement</span> <span class="function"><span class="title">prepareCall</span>(<span class="variable">sql</span>)</span></span><br></pre></td></tr></table></figure></li></ul></li><li>管理事务<ul><li>MYSQL 事务管理  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启事务：begin<span class="comment">;</span></span><br><span class="line">提交事务：commit<span class="comment">;</span></span><br><span class="line">回滚事务：rollback<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">MYSQL自动提交事务</span><br></pre></td></tr></table></figure></li><li>JDBC 事务管理  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启事务：<span class="function"><span class="title">setAutoCommit</span>(<span class="variable">boolean</span> <span class="variable">autoCommit</span>):<span class="variable"><span class="literal">true</span></span>为自动提交，<span class="variable"><span class="literal">false</span></span>为手动提交，即为开始事务</span></span><br><span class="line"><span class="function">提交事务：<span class="title">commit</span>()</span></span><br><span class="line">回滚事务：<span class="function"><span class="title">rollback</span>()</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><ul><li>作用<ul><li>执行SQL语句<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> execute<span class="constructor">Update(<span class="params">sql</span>)</span>; <span class="comment">//执行DML DDL语句</span></span><br><span class="line">返回值：<span class="number">1</span> DML语句影响的行数 <span class="number">2</span> DDL语句执行后，执行成功也可能返回<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ResultSet</span> executeQuery(sql): 执行DQL语句</span><br><span class="line">返回值：<span class="keyword">ResultSet</span> 结果集对象</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><ul><li>作用<ul><li>封装了DQL查询语句的结果<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet stmt.execute<span class="constructor">Query(<span class="params">sql</span>)</span>; <span class="comment">//执行DQL语句，返回ResultSet对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li>获取查询结果<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">boolean</span> <span class="keyword">next</span>(): <span class="number">1</span> 将光标从当前位置向前移动一行 <span class="number">2</span> 判断当前行是否为有效行</span><br><span class="line">返回值</span><br><span class="line">  <span class="literal">true</span> ：有效行，当前行有数据</span><br><span class="line">  <span class="literal">false</span> ： 无效行，当前行没有数据</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xxx getXxx(参数)  <span class="comment">//获取数据</span></span><br><span class="line">  xxx 数据类型 如<span class="built_in">int</span> getInt（参数）</span><br><span class="line">  参数  </span><br><span class="line">      <span class="built_in">int</span> 列的编号 从<span class="number">1</span>开始</span><br><span class="line">      <span class="built_in">String</span> 列的名称</span><br></pre></td></tr></table></figure></li></ul><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><ul><li><p>作用</p><ul><li>预编译SQL语句并执行：预防SQL注入问题</li></ul></li><li><p>SQL注入</p><ul><li>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</li></ul></li><li><p>获取 PreparedStatement 对象</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">SQL</span> 语句中的参数值，使用？占位符替代</span><br><span class="line">String <span class="keyword">sql</span> = &quot;select * from username = ? and password = ?&quot;;</span><br><span class="line"></span><br><span class="line">//通过<span class="keyword">Connection</span> 对象获取，并传入对应的<span class="keyword">SQL</span>语句</span><br><span class="line">PreparedStatement pstmt = conn.prepareStatement(<span class="keyword">sql</span>);</span><br></pre></td></tr></table></figure></li><li><p>设置参数值</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement对象：<span class="keyword">set</span>Xxx（参数1，参数2）：给 ？ 赋值</span><br><span class="line">Xxx：数据类型</span><br><span class="line">参数：</span><br><span class="line">  参数1：？的位置编号，从1开始</span><br><span class="line">  参数2：？的值</span><br></pre></td></tr></table></figure></li><li><p>执行SQL</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executeUpdate<span class="comment">()</span>;/executeQuery<span class="comment">()</span>; : 不需要再传递SQL</span><br></pre></td></tr></table></figure></li><li><p>好处</p><ul><li>预编译SQL 性能更高</li><li>防止SQL注入，将敏感字符转义</li></ul></li><li><p>原理</p><ul><li>在获取PreparedStatement对象时，将SQL语句发送给MYSQL服务器进行检查，编译</li><li>执行时就不用再进行这些步骤，速度更快</li><li>如果SQL模板一样，则只需要进行一次检查，编译</li></ul></li></ul><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul><li>数据库连接池是个容器，负责分配，管理数据库连接</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</li><li>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</li><li>好处<ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li></ul><h2 id="数据库连接池实现"><a href="#数据库连接池实现" class="headerlink" title="数据库连接池实现"></a>数据库连接池实现</h2><ul><li>标准接口 ：DataSource<ul><li>官方(SUN)提供的数据库连接池标准接口，由第三方组织实现此接口。</li><li>功能： 获取连接<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Connection</span> <span class="function"><span class="title">getConnection</span>()</span></span><br></pre></td></tr></table></figure></li></ul></li><li>常见的数据库连接池：<ul><li>D8CP</li><li>C3P0</li><li>Druid</li></ul></li><li>Druid(德鲁伊)<ul><li>Druid连接池是阿里巴巴开源的数据库连接池项目</li><li>功能强大，性能优秀，是Java语言最好的数据库连接池之一</li></ul></li></ul><h2 id="Druid-使用步骤"><a href="#Druid-使用步骤" class="headerlink" title="Druid 使用步骤"></a>Druid 使用步骤</h2><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//druid.properties</span><br><span class="line"><span class="attribute">driverClassName</span> <span class="operator">=</span> com.mysql.jdbc.Driver</span><br><span class="line"><span class="attribute">url</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="attribute">username</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="attribute">password</span> <span class="operator">=</span> ...</span><br><span class="line">//初始话连接数量</span><br><span class="line"><span class="attribute">initialSize</span> <span class="operator">=</span> ...</span><br><span class="line">//最大连接数量</span><br><span class="line"><span class="attribute">maxActive</span> <span class="operator">=</span> ...</span><br><span class="line">// 最大等待时间</span><br><span class="line"><span class="attribute">maxWait</span> <span class="operator">=</span> ...</span><br></pre></td></tr></table></figure></li><li>加载配置文件<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>));</span><br></pre></td></tr></table></figure></li><li>获取数据库连接池对象<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = <span class="module-access"><span class="module"><span class="identifier">DruidDataSourceFactory</span>.</span></span>create<span class="constructor">DataSource(<span class="params">prop</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获取连接<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection <span class="operator">=</span> dataSource.getConnection()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL---(3)</title>
      <link href="/2022/07/06/MYSQL-3/"/>
      <url>/2022/07/06/MYSQL-3/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>  SQL（Structured Query Language）,结构化查询语言，一门操作关系型数据库的编程语言，定义操作所有<a href="https://cn.bing.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&qs=SC&pq=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&sk=SC1&sc=8-6&cvid=959A8ABF9CB1416DB320362EC1B3BA5A&FORM=QBRE&sp=2">关系型数据库</a>的统一标准。不同数据库操作的方式可能存在一些不一样的地方</p><span id="more"></span><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>约束是作用于表中列上的规则，用于限制加入表的数据</li><li>约束的存在保证了数据库中数据的正确性，有效性和完整性</li></ul><h2 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h2><table><thead><tr><th>约束名称</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>保证列中数据不能有null值</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证列中所有数据各不相同</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>检查约束</td><td>保证列中的值满足某一条件</td><td>CHECK</td></tr><tr><td>默认约束</td><td>保存数据时，未指定值则采用默认值</td><td>DEFAULT</td></tr><tr><td>外键约束</td><td>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>MYSQL不支持检查约束</li><li>多个约束并排写中间空格</li><li>auto_increment 自增长 (当列是数字并且唯一约束)</li></ul><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3></li><li>添加约束  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加外键约束</span></span><br><span class="line">creat <span class="keyword">table</span> 表名(</span><br><span class="line">列名 数据类型;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key(外键列名) refereinces 主表(主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表后添加外键约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key （外键字段名称） <span class="keyword">references</span> 主表名称（主表列名称）;</span><br></pre></td></tr></table></figure></li><li>删除约束  <figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> 外键名称;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h3><ul><li>先建主表后建从表才能添加外键</li><li>外键名称一般为fk开头链接两关联主表的字段名称</li></ul><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ul><li>根据业务系统的具体需求，结合所选用的DBMS，为这个业务系统构造出最优的数据存储模型。</li><li>建立数据库中的表结构以及表与表之间的关联关系的过程。</li></ul><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><ul><li>需求分析 </li><li>逻辑分析</li><li>物理设计</li><li>维护设计</li></ul><h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h2><ul><li>一对一<ul><li>用户和用户详情</li><li>用于表拆分和提升查询性能</li><li><strong>实现方式</strong>：唯一外键</li></ul></li><li>一对多<ul><li>部门和员工</li><li><strong>实现方式</strong> ： 在多的一方建立外键，指向一的一方的主键</li></ul></li><li>多对多<ul><li>商品和订单</li><li><strong>实现方式</strong> ： 建立第三张中间表，中间表至少包含两个外键，分别对应两方主键</li></ul></li></ul><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><pre><code>相当于查询A B表交集数据</code></pre><ul><li><p>语法</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式内连接</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>，表<span class="number">2.</span>.. <span class="keyword">where</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示外连接</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> [<span class="keyword">inner</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3></li><li><p>语法</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 左外连接</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件;</span><br><span class="line"></span><br><span class="line">-- 右外连接</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure></li><li><p>左外连接</p><blockquote><p>相当于查询A表所有数据和交集部分数据</p></blockquote></li><li><p>右外连接</p><blockquote><p>相当于查询B表所有数据和交集部分数据</p></blockquote><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2></li><li><p>概念</p><blockquote><p>查询中嵌套查询 称为子查询</p></blockquote></li><li><p>根据查询结果不同，作用不同</p><ul><li>单行单列  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表 <span class="keyword">where</span> 字段名 = （子查询）;</span><br></pre></td></tr></table></figure></li><li>多行单列  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表 <span class="keyword">where</span> 字段名 <span class="keyword">in</span> （子查询）;</span><br></pre></td></tr></table></figure></li><li>多行多列 ： 作为虚拟表  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> （子查询） <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>数据库的事务(Transaction) 是一种机制 一个操作序列，包含了一组数据库操作命令</li><li>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败</li><li>事务是一个不可分割的工作逻辑单元</li></ul><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 回滚事务 </span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h2 id="事务的四大特征"><a href="#事务的四大特征" class="headerlink" title="事务的四大特征"></a>事务的四大特征</h2><ul><li>原子性(Atomictity): 事务是不可分割的最小操作单位，要么同时成功，要么同时失败</li><li>一致性(Consistency): 事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性(Isolation): 多个事务之间，操作的可见性</li><li>持久性(Durability): 事务一但提交或回滚，它对数据库中的数据的该表就是永久的</li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL---(2)</title>
      <link href="/2022/07/05/MYSQL-2/"/>
      <url>/2022/07/05/MYSQL-2/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>  SQL（Structured Query Language）,结构化查询语言，一门操作关系型数据库的编程语言，定义操作所有<a href="https://cn.bing.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&qs=SC&pq=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&sk=SC1&sc=8-6&cvid=959A8ABF9CB1416DB320362EC1B3BA5A&FORM=QBRE&sp=2">关系型数据库</a>的统一标准。不同数据库操作的方式可能存在一些不一样的地方</p><span id="more"></span><h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><blockquote><p>Data Query Language 数据查询语言，用于查询数据库中表的数据</p></blockquote><h2 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  字段列表</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  表名列表</span><br><span class="line"><span class="keyword">where</span>      <span class="comment">-- 条件查询 </span></span><br><span class="line">  条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>   <span class="comment">--分组查询</span></span><br><span class="line">  分组字段</span><br><span class="line"><span class="keyword">having</span> </span><br><span class="line">  分组后条件</span><br><span class="line">orded <span class="keyword">by</span>   <span class="comment">--排序查询</span></span><br><span class="line">  排序字段</span><br><span class="line"><span class="keyword">limit</span>      <span class="comment">--分页查询</span></span><br><span class="line">  分页限定</span><br></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><ul><li>去除重复记录<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> distinct <span class="params">...</span> from <span class="params">...</span></span><br></pre></td></tr></table></figure></li><li>起别名<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 <span class="keyword">as</span> （可省略用空格隔开） 别名</span><br></pre></td></tr></table></figure></li></ul><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ul><li><p>语法</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span>条件列表;</span><br></pre></td></tr></table></figure></li><li><p>条件</p><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>between…and…</td><td>在某个范围之间</td></tr><tr><td>in(…)</td><td>多选一</td></tr><tr><td>like 占位符</td><td>模糊查询，_表示任意单个字符，%表示多个任意字符</td></tr><tr><td>is NULL</td><td>是NULL</td></tr><tr><td>is not NULL</td><td>不是NULL</td></tr><tr><td>and</td><td>并且</td></tr><tr><td>or</td><td>或者</td></tr><tr><td>nor</td><td>非</td></tr></tbody></table></li></ul><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><ul><li><p>语法</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 排序字段名<span class="number">1</span> 排序方式<span class="number">1</span>，...;</span><br></pre></td></tr></table></figure></li><li><p>排序方式</p><ul><li>ASC : 升序排列 （默认）</li><li>DESC : 降序排列</li></ul><p><em><strong>如果有多个排序条件，当前边条件值一样时，才根据第二条件进行排序</strong></em></p></li></ul><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ul><li>语法<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 分组前条件限定] <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名 [<span class="keyword">having</span> 分组后条件过滤];</span><br></pre></td></tr></table></figure><strong>分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</strong></li></ul><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><blockquote><p>将一列数据作为一个整体，进行纵向计算</p></blockquote><ul><li><p>分类</p><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>count(列名)</td><td>统计数量(一般选用不为null的列)</td></tr><tr><td>max(列名)</td><td>最大值</td></tr><tr><td>min(列名)</td><td>最小值</td></tr><tr><td>sum(列名)</td><td>求和</td></tr><tr><td>avg(列名)</td><td>平均值</td></tr></tbody></table></li><li><p>语法</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 聚合函数名（列名） <span class="keyword">from</span> 表;</span><br></pre></td></tr></table></figure></li></ul><p><em><strong>null值不参与所有聚合函数运算</strong></em></p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ul><li>语法<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">limit</span> 起始索引，查询条目数;</span><br></pre></td></tr></table></figure><strong>起始索引从0开始</strong><br><strong>计算公式：起始索引 &#x3D; （当前页码-1）* 每页显示的条数</strong></li><li>tips<ul><li>分页查询limit是MYSQL数据库特有</li><li>Oracle 分页查询使用 rownumber</li><li>SQL Sever 使用top</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL---(1)</title>
      <link href="/2022/07/04/MYSQL-1/"/>
      <url>/2022/07/04/MYSQL-1/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>  SQL（Structured Query Language）,结构化查询语言，一门操作关系型数据库的编程语言，定义操作所有<a href="https://cn.bing.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&qs=SC&pq=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&sk=SC1&sc=8-6&cvid=959A8ABF9CB1416DB320362EC1B3BA5A&FORM=QBRE&sp=2">关系型数据库</a>的统一标准。不同数据库操作的方式可能存在一些不一样的地方</p><span id="more"></span><h1 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h1><ul><li><p>SQL语句可以多行或者单行书写，以分号结尾。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">database</span>;   </span><br></pre></td></tr></table></figure></li><li><p>MySQL 数据库的SQL语句不区分大小写，关键字建议大写</p></li><li><p>注释</p><ul><li>单行注释： – 注释内容 或者 #注释内容（MYSQL特有）</li><li>多行注释：&#x2F;* 注释 *&#x2F;</li></ul></li></ul><h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><blockquote><p>Data Definition Language  数据定义语言，用来定义数据库对象；数据库，表，列等</p></blockquote><h2 id="操作库"><a href="#操作库" class="headerlink" title="操作库"></a>操作库</h2><ul><li><p>查询</p>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据库</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>创建数据库（判断，如果不存在则创建）</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>删除数据库</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>查看当前使用的数据库</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">database</span>()</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用数据库</p>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名称<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><ul><li>查询表<ul><li>查询当前数据库下所有表名称  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure></li><li>查询表结构  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名称</span><br></pre></td></tr></table></figure></li></ul></li><li>创建表  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    字段名<span class="number">1</span> 数据类型<span class="number">1</span>，</span><br><span class="line">    字段名<span class="number">2</span> 数据类型<span class="number">2</span>，</span><br><span class="line">    <span class="comment">----</span></span><br><span class="line">    字段名n 数据类型n  <span class="comment">/*最后不加逗号*/</span></span><br><span class="line">)；</span><br></pre></td></tr></table></figure></li><li>删除表  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> 表名称;</span><br></pre></td></tr></table></figure></li><li>修改表<ul><li>修改表名  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">rename</span> <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure></li><li>添加一列  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 数据类型;</span><br></pre></td></tr></table></figure></li><li>修改数据类型  <figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 列名 新数据类型;</span><br></pre></td></tr></table></figure></li><li>修改列名和数据类型  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter <span class="keyword">table</span> 表名 change 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure></li><li>删除列  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><blockquote><p>Data Manipulation Language 数据操作语言，是指在SQL语言中，负责对数据库对象运行数据访问工作的指令集。</p></blockquote><ul><li>添加数据<ul><li>给指定列表添加数据  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">insert</span> into 表名（列名<span class="number">1</span>，列名<span class="number">2</span>，...） values(值<span class="number">1</span>，值<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li>给全部列添加数据  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span> ...);<span class="comment">-- 按照列的顺序添加值;</span></span><br></pre></td></tr></table></figure></li><li>批量添加数据  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">insert</span> into 表名(列<span class="number">1</span>，列<span class="number">2</span>，...) values(值<span class="number">1</span>，值<span class="number">2</span>，...),(值<span class="number">1</span>，值<span class="number">2</span>，...)...;</span><br><span class="line"></span><br><span class="line"><span class="attribute">insert</span> into 表名 values(值<span class="number">1</span>，值<span class="number">2</span>...),(值<span class="number">1</span>，值<span class="number">2</span>...);</span><br></pre></td></tr></table></figure></li></ul></li><li>修改数据  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 <span class="keyword">set</span> 列名<span class="number">1</span> = 值<span class="number">1</span>，列名<span class="number">2</span> = 值<span class="number">2</span>，...[<span class="keyword">where</span> 条件]<span class="punctuation">;</span><span class="comment">(***不加条件，所有数据都会修改！***)</span></span><br></pre></td></tr></table></figure></li><li>删除数据  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]<span class="punctuation">;</span><span class="comment">(***不加则所有数据都会被删除***)</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 注解</title>
      <link href="/2022/05/07/Java-%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/05/07/Java-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是注解-Annotation"><a href="#什么是注解-Annotation" class="headerlink" title="什么是注解(Annotation)"></a>什么是注解(Annotation)</h1><blockquote><p>代码的特殊标识，可以在编译，类加载，运行时被读取，并执行相对应的处理，以便于其他工具补充信息或者进行部署</p></blockquote><span id="more"></span><h1 id="内注解"><a href="#内注解" class="headerlink" title="内注解"></a>内注解</h1><ul><li><p>@Override - 检查该方法是否是重写方法，如果发现其父类，或者是应用的接口中并没有该方法时，会报编译错误</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//将会报编译错误</span></span><br><span class="line">    void say()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Deprecated - 标记过时方法。如果使用该方法，将会报编译警告</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">     son s = <span class="keyword">new</span> <span class="title function_">son</span>();</span><br><span class="line">     <span class="comment">//使用时会显示已废弃 </span></span><br><span class="line">     s.<span class="title function_">say</span>();</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@SuppressWarnings - 指示编译器忽略注解中声明的警告 该注解需要传入参数</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">    deprecation:</span> 使用了不赞成使用的类或方法时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    unchecked:</span> 执行了未检查的转换时的警告，例如当使用了集合时没有用泛型(Generics)来指定集合保存的类型</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    fallthrough:</span> 当switch程序块直接通往下一种情况而没有使用break时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    path:</span> 在类路径 源文件路径等中有不存在的路径时的警告</span><br><span class="line"><span class="symbol">   </span></span><br><span class="line"><span class="symbol">    serial:</span> 当在可序列化的类上缺少serialVersionUID定义时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    finally:</span> 任何finally子句不能正常完成时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    all:</span> 关于以上所有情况的警告</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">// 消除了age没有使用的警告</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">son</span>();</span><br><span class="line">    s.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><blockquote><p>作用在其他注解的注解</p></blockquote><ul><li><p>@Retention - 标识这个注解如何保存，是在代码中，还是编译进class中，或者实在运行时可以通过反射访问</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation</span><br><span class="line"><span class="keyword">public</span> enum RetentionPolicy &#123;</span><br><span class="line">   <span class="comment">//Annotation信息仅存在于编译器处理期间</span></span><br><span class="line">   <span class="comment">//编译器处理完之后就没有该Annotation信息</span></span><br><span class="line">    <span class="keyword">SOURCE</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Annotation信息存储于类对应的class文件之中 (默认)</span></span><br><span class="line">    <span class="keyword">CLASS</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Annotation信息存储于class文件中，并且可由JVM读入</span></span><br><span class="line">    <span class="keyword">RUNTIME</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Documented - 标记这个注解是否包含在用户文档中</p></li><li><p>Target - 标记这个注解一个是哪种java成员</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package java.lang.annotation</span><br><span class="line">public enum ElementType &#123;</span><br><span class="line">      <span class="regexp">//</span>类，接口(包括注释类型) 枚举 </span><br><span class="line">      TYPE,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>字段声明(包括枚举变量)</span><br><span class="line">      FIELD,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>方法声明</span><br><span class="line">      METHOD,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>参数声明</span><br><span class="line">      PARAMETER,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>构造方法声明</span><br><span class="line">      CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>局部变量声明</span><br><span class="line">      LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>注释类型声明</span><br><span class="line">      ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>包声明</span><br><span class="line">      PACKAGE,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>@Inherited - 标记这个注解是继承于哪个注解类(默认注解并没有继承于任何子类)</p></li></ul><h1 id="Annotation的通用定义"><a href="#Annotation的通用定义" class="headerlink" title="Annotation的通用定义"></a>Annotation的通用定义</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Target</span>(ElementType TYPE)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> MyAnnotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@interface 使用@interface 定义注解时，意味着它实现了java.lang.annotation.Annotation 接口，即该注解就是一个Anonotation<br></li><li>定义注解时，@interface 时必须的</li><li>Annotation 接口的实现细节都由编译器完成 通过@interface 定义注解后，该注解不能继承其他注解或接口</li></ul><h1 id="新增接口-java-7-后"><a href="#新增接口-java-7-后" class="headerlink" title="新增接口(java 7 后)"></a>新增接口(java 7 后)</h1><ul><li>SafeVarargs - 忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告</li><li>FunctionalInterface - 标识一个匿名函数或者函数式接口</li><li>Repeatable - 标识某注解可以在同一个声明上使用多次</li></ul><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://www.runoob.com/w3cnote/java-annotation.html">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射</title>
      <link href="/2022/05/04/Java-%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/05/04/Java-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射概述（Reflection）"><a href="#反射概述（Reflection）" class="headerlink" title="反射概述（Reflection）"></a>反射概述（Reflection）</h1><blockquote><p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。</p></blockquote><span id="more"></span><h1 id="反射机制的作用"><a href="#反射机制的作用" class="headerlink" title="反射机制的作用"></a>反射机制的作用</h1><blockquote><ul><li>在运行程序时构造任意一个已知类名称的对象</li><li>在运行时获取或调用类的属性和方法</li><li>生成动态代理</li></ul></blockquote><h2 id="获取类名的三种方式"><a href="#获取类名的三种方式" class="headerlink" title="获取类名的三种方式"></a>获取类名的三种方式</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">package</span> test01;</span><br><span class="line">    <span class="keyword">class</span> test&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">//第一种 通过对象的getClass()方法        Person p1 = new Person();</span></span><br><span class="line">        <span class="keyword">Class</span> c1 = p1.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种 通过类名.class的方式得到，最安全，性能最高，说明每个类都有一个隐藏的静态成员变量class</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">Class</span> c2 = Person.<span class="keyword">class</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种 通过Class对象的forName()静态方法获取，最常用，需要抛出ClassNotFound 异常</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">Class</span> c3 = <span class="keyword">Class</span>.forName(<span class="string">&quot;test01.Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>注意</strong></em>：一个类在JVM中只存在一个Class实例，所以以上c1&#x3D;c2&#x3D;c3</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//共有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    Person()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Person(String name,<span class="built_in">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class中的各种方法"><a href="#Class中的各种方法" class="headerlink" title="Class中的各种方法"></a>Class中的各种方法</h2><p><img src="/../../themes/next/source/images/ClassFunction.png"><br></p><ul><li>getName()：获得类的完整名字。</li><li>getFields()：获得类的public类型的属性。</li><li>getDeclaredFields()：获得类的所有属性。包括private 声明的和继承类</li><li>getMethods()：获得类的public类型的方法。</li><li>getDeclaredMethods()：获得类的所有方法。包括private 声明的和继承类</li><li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。</li><li>getConstructors()：获得类的public类型的构造方法。</li><li>getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。</li><li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</li></ul><h2 id="所获取的方法激活以及属性的修改"><a href="#所获取的方法激活以及属性的修改" class="headerlink" title="所获取的方法激活以及属性的修改"></a>所获取的方法激活以及属性的修改</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Class c1 = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;Person&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">//通过构造方法实例化对象</span></span><br><span class="line">    Person p1 = (Person)(c1.get<span class="constructor">Constructor()</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取方法 第二个参数为形参的类 比如String.class</span></span><br><span class="line">    Method <span class="keyword">method</span> = c1.get<span class="constructor">Method(<span class="string">&quot;say&quot;</span>, <span class="params">null</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数激活，第一个参数为对象，第二个参数为传入的形参</span></span><br><span class="line">    <span class="keyword">method</span>.invoke(p1, null);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//通过构造方法实例化对象</span></span><br><span class="line">    Person p2 = (Person)(c1.get<span class="constructor">Constructor()</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取属性</span></span><br><span class="line">    Field name = c1.get<span class="constructor">DeclaredField(<span class="string">&quot;name&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置是否自检 true为取消访问检查 私有类型的修改不关闭检查则会报错</span></span><br><span class="line">    name.set<span class="constructor">Accessible(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置属性 第一个参数为对象，第二个参数为值</span></span><br><span class="line">    name.set(p2,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h1><pre><code>待续</code></pre><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://www.cnblogs.com/mikechenshare/p/15796381.html">mikechen</a><br><br><a href="https://www.w3cschool.cn/java/java-reflex.html">W3Cschool</a><br><br><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">敬业小码哥</a><br><br><a href="https://www.cnblogs.com/ysocean/p/6516248.html">IT可乐</a><br><br><a href="https://www.bilibili.com/video/BV1p4411P7V3?p=17">狂神说Java(视频)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java I/O</title>
      <link href="/2022/05/02/Java-I-O/"/>
      <url>/2022/05/02/Java-I-O/</url>
      
        <content type="html"><![CDATA[<h1 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h1><p>流：代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象</p><p>流的本质:数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p><p>作用：为数据源和目的地建立一个输送通道</p><span id="more"></span><h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ul><li><p>流向不同 分为输入输出流<br></p><ul><li><p><strong>输出</strong>：把程序(内存)中的内容输出到磁盘、光盘等存储设备中</p></li><li><p><strong>输入</strong>：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中</p></li></ul></li><li><p>处理的数据类型不同 分为字节流和字符流<br></p><ul><li><strong>字节流</strong>： 可以用于读写二进制文件及任意类型文件（如图片 等），读取时一字节为单位（8 bit），同时字节流在操作时不会将数据读取到缓冲区，而是对文件本身进行直接操作，通常情况下采取这种方式</li><li><strong>字符流</strong>： 可以用于读取文本文件。在java中，字符采取Unicode标准，一个字符为16位，所以字符流通常用于处理字符类型的数据，字符流操作时会将数据先读取到缓冲区，只有在流关闭时或者使用flush才能对文件进行操作，一般只在处理纯文本数据时使用。</li></ul></li><li><p>根据功能不同 分为节点流和处理流<br></p><ul><li><strong>节点流</strong>： 可以从或向一个特定的地方(节点)读写数据。如FileInputStream，FileReader，节点流是直接作用在文件上的流，可以理解为一个管道，文件在管道中传输。</li><li><strong>处理流</strong>：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接，处理流是作用在已有的节点流基础上，是包在节点流的外面的管道(可多层)，其目的是让管道内的流可以更快的传输</li></ul></li></ul><h1 id="IO流的五类一接口"><a href="#IO流的五类一接口" class="headerlink" title="IO流的五类一接口"></a>IO流的五类一接口</h1><ul><li>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等</li><li>InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征</li><li>OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征</li><li>Reader（文件格式操作）：抽象类，基于字符的输入操作</li><li>Writer（文件格式操作）：抽象类，基于字符的输出操作</li><li>RandomAccessFile（p随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作</li><li>Serializable： 一个空接口，为对象提供标准的序列化与反序列化操作</li></ul><h1 id="IO流整体框架"><a href="#IO流整体框架" class="headerlink" title="IO流整体框架"></a>IO流整体框架</h1><p><a href="https://img-blog.csdnimg.cn/img_convert/ff708c54547127a831997b01789f07ea.png">javaIO</a><br><br><a href="https://img-blog.csdnimg.cn/img_convert/9092b53635a76155b8189d96e2f866be.png">javaIO</a></p><h1 id="Java-IO流对象介绍"><a href="#Java-IO流对象介绍" class="headerlink" title="Java IO流对象介绍"></a>Java IO流对象介绍</h1><h2 id="字节输入流InputStream"><a href="#字节输入流InputStream" class="headerlink" title="字节输入流InputStream"></a>字节输入流InputStream</h2><ul><li><p>InputStream：字节输入流基类，是所有的字节输入流的父类，它是一个抽象类。</p></li><li><p>FileInputSream：文件输入流。它通常用于对文件进行读取操作。</p></li><li><p>FilterInputStream ：过滤流。作用是为基础流提供一些额外的功能。装饰者模式中处于装饰者，具体的装饰者都要继承它，所以在该类的子类下都是用来装饰别的流的，也就是处理类。</p></li><li><p>BufferedInputStream：缓冲流。对处理流进行装饰，增强，内部会有一个缓存区，用来存放字节，每次都是将缓存区存满然后发送，而不是一个字节或两个字节这样发送。效率更高。</p></li><li><p>DataInputStream：数据输入流。它是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。</p></li><li><p>PushbakInputStream：回退输入流。java中读取数据的方式是顺序读取,如果某个数据不需要读取，需要程序处理。PushBackInputStream就可以将某些不需要的数据回退到缓冲中。</p></li><li><p>ObjectInputStream：对象输入流。用来提供对“基本数据或对象”的持久存储。通俗点讲，也就是能直接传输对象(反序列化中使用)。</p></li><li><p>PipedInputStream：管道字节输入流。它和PipedOutputStream一起使用，能实现多线程间的管道通信。</p></li><li><p>SequenceInputStream:合并输入流。依次将多个源合并成一个源。</p></li><li><p>StringBufferInputStream:字符相关流。已经过时。</p></li><li><p>ByteArrayInputStream：字节数组输入流，该类的功能就是从字节数组(byte[])中进行以字节为单位的读取，也就是将资源文件都以字节的形式存入到该类中的字节数组中去，我们拿也是从这个字节数组中拿。</p></li></ul><h2 id="字节输出流OutputStream"><a href="#字节输出流OutputStream" class="headerlink" title="字节输出流OutputStream"></a>字节输出流OutputStream</h2><ul><li><p>OutputStream：字节输出流基类，是所有的字节输出流的父类，它是一个抽象类。</p></li><li><p>FileOutputStream：文件输出流。该类实现了一个输出流，将数据输出到文件。</p></li><li><p>FilterOutputStream ：过滤流。用来封装其它的输出流，并为它们提供额外的功能(序列化中使用)。它主要包括BufferedOutputStream, DataOutputStream和PrintStream。</p></li><li><p>BufferedOutputStream：缓冲输出流。给输出流提供缓冲功能。</p></li><li><p>DataOutputStream：是用来装饰其它输出流，将DataOutputStream和DataInputStream输入流配合使用，“允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型”。</p></li><li><p>PrintStream：是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p></li><li><p>ObjectOutputStream：对象输出流。该类将实现了序列化的对象序列化后写入指定地方。</p></li><li><p>PipedOutputStream：管道字节输出流。它和PipedInputStream一起使用，能实现多线程间的管道通信，是管道的发送端。</p></li><li><p>ByteArrayOutputStream：字节数组输出流。该类实现了一个输出流，其数据被写入由byte数组充当的缓冲区，缓冲区会随着数据的不断写入而自动增长</p></li></ul><h2 id="字符输入流Reader"><a href="#字符输入流Reader" class="headerlink" title="字符输入流Reader"></a>字符输入流Reader</h2><ul><li><p>Reader：是所有的输入字符流的父类，它是一个抽象类。</p></li><li><p>CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。</p></li><li><p>PipedReader 是从与其它线程共用的管道中读取数据。</p></li><li><p>BufferedReader是一个装饰器，它和其子类LineNumberReader负责装饰其它Reader对象。</p></li><li><p>InputStreamReader：是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。</p></li><li><p>FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader对象进行装饰，会增加一个行号</p></li></ul><h2 id="字符输出流Writer"><a href="#字符输出流Writer" class="headerlink" title="字符输出流Writer"></a>字符输出流Writer</h2><ul><li><p>Writer：是所有的输出字符流的父类，它是一个抽象类。</p></li><li><p>CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据，</p></li><li><p>BufferedWriter 是一个装饰器为Writer 提供缓冲功能。</p></li><li><p>PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。</p></li><li><p>OutputStreamWriter：是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类(具体可以研究一SourceCode)。功能和使用和OutputStream 极其类似。</p></li></ul><h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><p><a href="https://blog.csdn.net/weixin_33602738/article/details/114146995">塔塔君Minkun</a><br><br><a href="https://blog.csdn.net/i6223671/article/details/89041879">Junieson</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的ArrayList</title>
      <link href="/2022/04/15/java%E4%B8%AD%E7%9A%84ArrayList/"/>
      <url>/2022/04/15/java%E4%B8%AD%E7%9A%84ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的ArrayList"><a href="#Java中的ArrayList" class="headerlink" title="Java中的ArrayList"></a>Java中的ArrayList</h1><blockquote><p>ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。<br>ArrayList 继承了 AbstractList ，并实现了 List 接口。</p></blockquote><span id="more"></span><h2 id="引入以及初始化"><a href="#引入以及初始化" class="headerlink" title="引入以及初始化"></a>引入以及初始化</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">ArrayList</span>; <span class="comment">//引入</span></span><br><span class="line">    <span class="built_in">ArrayList</span>&lt;E&gt; objectName = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;&gt;(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">ArrayList</span>&lt;E&gt; objectName = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;&gt;(<span class="type">int</span> initalCapacity); <span class="comment">// 初始化容量</span></span><br><span class="line">    <span class="built_in">ArrayList</span>&lt;E&gt; objectName = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;&gt;(Collection c);</span><br><span class="line">    <span class="comment">//使用集合类的对象进行初始化（set, list,map）等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-ArrayList常用方法"><a href="#Java-ArrayList常用方法" class="headerlink" title="Java  ArrayList常用方法"></a>Java  ArrayList常用方法</h2><ul><li><p>add(int index, E element)<br></p><blockquote><p>将指定元素插入到指定位置,如果无参则默认从末尾插入</p></blockquote><hr></li><li><p>addAll(int index,Collection<E> c)</E></p><blockquote><p>将集合类对象全部插入到指定位置，如果无参则默认从末尾插入</p></blockquote><hr></li><li><p>clear()</p><blockquote><p>清空链表</p></blockquote><hr></li><li><p>clone()</p><blockquote><p>克隆链表 用链表接收返回值</p></blockquote><hr></li><li><p>contains(Object o)</p><blockquote><p>判断链表中是否包含某一元素 返回一个boolean 类型的值</p></blockquote><hr></li><li><p>containsAll(Collection&lt;&gt; o)</p><blockquote><p>判断是否全部包含Collection中的元素</p></blockquote><hr></li><li><p>get(int index)</p><blockquote><p>获得该下标的元素</p></blockquote><hr></li><li><p>indexOf(Object o)</p><blockquote><p>获得在链表中该元素的下标位置</p></blockquote><hr></li><li><p>remove(int index || Object o)</p><blockquote><p>去除链表中该下标位置的元素或与o相同的元素</p></blockquote></li><li><p>subList(int fromIndex,int toIndex)</p><blockquote><p>截取从fromIndex到toIndex的元素 返回值为list</p></blockquote><hr></li><li><p>set(int index,Object element)</p><blockquote><p>替换 arraylist 中指定索引的元素</p></blockquote><hr></li><li><p>sort(Comparator c)</p><blockquote><p>对 arraylist 元素进行排序<br><br>  Comparator 顺序方式 <br><br>  Comparator.naturalOrder() 升序<br>  Comparator.reverseOrder() 降序</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://www.runoob.com/java/java-arraylist.html">菜鸟教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql语句的执行顺序以及流程</title>
      <link href="/2022/04/02/sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/04/02/sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="sql语句的执行顺序以及流程"><a href="#sql语句的执行顺序以及流程" class="headerlink" title="sql语句的执行顺序以及流程"></a>sql语句的执行顺序以及流程</h1><blockquote><p>程序员对sql语句的执行顺序的透彻掌握，是避免编程中各种bug和错误，歧义语句的不二法则。</p></blockquote><span id="more"></span><h1 id="SQL-Select-语句完整的执行顺序："><a href="#SQL-Select-语句完整的执行顺序：" class="headerlink" title="SQL Select 语句完整的执行顺序："></a>SQL Select 语句完整的执行顺序：</h1><p>1、from 子句组装来自不同数据源的数据；<br><br>2、where 子句基于指定的条件对记录行进行筛选； <br><br>3、group by 子句将数据划分为多个分组； <br><br>4、使用聚集函数进行计算； <br><br>5、使用 having 子句筛选分组；<br><br>6、计算所有的表达式；<br>7、select 的字段；<br><br>8、使用 order by 对结果集进行排序。<br></p><p>SQL 语言不同于其他编程语言的最明显特征是处理代码的顺序。 在大多数据库语言中，代码按编码顺序被处理。但在 SQL 语句中，第一个被处理的子句式 FROM，而不是第一出现的 SELECT。</p><h1 id="SQL-查询处理的步骤序号："><a href="#SQL-查询处理的步骤序号：" class="headerlink" title="SQL 查询处理的步骤序号："></a>SQL 查询处理的步骤序号：</h1><p>(1) FROM <left_table> <br><br>(2) <join_type> JOIN <right_table> <br><br>(3) ON <join_condition> <br><br>(4) WHERE <where_condition> <br><br>(5) GROUP BY <group_by_list><br><br>(6) WITH {CUBE | ROLLUP} <br><br>(7) HAVING <having_condition> <br><br>(8) SELECT (9) DISTINCT <br><br>(9) ORDER BY <order_by_list> <br><br>(10) <TOP_specification> <select_list><br></select_list></TOP_specification></order_by_list></having_condition></group_by_list></where_condition></join_condition></right_table></join_type></left_table></p><p>以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者(客户端应 用程序或者外部查询)不可用。只有最后一步生成的表才会会给调用者。如果没有在查询中指定某一个子句， 将跳过相应的步骤。</p><h1 id="逻辑查询处理阶段简介："><a href="#逻辑查询处理阶段简介：" class="headerlink" title="逻辑查询处理阶段简介："></a>逻辑查询处理阶段简介：</h1><p>1、 FROM：对 FROM 子句中的前两个表执行笛卡尔积(交叉联接)，生成虚拟表 VT1。</p><p>2、 ON：对 VT1 应用 ON 筛选器，只有那些使为真才被插入到 TV2。 </p><p>3、 OUTER (JOIN):如果指定了 OUTER JOIN(相对于 CROSS JOIN 或 INNER JOIN)，保留表中未找到 匹配的行将作为外部行添加到 VT2，生成 TV3。如果 FROM 子句包含两个以上的表，则对上一个联接生成的 结果表和下一个表重复执行步骤 1 到步骤 3，直到处理完所有的表位置。</p><p>4、 WHERE：对 TV3 应用 WHERE 筛选器，只有使为 true 的行才插入 TV4。 </p><p>5、 GROUP BY：按 GROUP BY 子句中的列列表对 TV4 中的行进行分组，生成 TV5。 </p><p>6、 CUTE|ROLLUP：把超组插入 VT5，生成 VT6。 </p><p>7、 HAVING：对 VT6 应用 HAVING 筛选器，只有使为 true 的组插入到 VT7。 </p><p>8、 SELECT：处理 SELECT 列表，产生 VT8。 </p><p>9、 DISTINCT：将重复的行从 VT8 中删除，产品 VT9。</p><p>10、 ORDER BY：将 VT9 中的行按 ORDER BY 子句中的列列表顺序，生成一个游标(VC10)。 </p><p>11、 TOP：从 VC10 的开始处选择指定数量或比例的行，生成表 TV11，并返回给调用者。 where 子句中的条件书写顺序</p><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="https://cloud.tencent.com/developer/article/1600323">小马哥</a></p><p>侵权联系删除 email：<a href="mailto:&#x32;&#54;&#54;&#56;&#51;&#x38;&#x30;&#x30;&#54;&#52;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;">&#x32;&#54;&#54;&#56;&#51;&#x38;&#x30;&#x30;&#54;&#52;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;</a></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Morris 中序遍历</title>
      <link href="/2022/04/01/Morris-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2022/04/01/Morris-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote><p>morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，morris遍历可以将非递归遍历中的空间复杂度降为O(1),并且避免了对栈的依赖。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。</p></blockquote><span id="more"></span><h1 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h1><p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 x）：</p><ul><li>如果 x 无左孩子，先将 x 的值加入答案数组，再访问 x 的右孩子，即 x &#x3D; x..right。</li><li>如果 x 有左孩子，则找到 x 左子树上最右的节点（即左子树中序遍历的最后一个节点，x 在中序遍历中的前驱节点），我们记为 predecessor。根据 predecessor 的右孩子是否为空，进行如下操作。</li><li>如果 predecessor 的右孩子为空，则将其右孩子指向 x，然后访问 x 的左孩子，即 x &#x3D; x.left。</li><li>如果 predecessor 的右孩子不为空，则此时其右孩子指向 x，说明我们已经遍历完 x 的左子树，我们将predecessor 的右孩子置空，将 x 的值加入答案数组，然后访问 x 的右孩子，即 x &#x3D; x.right。</li><li>重复上述操作，直至访问完整棵树。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        TreeNode *predecessor = nullptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != nullptr) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (root-&gt;</span>left != nullptr) &#123;</span><br><span class="line">                <span class="comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                <span class="function"><span class="title">predecessor</span> = root-&gt;</span>left;</span><br><span class="line">                <span class="function"><span class="title">while</span> (predecessor-&gt;</span><span class="function"><span class="title">right</span> != nullptr &amp;&amp; predecessor-&gt;</span>right != root) &#123;</span><br><span class="line">                    <span class="function"><span class="title">predecessor</span> = predecessor-&gt;</span>right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="function"><span class="title">if</span> (predecessor-&gt;</span>right == nullptr) &#123;</span><br><span class="line">                    <span class="function"><span class="title">predecessor</span>-&gt;</span>right = root;</span><br><span class="line">                    <span class="function"><span class="title">root</span> = root-&gt;</span>left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="function"><span class="title">res</span>.push_back(root-&gt;</span>val);</span><br><span class="line">                    <span class="function"><span class="title">predecessor</span>-&gt;</span>right = nullptr;</span><br><span class="line">                    <span class="function"><span class="title">root</span> = root-&gt;</span>right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">res</span>.push_back(root-&gt;</span>val);</span><br><span class="line">                <span class="function"><span class="title">root</span> = root-&gt;</span>right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">LeetCode-Solution</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析hexo的原理</title>
      <link href="/2022/03/30/%E6%B5%85%E6%9E%90hexo%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/30/%E6%B5%85%E6%9E%90hexo%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析hexo的原理"><a href="#浅析hexo的原理" class="headerlink" title="浅析hexo的原理"></a>浅析hexo的原理</h1><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><span id="more"></span><h2 id="github的pages服务"><a href="#github的pages服务" class="headerlink" title="github的pages服务"></a>github的pages服务</h2><ul><li><p>github pages 支持静态页面的解析</p></li><li><p>Hexo 用来生成HTML，生成的HTML上传到服务器进行解析</p></li></ul><h2 id="如何用-hexo-生成HTML"><a href="#如何用-hexo-生成HTML" class="headerlink" title="如何用 hexo 生成HTML"></a>如何用 hexo 生成HTML</h2><h3 id="Hexo的工作原理"><a href="#Hexo的工作原理" class="headerlink" title="Hexo的工作原理"></a>Hexo的工作原理</h3><ul><li><p>hexo g : 生成静态文件。将我们的数据和界面相结合生成静态文件的过程。会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 publid 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。</p></li><li><p>hexo d：部署文件。部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 public 文件上传至 github 或者 coding 中。然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 public 文件上传至你自己的服务器上。</p></li></ul><h3 id="hexo的模板引擎"><a href="#hexo的模板引擎" class="headerlink" title="hexo的模板引擎"></a>hexo的模板引擎</h3><ul><li>source 文件夹理解为数据库，而主题文件夹相当于 界面。然后我们 hexo g 就将我们的数据和界面相结合生成静态文件 public。</li></ul><br><ul><li><p>Hexo 的模板引擎是默认使用 ejs 编写的。hexo首先会解析 md 文件，然后根据 layout 判断布局类型，再调用其他的文件，这样每一块的内容都是独立的，提高代码的复用性。最终会生成一个 html 页面。</p></li><li><p>hexo new [layout] &lt;title&gt;就会使用对应的模板。</p><br>其中 _layout.swig 是通用模板，里面引入了 head、footer 等公共组件，然后在其他的模板中会引入这个 _layout.swig 通用模板，比如 post.swig 模板</li></ul><h3 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h3><ul><li>数据填充主要是 hexo -g 的时候将数据传递给swig 模板，然后由swig模板填充到HTML中</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><br>    非要说 Hexo 是什么的话，我觉得就是生成静态页面的工具，可以将我们使用 markdown 编写的内容与主题模板相结合，生成 HTML 静态文件。并且可以和 github 的 pages 或者其他可以将静态页面展现出来的服务（例如 coding 的 pages 服务）相结合，一键部署。<p>再深入一点讲 Hexo 的原理的话，那就应该是使用 yaml 语言 做配置文件，使用 ejs 或者 swig 作为主题模板，与使用 markdown 书写的内容结合，生成静态 HTML 文件。</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><h3 id="如何使用git工具对hexo文章进行版本控制"><a href="#如何使用git工具对hexo文章进行版本控制" class="headerlink" title="如何使用git工具对hexo文章进行版本控制"></a>如何使用git工具对hexo文章进行版本控制</h3><blockquote><p>1.在github或gitee上创建一个私有仓<br><br>2.在hexo文件夹下执行git init <br><br>3.添加远程仓库地址，git remote add github repository_path(github是远程仓库别名，可以另取，repository_path是远程仓库地址)<br><br>4.先拉一下远程仓库的代码，git fetch github<br><br>5.将自己主题的配置复制一份，重命名放到hexo&#x2F;下<br><br>6.填写.gitignore忽略一些不需要进行管理的文件或文件夹，下面是我的配置<br><br>7.将自己的代码提交并push到github上即可<br></p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="meta">    .DS_Store</span></span><br><span class="line">    Thumbs<span class="number">.</span><span class="built_in">db</span></span><br><span class="line">    <span class="built_in">db</span><span class="number">.</span>json</span><br><span class="line">    *.log</span><br><span class="line">    node_modules/</span><br><span class="line">    <span class="meta">public</span>/</span><br><span class="line"><span class="meta">    .deploy</span>*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考  ：<br><br> <a href="https://juejin.cn/post/6844903490930622471">sunshine小小倩</a><br><br> <a href="https://blog.wangx.me/2019/01/12/git-upload-subfolder/">Wangx</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2022/03/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/03/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><strong>正则表达式</strong>：又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</p><span id="more"></span><hr><h2 id="常用字符"><a href="#常用字符" class="headerlink" title="常用字符"></a>常用字符</h2><ul><li><p>\</p><p>  将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</p></li></ul><hr><ul><li><p>^</p><p>  匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</p></li></ul><hr><ul><li><p>$    </p><p>  匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</p></li></ul><hr><ul><li><p>*    </p><p>  匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</p></li></ul><hr><ul><li><p>+</p><p>  匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</p></li></ul><hr><ul><li><p>?</p><p>  匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</p></li></ul><hr><ul><li><p>{n}</p><p>  n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</p></li></ul><hr><ul><li><p>{n,}    </p><p>  n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</p></li></ul><hr><ul><li><p>{n,m}    </p><p>  m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</p></li></ul><hr><ul><li><p>?    </p><p>  当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</p></li></ul><hr><ul><li><p>.    </p><p>  匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.|\n)”的模式。</p></li></ul><hr><ul><li><p>[xyz]    </p><p>  字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</p></li></ul><hr><ul><li><p>[^xyz]</p><p>  负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</p></li></ul><hr><ul><li><p>[a-z]    </p><p>  字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</p></li></ul><hr><ul><li><p>[^a-z]</p><p>  负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</p></li></ul><hr><ul><li><p>\b    </p><p>  匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</p></li></ul><hr><ul><li><p>\B    </p><p>  匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</p></li></ul><hr><ul><li><p>\d</p><p>  匹配一个数字字符。等价于 [0-9]。</p></li></ul><hr><ul><li><p>\D</p><p>  匹配一个非数字字符。等价于 [^0-9]。</p></li></ul><hr><ul><li><p>\r</p><p>  匹配一个回车符。等价于 \x0d 和 \cM。</p></li></ul><hr><ul><li><p>\s</p><p>  匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</p></li></ul><hr><ul><li><p>\S    </p><p>  匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</p></li></ul><hr><ul><li><p>\w    </p><p>  匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</p></li></ul><hr><ul><li><p>\W    </p><p>  匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</p></li></ul><hr><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul><li><p>i</p><p>不区分大小写</p></li><li><p>g</p><p>全局匹配  查找所有的匹配项</p></li><li><p>m</p><p>多行匹配</p></li></ul><br><p>参考   <a href="https://www.runoob.com/regexp/regexp-flags.html">菜鸟教程-正则表达式</a></p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/08/hello-world/"/>
      <url>/2022/03/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
