<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ConcurrentHashMap源码分析</title>
      <link href="/2023/10/11/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2023/10/11/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ConcurrentHashMap-简介"><a href="#ConcurrentHashMap-简介" class="headerlink" title="ConcurrentHashMap 简介"></a>ConcurrentHashMap 简介</h1><blockquote><p> 本篇使用的jdk源码版本jdk11</p></blockquote><p><code>ConcurrentHashMap</code> 是 Java 中的一个线程安全的哈希表实现，用于支持多线程并发访问。它的设计目的是提供高并发性能，同时确保数据的一致性和可靠性。在多线程并发环境下，使用普通的 HashMap 可能会导致数据不一致或抛出异常。ConcurrentHashMap 被设计用来在高并发情况下安全地执行插入、删除和查询操作，无需显式的同步措施，从而提高了程序的并发性能。</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/09/%5BJavaGuide/docs/java/collection/arraylist-source-code/"/>
      <url>/2023/10/09/%5BJavaGuide/docs/java/collection/arraylist-source-code/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap源码分析</title>
      <link href="/2023/10/06/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2023/10/06/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h1><blockquote><p>本篇使用的jdk源码版本jdk11</p></blockquote><p><code>HashMap</code> 是 <code>Java</code> 中的一个重要数据结构，它用于存储键值对（key-value pairs），并提供了高效的查找、插入和删除操作。<code>HashMap</code>  是常用的Java集合之一，是非线程安全的。</p><span id="more"></span><p><img src="/2023/10/06/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashMap.png" alt="HashMap"></p><p><code>HashMap</code> 继承了 <code>Map</code>、 <code>Cloneable</code>、<code>Serializable</code> 等接口</p><ul><li><code>Map</code> ：该接口提供了最基本键值对映射的基本框架，定义了键和值之间的映射关系，并提供了一系列的操作来管理这些映射关系</li><li><code>Cloneable</code> : 也是一个标记接口，表明它具有拷贝能力，可以进行深拷贝和浅拷贝</li><li><code>Serializable</code> : 也是一个标记接口，表明它可以进行序列化操作，也就是可以将对象转化为字节流进行持久化存储或者在网络中传输，非常方便</li><li><code>AbstractMap</code> : 一个抽象类，它提供了一些通用的方法和骨架实现</li></ul><p><strong>注意</strong> ：<code>HashMap</code> <strong>是可以添加null值的，作为键值null值只能添加一个，但作为值可以添加多个</strong></p><h1 id="HashMap-的成员变量"><a href="#HashMap-的成员变量" class="headerlink" title="HashMap 的成员变量"></a>HashMap 的成员变量</h1><p>在开始了解 <code>HashMap</code> 的源码之前，我们需要先了解一下 <code>HashMap</code> 类中的各个成员变量代表什么含义，这可以更有效的让我们了解  <code>HashMap</code> 类中函数对成员变量的一些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化id 用于控制序列化和反序列化过程中版本的一致性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的初始容量，必须为2的幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的装载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当Bins(箱，或者说桶)中至少有TREEIFY_THRESHOLD个元素的时候，存储结构将转换为红黑树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当Bins(箱，或者说桶)中元素少于UNTREEIFY_THRESHOLD的时候，存储结构将转换为链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bins(箱，或者说桶)中结构转化为红黑树对应的table的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储元素的数组，大小总是2的幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存缓存的entrySet()。AbstractMap 字段用于 keySet() 和 value()。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次扩容和更改map结构的计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阈值(容量 * 装载因子) 当实际大小超过阈值时会进行扩</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Node 节点类源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;  </span><br><span class="line">    <span class="keyword">final</span> K key;  </span><br><span class="line">    V value;  </span><br><span class="line">    Node&lt;K,V&gt; next;  </span><br><span class="line">  </span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.hash = hash;  </span><br><span class="line">        <span class="built_in">this</span>.key = key;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">        <span class="built_in">this</span>.next = next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;  </span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;  </span><br><span class="line">        value = newValue;  </span><br><span class="line">        <span class="keyword">return</span> oldValue;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;  </span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;  </span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;  </span><br><span class="line">                Objects.equals(value, e.getValue()))  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看到这里，你可以会有以下几个疑问，让我一一为你解答</p><ol><li><p>为什么 <code>HashMap</code> 的大小必须是2的幂</p><ul><li>在 <code>HashMap</code> 中，我们对元素的存储位置需要进行取模运算来获得，而在取模运算中<code>hash % size</code> 对于2的幂来说，可以等价于使用位运算 <code>hash &amp; (size - 1)</code>，这可以保证哈希码的高位和低位都参与了桶索引的计算，从而是元素分布更均匀，减少了Hash碰撞的发生。</li><li>使用2的幂作为大小可以提高散列函数的计算效率，因为计算 <code>hash &amp; (size - 1)</code> 比计算 <code>hash % size</code> 更快。</li></ul></li><li><p>什么是转载因子(LOAD_FACTOR)</p><ul><li>在HashMap中，转载因子通常用来衡量散列表的填充程度。即键值对数量相对于 <code>HashMap</code> 的容量比例。在Java的HashMap实现中，默认的转载因子是0.75，这意味着当HashMap中的键值对数量达到容量的75%时，HashMap会自动进行扩容操作。合理的装载因子可以减少空间还足够充足的时候发生扩容从而导致的空间浪费，也可以减少元素过多而空间不足时发生的Hash冲突发生的频率</li></ul></li><li><p>什么是 <code>Bin</code> ，即桶</p><ul><li><code>Bin</code> 或桶是HashMap内部用来存储键值对的数据结构，用于解决哈希冲突。在Java 8之前，它是链表，而在Java 8及以后，它可以是链表或红黑树，具体取决于桶内键值对的数量。</li></ul></li><li><p>为什么要将存储结构转换为红黑树</p><ul><li>当多个键映射到同一个桶时，如果链表过长，查找、插入和删除操作可能会变得很慢，因为它们需要遍历整个链表。红黑树是一种自平衡二叉搜索树，它在平均情况下具有较快的查找、插入和删除操作，因此可以在某些情况下提高HashMap的性能。</li></ul></li></ol><h1 id="HashMap-的构造函数"><a href="#HashMap-的构造函数" class="headerlink" title="HashMap 的构造函数"></a>HashMap 的构造函数</h1><p>了解完成员变量之后，我们需要了解 <code>hashMap</code> 的构造方法，让我们知道我们可以使用一些什么参数来构造一个 <code>hashMap</code> 并且使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定容量和装载因子的构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity 初始化容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      装载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// 初始容量暂时存放到 threshold 中</span></span><br><span class="line">        <span class="comment">// tableSizeFor 根据传入的initialCapacity 计算出一个大于或等于initialCapacity的最小的2的幂次方的整数</span></span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定容量的构造方法，使用默认的装载因子</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity 初始化容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的构造方法，使用默认的大小和装载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含另一个 Map 的构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   the map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        <span class="comment">//后面会分析这个方法</span></span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于 <code>HashMap</code> 中没有 <code>capacity</code> 这个属性，所以先将初始化容量赋值给 <code>threshold</code> 这个属性，后续通过 <code>resize</code>  这个方法来进行对 <code>table</code> 的初始化</p></blockquote><h2 id="putMapEntries-方法"><a href="#putMapEntries-方法" class="headerlink" title="putMapEntries 方法"></a>putMapEntries 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();  </span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size  </span></span><br><span class="line">        <span class="comment">// s / capacity = loadFactor </span></span><br><span class="line">        <span class="comment">// ft 是 计算要添加s个元素所需的最小的容量</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?  </span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);  </span><br><span class="line">            <span class="comment">// 如果要添加s个元素所需的最小容量小于初始化容量</span></span><br><span class="line">            <span class="comment">// 则以这个容量扩容至最接近这个容量的2的幂的容量</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)  </span><br><span class="line">                threshold = tableSizeFor(t);  </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)  </span><br><span class="line">        <span class="comment">// 已经初始化，并且元素个数大于阈值，进行扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将 m 中的所有元素添加至 HashMap 中   </span></span><br><span class="line">        <span class="comment">// 如果table 并没有初始化，在putVal方法中会调用resize进行初始化或扩容</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;  </span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();  </span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();  </span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);  </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HashMap-的核心方法"><a href="#HashMap-的核心方法" class="headerlink" title="HashMap 的核心方法"></a>HashMap 的核心方法</h1><h2 id="RESIZE-方法"><a href="#RESIZE-方法" class="headerlink" title="RESIZE 方法"></a>RESIZE 方法</h2><p>在初始化或者容量不够的时候，<code>HashMap</code> 都会调用这个方法来进行扩容，这个过程会遍历 <code>hash</code> 表中的所有元素并对其进行 <code>hash</code> 分配，是非常耗时的。在编写程序中，要尽量避免 resize。resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 初始化表大小或将表大小加倍。如果为空，则根据阈值字段中保存的初始容量目标进行分配。否则，因为我们使用的是 2 的幂扩展，所以每个 bin 中的元素必须保持在相同的索引处，或者在新表中以 2 的幂偏移量移动。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;  </span><br><span class="line">    <span class="comment">// 旧容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;  </span><br><span class="line"><span class="comment">// 旧阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;  </span><br><span class="line">    <span class="comment">// 新容量，新阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">// 如果旧容量大于0，即table已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="comment">// 旧容量大于最大容量，不再扩充</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;  </span><br><span class="line">            threshold = Integer.MAX_VALUE;  </span><br><span class="line">            <span class="comment">// 返回旧表</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;  </span><br><span class="line">        <span class="comment">// 旧容量的两倍没超过最大值并且大于默认值，将新容量设置为旧容量的两倍</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;  </span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)  </span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// table没有初始化，但有初始化容量，</span></span><br><span class="line">    <span class="comment">// 在构造函数中我们知道，最开始不会直接给table分配一个数组，而是把初始值容量放在threshold</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 新容量即为暂存在threshold的初始容量</span></span><br><span class="line">        newCap = oldThr;  </span><br><span class="line">    <span class="comment">// 没有指定初始容量</span></span><br><span class="line">    <span class="keyword">else</span> &#123;            </span><br><span class="line">        <span class="comment">// 都使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;  </span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span></span><br><span class="line">    <span class="comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;  </span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?  </span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 更新阈值</span></span><br><span class="line">    threshold = newThr;  </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span>  </span><br><span class="line">    <span class="comment">// 给table分配空间</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];  </span><br><span class="line">    table = newTab;  </span><br><span class="line">    <span class="comment">// 旧表中有数据的时候，需要重新hash</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;  </span><br><span class="line">            Node&lt;K,V&gt; e;  </span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;  </span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;  </span><br><span class="line">                <span class="comment">// 只有一个节点 直接计算元素新的位置</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)  </span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;  </span><br><span class="line">                <span class="comment">// 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。</span></span><br><span class="line">                    <span class="comment">// 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)  </span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);  </span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order  </span></span><br><span class="line">                <span class="comment">// 旧桶</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;  </span><br><span class="line">                    <span class="comment">// 新桶</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;  </span><br><span class="line">                    Node&lt;K,V&gt; next;  </span><br><span class="line">                    <span class="keyword">do</span> &#123;  </span><br><span class="line">                        next = e.next;  </span><br><span class="line">                        <span class="comment">//根据节点的哈希值的某一位是否为0，来决定将节点放入新桶还是旧桶，</span></span><br><span class="line">                        <span class="comment">//是为了实现哈希表的“分而治之”（分治）策略，以提高性能和分布均匀性。</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;  </span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)  </span><br><span class="line">                                loHead = e;  </span><br><span class="line">                            <span class="keyword">else</span>  </span><br><span class="line">                                loTail.next = e;  </span><br><span class="line">                            loTail = e;  </span><br><span class="line">                        &#125;                        </span><br><span class="line">                        <span class="keyword">else</span> &#123;  </span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)  </span><br><span class="line">                                hiHead = e;  </span><br><span class="line">                            <span class="keyword">else</span>  </span><br><span class="line">                                hiTail.next = e;  </span><br><span class="line">                            hiTail = e;  </span><br><span class="line">                        &#125;                   </span><br><span class="line">                     &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);  </span><br><span class="line">                    <span class="comment">// 将链表中的节点分为两部分放在原来的位置，和偏移oldCap的位置</span></span><br><span class="line">                    <span class="comment">// 这样可以分散节点，均匀分布</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;  </span><br><span class="line">                        loTail.next = <span class="literal">null</span>;  </span><br><span class="line">                        newTab[j] = loHead;  </span><br><span class="line">                    &#125;                    </span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;  </span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;  </span><br><span class="line">                        <span class="comment">// 因为容量为2的幂，所有新容量至少是旧容量的两倍</span></span><br><span class="line">                        <span class="comment">// 所以并不会越界</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;  </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 没有数据则直接返回新表</span></span><br><span class="line">    <span class="keyword">return</span> newTab;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PUT-方法"><a href="#PUT-方法" class="headerlink" title="PUT 方法"></a>PUT 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 将指定值与此映射中的指定键相关联。如果映射之前包含键的映射，则旧值将被替换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 键的hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 想要放入的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果为真，则不改变原有的值，否则则会覆盖  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为假，表示在创建模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 前一个值，如果有的话，没有则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,  </span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;  </span><br><span class="line">    <span class="comment">// 如果table 长度为0 或者为null 进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)  </span><br><span class="line">        n = (tab = resize()).length;  </span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 计算 下标，如果哪个下标没有值，则直接插入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)  </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 如果已经有值了</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;  </span><br><span class="line">        <span class="comment">// 判断那个下标的第一个节点的hash值是否与下标的hash值是一样的</span></span><br><span class="line">        <span class="comment">// 如果是，就直接使用插入的节点替换掉</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;  </span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">            e = p;  </span><br><span class="line">        <span class="comment">// 如果不是，判断插入的是否是红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  </span><br><span class="line">        <span class="comment">// 放入到树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);  </span><br><span class="line">        <span class="comment">// 如果不是红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// 遍历到链表的末尾</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;  </span><br><span class="line">            <span class="comment">// 到达链表末尾</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="comment">// 插入节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);  </span><br><span class="line">                    <span class="comment">// 节点数达到转化成树的阈值(默认是8) 执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);  </span><br><span class="line">                    <span class="comment">// 未达到，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// 判断 链表中节点的key值与插入的元素的key值是否一致          </span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等则跳出循环  </span></span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                <span class="comment">// 用于遍历链表 与前面的 e = p.next 对应</span></span><br><span class="line">                p = e;  </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 找到key值，hash值一致的节点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key  </span></span><br><span class="line">        <span class="comment">// 记录e 的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;  </span><br><span class="line">            <span class="comment">// 如果onlyIfAbsent 为 false，即改变原有的值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)  </span><br><span class="line">            <span class="comment">// 新值 替换 旧值</span></span><br><span class="line">                e.value = value;  </span><br><span class="line">            <span class="comment">// 访问后回调 </span></span><br><span class="line">            afterNodeAccess(e);  </span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;   </span><br><span class="line">     &#125;    </span><br><span class="line">    <span class="comment">// 结构性计数器修改</span></span><br><span class="line">    ++modCount;  </span><br><span class="line">    <span class="comment">// 大小增加  并判断是否大于阈值，大于则需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)  </span><br><span class="line">        resize();  </span><br><span class="line">    <span class="comment">// 插入后回调的函数</span></span><br><span class="line">    afterNodeInsertion(evict);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>afterNodeAccess</code> 是<code>java.util.LinkedHashMap</code>类中的一个方法，用于在访问（查找、读取）映射中的节点（键值对）后执行一些操作。<code>LinkedHashMap</code>是<code>HashMap</code>的一个子类，它扩展了<code>HashMap</code>的功能，提供了按照插入顺序或访问顺序（LRU，最近最少使用）来迭代元素的能力。</li><li><code>afterNodeInsertion</code> 与 <code>afterNodeAccess</code> 同理，在数据插入后进行回调</li></ul><h2 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 映射到值得时候返回值，否则返回null </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;  </span><br><span class="line">    Node&lt;K,V&gt; e;  </span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 键得hash值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回这个节点或者null </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;  </span><br><span class="line">    <span class="comment">// 判断table 是否初始化并且下标指向的节点是否有值</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;  </span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;</span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">            <span class="comment">// 首节点的hash值与其相等并且key值相等时</span></span><br><span class="line">            <span class="comment">// 或者key值不为空的时候且key值相等的时候 </span></span><br><span class="line">            <span class="comment">// 第二个条件出现在我们使用自定义类型做为键的时候，比如 ：key1 = new Key（1）</span></span><br><span class="line">            <span class="comment">// key2 = new Key（1），在实现了合适的equals 和 hashCode 的情况下，</span></span><br><span class="line">            <span class="comment">// key1 和 key2都可以获取到这个值</span></span><br><span class="line">            <span class="comment">// 返回这个节点</span></span><br><span class="line">            <span class="keyword">return</span> first;  </span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果链表已经转化成了红黑树，则在树中查找这个节点  </span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);  </span><br><span class="line">            <span class="keyword">do</span> &#123;  </span><br><span class="line">            <span class="comment">// 否则在链表中查找这个节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">                    <span class="keyword">return</span> e;  </span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要注意的是，在 <code>HashMap</code> 的源码中对键值以及hash值得判断使用了这一段代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.hash == hash &amp;&amp;  </span><br><span class="line">((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure></li></ul><p>这说明在键值得判断时，他不仅判断了键值得地址是否相等，还判断键值的内容是否相等，这也就说明在使用 <code>HashMap</code> 的时候，我们可以使用我们自己定义的数据类型作为键值<br><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Key</span> <span class="variable">key1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">        <span class="type">Key</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Key</span>(<span class="string">&quot;1&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        Map&lt;Key,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">        <span class="comment">// 使用key1存数据  </span></span><br><span class="line">        map.put(key1,<span class="number">1</span>);  </span><br><span class="line">        <span class="comment">//使用key2取数据  </span></span><br><span class="line">        System.out.println(map.get(key2));  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 自定义数据类型  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Key</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> String keyName;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">(String keyName)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.keyName = keyName;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Key</span><span class="params">()</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> (Key) o;  </span><br><span class="line">        <span class="keyword">return</span> Objects.equals(keyName, key.keyName);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> Objects.hash(keyName);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="REMOVE-方法"><a href="#REMOVE-方法" class="headerlink" title="REMOVE 方法"></a>REMOVE 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> *  从此映射中删除指定键的映射（如果存在），没有这个节点就返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;  </span><br><span class="line">    Node&lt;K,V&gt; e;  </span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?  </span><br><span class="line">        <span class="literal">null</span> : e.value;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 键值的hash</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 如果 matchValue 则匹配的值，否则忽略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 如果为真的话，只在值相等的时候删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 如果为 false，则删除时不移动其他节点 </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,  </span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;  </span><br><span class="line">    <span class="comment">// 在table有元素且对应下标有元素的时候进行查找删除，否则返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;  </span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;  </span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;  </span><br><span class="line">        <span class="comment">// 找到节点，hash值相等且键值相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;  </span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">            node = p;  </span><br><span class="line">        <span class="comment">// 当这个下标不止一个元素的时候</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  </span><br><span class="line">            <span class="comment">// 如果是树，从树中查找节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);  </span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">do</span> &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">                        ((k = e.key) == key ||  </span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;  </span><br><span class="line">                        node = e;  </span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                    &#125;                    </span><br><span class="line">                    p = e;  </span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);  </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 如果找到节点</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||  </span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)  </span><br><span class="line">            <span class="comment">//从树中移除</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);  </span><br><span class="line"><span class="comment">// node == p 说明是第一个节点，将该节点移除直接指向下一个节点即可</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)  </span><br><span class="line">                tab[index] = node.next;  </span><br><span class="line">            <span class="comment">// 不然的话，p指向目标节点的前一个节点 进行删除操作</span></span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                p.next = node.next;  </span><br><span class="line">            ++modCount;  </span><br><span class="line">            --size;  </span><br><span class="line">            afterNodeRemoval(node);  </span><br><span class="line">            <span class="keyword">return</span> node;  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList源码分析</title>
      <link href="/2023/09/26/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2023/09/26/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList-简介"><a href="#ArrayList-简介" class="headerlink" title="ArrayList 简介"></a>ArrayList 简介</h1><blockquote><p>本篇使用的jdk源码版本jdk11</p></blockquote><p>ArrayList是一个非常常用的类，它提供了一种便捷的方式来管理和操作动态数组。它的底层实现是数组队列，相当于动态数组，比起常用的数组，ArrayList可以动态的增长容量。</p><span id="more"></span><p><img src="/2023/09/26/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ArrayList.png" alt="ArrayList"></p><p><code>ArrayList</code>继承了AbstractList类，并实现了 <code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code> 等接口</p><ul><li><code>AbstractList</code> : 一个抽象类，它提供了一些通用的方法和骨架实现</li><li><code>List</code> : 表明它是一个列表，支持添加，删除，查询等操作</li><li><code>RandomAccess</code> : 这是一个标记接口（Marker Interface），它在Java标准库中用于标识实现了随机访问的数据结构。在<code>ArrayList</code> 中，我们即可以通过元素的下标快速的获取元素对象，这就是快速随机访问。在 <code>LinkedList</code> 中，由于<code>LinkedList</code> 底层是由链表实现的，不支持快速的获取元素对象，所以它并没有实现 <code>RandomAccess</code> 这个接口</li><li><code>Cloneable</code> : 也是一个标记接口，表明它具有拷贝能力，可以进行深拷贝和浅拷贝</li><li><code>Serializable</code> : 也是一个标记接口，表明它可以进行序列化操作，也就是可以将对象转化为字节流进行持久化存储或者在网络中传输，非常方便</li></ul><p><strong>注意</strong> ：** <code>ArrayList</code> 是可以添加null值得，但是不建议往其中添加null值，会使代码更加不容易维护**</p><h1 id="ArrayList-的成员变量"><a href="#ArrayList-的成员变量" class="headerlink" title="ArrayList 的成员变量"></a>ArrayList 的成员变量</h1><p>在开始了解 <code>ArrayList</code> 的源码之前，我们需要先了解一下 <code>ArrayList</code> 类中的各个成员变量代表什么含义，这可以更有效的让我们了解 <code>ArrayList</code> 类中函数对成员变量的一些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化id 用于控制序列化和反序列化过程中版本的一致性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始化的容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组，用于空实例</span></span><br><span class="line"><span class="comment">     * 即当不指定容量的时候，会使用该数组来当作初始的内部存储结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于默认大小空实例的共享数组实例</span></span><br><span class="line"><span class="comment">     * 我们把他从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少    ？？？(区别)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个Arraylist的大小(所包含元素的个数)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此列表在结构上被修改的次数。结构修改是那些改变列表大小的修改，或者以其他方式扰乱列表的修改，以致正在进行的迭代可能会产生不正确的结果。该字段由 iterator 和 listIterator 方法返回的迭代器和列表迭代器实现使用。如果该字段的值意外更改，迭代器（或列表迭代器）将抛出 ConcurrentModificationException 来响应下一个、删除、上一个、设置或添加操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 要分配的数组的最大大小（除非必要）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span></span><br></pre></td></tr></table></figure><p>当然，现在你有可能不太理解这些成员变量的作用，但无妨，随着我们的逐渐深入，你会对这些成员变量有更深刻的理解，现在我们只需要有一个大概印象即可。</p><h1 id="ArrayList的构造函数"><a href="#ArrayList的构造函数" class="headerlink" title="ArrayList的构造函数"></a>ArrayList的构造函数</h1><p>了解完成员变量之后，我们需要了解 <code>ArrayList</code> 的构造方法，让我们知道我们可以使用一些什么参数来构造一个 <code>ArrayList</code> 并且使用它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 的无参构造方法</span></span><br><span class="line"><span class="comment">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为空.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始化参数的构造方法(用户可以在创建ArrayList的时候自定义它的大小)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity  初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;  </span><br><span class="line">        <span class="comment">//当初始化参数合法时 即大于0的时候 创建initialCapacity大小的数组</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">//如果初始化参数为0  创建空数组  即成员变量的空数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">//参数不合法的情况  抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+  </span><br><span class="line">                                            initialCapacity);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合中所有元素的列表，按照他们由集合的迭代器返回的顺序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;  </span><br><span class="line">        <span class="comment">// 将集合转化为一个对象数组</span></span><br><span class="line">        Object[] a = c.toArray();  </span><br><span class="line">        <span class="comment">//如果长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;  </span><br><span class="line">                <span class="comment">//是 ArrayList 类型的数据，直接复制给 elementData</span></span><br><span class="line">                elementData = a;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// 如果 elementData 不是 ArrayList 类型的数据 （c.toArray可能返回的不是ArrayList 类型的数组所以加上下面的语句用于判断）</span></span><br><span class="line">                <span class="comment">//将原来不是 ArrayList 类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);  </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 长度为0，则使用空数组替代</span></span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ArrayList的核心方法"><a href="#ArrayList的核心方法" class="headerlink" title="ArrayList的核心方法"></a>ArrayList的核心方法</h1><p>了解了  <code>ArrayList</code> 的构造方法之后，我们可以了解一下 <code>ArrayList</code> 的核心方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回此列表中的元素数。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//注意=和==的区别</span></span><br><span class="line">       <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">       <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line">       <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">               <span class="keyword">if</span> (elementData[i] == <span class="literal">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">               <span class="comment">//equals()方法比较</span></span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">               <span class="keyword">if</span> (elementData[i] == <span class="literal">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">           <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">           v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">           v.modCount = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">return</span> v;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">           <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class="line"><span class="comment">    * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">    * 因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">       <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class="line"><span class="comment">    * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class="line"><span class="comment">    * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class="line"><span class="comment">    * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">    * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">       <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">           <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">           <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">       <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">       System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">       <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">           a[size] = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  </span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  </span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; E <span class="title function_">elementAt</span><span class="params">(Object[] es, <span class="type">int</span> index)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> (E) es[index];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> *  获取下标为 index 的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;  </span><br><span class="line"><span class="comment">//调用Objects的方法来判断下表是是否越界或者不合法</span></span><br><span class="line">    Objects.checkIndex(index, size);  </span><br><span class="line">    <span class="keyword">return</span> elementData(index);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 用指定元素替换下标为index的元素</span></span><br><span class="line"><span class="comment"> * 并返回原来在这个位置的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;  </span><br><span class="line"><span class="comment">//检查index</span></span><br><span class="line">    Objects.checkIndex(index, size);  </span><br><span class="line">    <span class="comment">//获取在这个位置的值</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);  </span><br><span class="line">    <span class="comment">//替换它</span></span><br><span class="line">    elementData[index] = element;  </span><br><span class="line">    <span class="keyword">return</span> oldValue;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 移除下标为index的元素</span></span><br><span class="line"><span class="comment"> * 并返回这个值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;  </span><br><span class="line"><span class="comment">//边界检查</span></span><br><span class="line">    Objects.checkIndex(index, size);  </span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;  </span><br><span class="line"><span class="comment">//获取index位置的值</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) es[index];  </span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    fastRemove(es, index);  </span><br><span class="line"><span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">    * 返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;  </span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">//循环块   使用 break found 跳出</span></span><br><span class="line">    found: &#123;  </span><br><span class="line"><span class="comment">//因为null 不能使用 equals 来判断，所以这里进行了区分</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)  </span><br><span class="line">                <span class="keyword">if</span> (es[i] == <span class="literal">null</span>)  </span><br><span class="line">                    <span class="keyword">break</span> found;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size; i++)  </span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i]))  </span><br><span class="line">                    <span class="keyword">break</span> found;  </span><br><span class="line">        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;    </span><br><span class="line">    fastRemove(es, i);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> *  真正执行删除的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(Object[] es, <span class="type">int</span> i)</span> &#123;  </span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> newSize;  </span><br><span class="line">    <span class="comment">//将删除元素的后面的元素向前移</span></span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i)  </span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);  </span><br><span class="line">    <span class="comment">//并将最后的赋值为null</span></span><br><span class="line">    es[size = newSize] = <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 从此列表中删除所有索引为 fromIndex (包含) 和 toIndex (不包含) 之间的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt; toIndex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(  </span><br><span class="line">                outOfBoundsMsg(fromIndex, toIndex));  </span><br><span class="line">    &#125;   </span><br><span class="line">    modCount++;  </span><br><span class="line">    shiftTailOverGap(elementData, fromIndex, toIndex);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 真正执行的删除函数</span></span><br><span class="line"><span class="comment"> * 将hi后面的元素往前移到lo的位置进行删除，并将删除的元素位置置空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shiftTailOverGap</span><span class="params">(Object[] es, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;  </span><br><span class="line">    System.arraycopy(es, hi, es, lo, size - hi);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> size, i = (size -= hi - lo); i &lt; to; i++)  </span><br><span class="line">        es[i] = <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">    * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class="line"><span class="comment">    * 返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;  </span><br><span class="line">    rangeCheckForAdd(index);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class="line"><span class="comment">    * 返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(<span class="number">0</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class="line"><span class="comment">    * 返回的迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关于ArrayList的扩容机制"><a href="#关于ArrayList的扩容机制" class="headerlink" title="关于ArrayList的扩容机制"></a>关于ArrayList的扩容机制</h1><p>在上面，我们并没有分析关于 <code>ArrayList</code> 的添加元素的一些方法，这是因为在添加操作时，涉及到<code>ArrayList</code>的扩容机制，这是我们需要重点关注的，于是我打算新开一节来重点分析这一部分。</p><p><strong>我们先从add方法看起</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 添加元素至数组的末尾 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)  </span><br><span class="line">        elementData = grow();  </span><br><span class="line">    <span class="comment">//在末尾添加元素</span></span><br><span class="line">    elementData[s] = e;  </span><br><span class="line">    <span class="comment">//大小 + 1</span></span><br><span class="line">    size = s + <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;  </span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="comment">//在末尾添加元素</span></span><br><span class="line">    add(e, elementData, size);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 在此列表的指定位置插入指定的元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;  </span><br><span class="line"><span class="comment">//检查下标是否非法</span></span><br><span class="line">    rangeCheckForAdd(index);  </span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> s;  </span><br><span class="line">    Object[] elementData;  </span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="built_in">this</span>.elementData).length)  </span><br><span class="line">        elementData = grow();  </span><br><span class="line">    <span class="comment">//将index赋值到index+1后面的位置</span></span><br><span class="line">    System.arraycopy(elementData, index,  </span><br><span class="line">                     elementData, index + <span class="number">1</span>,  </span><br><span class="line">                     s - index);  </span><br><span class="line">    <span class="comment">//在将元素element赋值到index这个位置</span></span><br><span class="line">    elementData[index] = element;  </span><br><span class="line">    <span class="comment">//大小+1</span></span><br><span class="line">    size = s + <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这些add方法中我们不难看出，当我们的 <code>size</code> &#x3D;&#x3D; <code>length</code> 的时候，我们会调用 <code>grow</code> 方法来进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 增加容量以确保它至少可以容纳最小容量参数指定的元素数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;  </span><br><span class="line">    <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData,  </span><br><span class="line">                                       newCapacity(minCapacity));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;  </span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着看 <code>newCapacity</code> 这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 返回至少与给定最小容量一样大的容量。如果足够的话，返回当前容量增加 50%。</span></span><br><span class="line"><span class="comment"> * 除非给定的最小容量大于 MAX_ARRAY_SIZE，否则不会返回大于 MAX_ARRAY_SIZE 的容量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;  </span><br><span class="line">    <span class="comment">// 旧容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;  </span><br><span class="line">    <span class="comment">//新容量   为旧容量的 1.5 倍  使用位运算效率更高</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">// 检查新容量 是否小于最小需要的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line"><span class="comment">// 如果 数组为空，返回默认容量和最小容量的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)  </span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);  </span><br><span class="line">        <span class="comment">//最小容量小于0  抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow  </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();  </span><br><span class="line">        <span class="comment">// 如果小于 就把最小需要的容量当作数组的容量</span></span><br><span class="line">        <span class="keyword">return</span> minCapacity;  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//不小于  判断新容量和最大数组的长度大小</span></span><br><span class="line">    <span class="comment">//如果新容量小于最大数组的长度，就返回新容量</span></span><br><span class="line">    <span class="comment">//不然调用 hugeCapacity()  去获取更大的容量</span></span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)  </span><br><span class="line">       ? newCapacity  </span><br><span class="line">       : hugeCapacity(minCapacity);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以看看 <code>hugeCapacity</code> 这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 判断最小的容量是否大于最大数组容量， 大于的话就返回 Integer.MAX_VALUE  </span></span><br><span class="line"><span class="comment"> * 更大的数组容量也就多了 8 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow  </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();  </span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)  </span><br><span class="line">        ? Integer.MAX_VALUE  </span><br><span class="line">        : MAX_ARRAY_SIZE;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们再来通过例子探究一下<code>grow()</code> 方法：</strong></p><ul><li>当 <code>add</code> 第 1 个元素时，<code>oldCapacity</code> 为 0，经比较后第一个 if 判断成立，<code>newCapacity = minCapacity</code>(为 10)。但是第二个 if 判断不会成立，即 <code>newCapacity</code> 不比 <code>MAX_ARRAY_SIZE</code> 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，<code>add</code> 方法中 return true,size 增为 1。</li><li>当 <code>add</code> 第 11 个元素进入 <code>grow</code> 方法时，<code>newCapacity</code> 为 15，比 <code>minCapacity</code>（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 huge<code>C</code>apacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li><li>以此类推······</li></ul><p>到这我们就已经搞明白了 <code>ArrayList</code> 的扩容机制，最后在让我们看一下关于添加元素的其他方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;  </span><br><span class="line">    Object[] a = c.toArray();  </span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;  </span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    Object[] elementData;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> s;  </span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="built_in">this</span>.elementData).length - (s = size))  </span><br><span class="line">        elementData = grow(s + numNew);  </span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, s, numNew);  </span><br><span class="line">    size = s + numNew;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;  </span><br><span class="line"><span class="comment">//界限判定</span></span><br><span class="line">    rangeCheckForAdd(index);  </span><br><span class="line"><span class="comment">//转为数组</span></span><br><span class="line">    Object[] a = c.toArray();  </span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;  </span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    Object[] elementData;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> s;  </span><br><span class="line"><span class="comment">//判断容量</span></span><br><span class="line">    <span class="keyword">if</span> (numNew &gt; (elementData = <span class="built_in">this</span>.elementData).length - (s = size))  </span><br><span class="line">        elementData = grow(s + numNew);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> s - index;  </span><br><span class="line">    <span class="comment">//进行复制</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </span><br><span class="line">        System.arraycopy(elementData, index,  </span><br><span class="line">                         elementData, index + numNew,  </span><br><span class="line">                         numMoved);  </span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);  </span><br><span class="line">    <span class="comment">//改变</span></span><br><span class="line">    size = s + numNew;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关于ArrayList的一些问题"><a href="#关于ArrayList的一些问题" class="headerlink" title="关于ArrayList的一些问题"></a>关于ArrayList的一些问题</h1><h2 id="为什么ArrayList-要实现-AbstractList-，不能直接实现-List-接口就行了嘛？"><a href="#为什么ArrayList-要实现-AbstractList-，不能直接实现-List-接口就行了嘛？" class="headerlink" title="为什么ArrayList 要实现 AbstractList ，不能直接实现 List 接口就行了嘛？"></a><strong>为什么<code>ArrayList</code> 要实现 <code>AbstractList</code> ，不能直接实现 <code>List</code> 接口就行了嘛？</strong></h2><ul><li><strong>代码复用和一致性</strong>：<ul><li><code>AbstractList</code> 提供了 <code>List</code> 接口的骨架实现，这意味着所有实现 <code>AbstractList</code> 的子类都可以共享一些通用的列表操作逻辑，例如 <code>size()</code> 和 <code>isEmpty()</code> 等方法。这样可以避免在每个具体的列表实现中重复编写相同的代码，提高了代码复用性。</li><li>这也有助于确保所有的 <code>List</code> 实现都具有一致的行为，因为它们都共享了来自 <code>AbstractList</code> 的相似的实现。</li></ul></li><li><strong>简化实现</strong>：<ul><li><code>List</code> 接口定义了许多方法，其中一些可能需要复杂的数据结构和算法来实现。使用 <code>AbstractList</code> 可以将列表的实现细节分解为更小的部分，简化了实现的过程，使其更易于理解和维护。</li><li>子类只需要关注实现 <code>AbstractList</code> 抽象类所要求的方法，而不需要关心其他不相关的方法。</li></ul></li><li><strong>提供默认实现</strong>：<ul><li><code>AbstractList</code> 中提供了默认的实现，这使得实现 <code>List</code> 接口的类可以选择性地覆盖这些默认实现。如果某个具体的列表类不需要对某些方法进行特定的优化或自定义实现，可以直接继承 <code>AbstractList</code> 的默认实现，减少了编码工作。</li></ul></li><li><strong>接口的演化</strong>：<ul><li>Java 编程语言的版本在不断演化，新的版本可能会添加新的方法到接口中。使用 <code>AbstractList</code> 可以减轻在现有 <code>List</code> 实现中添加新方法所带来的负担，因为子类只需要实现新添加的方法，而不需要修改已经存在的方法。</li></ul></li></ul><h2 id="elementData-是-ArrayList-中用来存储数据的数组，既然-ArrayList-实现了-Serializable-接口，又为什么要将存储序列化的数组使用-transient-来修饰呢-即不会将这个数组参与序列化"><a href="#elementData-是-ArrayList-中用来存储数据的数组，既然-ArrayList-实现了-Serializable-接口，又为什么要将存储序列化的数组使用-transient-来修饰呢-即不会将这个数组参与序列化" class="headerlink" title="elementData 是 ArrayList 中用来存储数据的数组，既然 ArrayList 实现了 Serializable 接口，又为什么要将存储序列化的数组使用 transient 来修饰呢(即不会将这个数组参与序列化)"></a><strong><code>elementData</code> 是 <code>ArrayList</code> 中用来存储数据的数组，既然 <code>ArrayList</code> 实现了 <code>Serializable</code> 接口，又为什么要将存储序列化的数组使用</strong> <em><strong>transient</strong></em> <strong>来修饰呢(即不会将这个数组参与序列化)</strong></h2><ul><li><strong>容量和性能优化</strong>：<ul><li><code>elementData</code> 数组的容量可能大于实际存储的元素数量，因为 <code>ArrayList</code> 通常会分配比实际元素数量更大的容量，以减少频繁的扩容操作，提高性能。</li><li>如果 <code>elementData</code> 数组参与序列化，那么在反序列化时，可能会导致反序列化后的 <code>ArrayList</code> 对象具有不必要的大容量。这可能会浪费内存，尤其是在存储大型 <code>ArrayList</code> 对象时。</li></ul></li><li><strong>序列化和反序列化的一致性</strong>：<ul><li>序列化的目的是将对象的状态保存到持久存储，然后在需要时恢复它。然而，<code>ArrayList</code> 的容量状态通常不是用户关心的对象状态的一部分。用户更关心的是元素的内容。</li><li>如果 <code>elementData</code> 数组参与序列化，那么序列化和反序列化操作可能会包括大量不必要的数据，这不仅浪费了时间和资源，而且可能导致不必要的数据传输。</li></ul></li><li><strong>数组可能包含敏感数据</strong>：<ul><li>在某些情况下，<code>elementData</code> 数组可能包含敏感数据，例如密码、密钥或其他敏感信息。如果将这些数据参与序列化，可能会引发安全问题，因为序列化的数据可能在传输或存储过程中暴露。</li></ul></li></ul><h2 id="在-ArrayList-的有参构造函数中，为什么要专门判断一下初始化参数是否为0，不能直接-new-一个-初始容量为-0-长度的数组吗"><a href="#在-ArrayList-的有参构造函数中，为什么要专门判断一下初始化参数是否为0，不能直接-new-一个-初始容量为-0-长度的数组吗" class="headerlink" title="在 ArrayList 的有参构造函数中，为什么要专门判断一下初始化参数是否为0，不能直接 new 一个 初始容量为 0 长度的数组吗"></a>在 <code>ArrayList</code> 的有参构造函数中，为什么要专门判断一下初始化参数是否为0，不能直接 <code>new</code> 一个 初始容量为 0 长度的数组吗</h2><ul><li>如果初始化参数为0，这意味着用户希望创建一个空的 <code>ArrayList</code>，没有初始容量。在这种情况下，为了节省内存和不浪费不必要的空间，<code>ArrayList</code> 不会立即分配一个初始容量为0的数组。相反，它会使用一个共享的空数组（<code>EMPTY_ELEMENTDATA</code>），这个数组在初始状态下不占用额外的内存空间，因为它是一个静态常量。</li></ul><h2 id="ArrayList-的最大数组大小为什么不是-Integer-MAX-VALUE-而是-Integer-MAX-VALUE-8"><a href="#ArrayList-的最大数组大小为什么不是-Integer-MAX-VALUE-而是-Integer-MAX-VALUE-8" class="headerlink" title="ArrayList 的最大数组大小为什么不是  Integer.MAX_VALUE  而是  Integer.MAX_VALUE - 8"></a><code>ArrayList</code> 的最大数组大小为什么不是  <code>Integer.MAX_VALUE</code>  而是  <code>Integer.MAX_VALUE - 8</code></h2><ul><li><strong>头部开销</strong>：在Java中，数组通常有一些头部开销，用于存储数组的长度和其他元数据。这些开销通常是一个整数的大小，所以减去 8 可以确保即使数组达到 <code>Integer.MAX_VALUE</code> 的上限，仍然可以保留足够的空间来存储元数据。</li><li><strong>内存对齐</strong>：在某些系统上，数组的大小可能需要按照某种特定的内存对齐规则进行分配。减去 8 可以确保数组大小在内存对齐规则下仍然有效。</li><li><strong>避免潜在问题</strong>：在某些情况下，如果数组的大小接近 <code>Integer.MAX_VALUE</code>，可能会导致性能问题或内存溢出。通过将 <code>MAX_ARRAY_SIZE</code> 设置为 <code>Integer.MAX_VALUE - 8</code>，可以在靠近数组大小限制的情况下提前触发警告或错误，以防止出现不可预测的问题。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[JavaGuide](<a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/collection/arraylist-source-code.md">JavaGuide&#x2F;docs&#x2F;java&#x2F;collection&#x2F;arraylist-source-code.md at main · Snailclimb&#x2F;JavaGuide (github.com)</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/2023/08/22/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/22/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。</p><p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p><p><strong>主要解决</strong>：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p><p><strong>何时使用</strong>：代码中包含大量与对象状态有关的条件语句。</p><p><strong>如何解决</strong>：将各种具体的状态类抽象出来。</p><p><strong>关键代码</strong>：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</p><p><strong>应用实例：</strong> 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</p><p><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p><p><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p><p><strong>使用场景：</strong> 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。</p><p><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/22/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png" alt="状态模式.png"></p><ul><li>环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> State state;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//定义环境类的初始状态  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.state = <span class="keyword">new</span> <span class="title class_">ConcreteStateA</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//设置新状态  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.state = state;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//读取状态  </span></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> (state);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//对请求做处理  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Handle</span><span class="params">()</span> &#123;  </span><br><span class="line">        state.Handle(<span class="built_in">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Handle</span><span class="params">(Context context)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> <span class="keyword">implements</span> <span class="title class_">State</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Handle</span><span class="params">(Context context)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态是 A.&quot;</span>);  </span><br><span class="line">        context.setState(<span class="keyword">new</span> <span class="title class_">ConcreteStateB</span>());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解释器模式</title>
      <link href="/2023/08/21/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/21/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><p><strong>主要解决</strong>：对于一些固定文法构建一个解释句子的解释器。</p><p><strong>何时使用</strong>：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p><p><strong>如何解决</strong>：构建语法树，定义终结符与非终结符。</p><p><strong>关键代码</strong>：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。</p><p><strong>应用实例</strong>：编译器、运算表达式计算。</p><p><strong>优点：</strong> 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。</p><p><strong>缺点：</strong> 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。</p><p><strong>使用场景：</strong> 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。</p><p><strong>注意事项</strong>：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="/2023/08/20/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/20/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p><strong>主要解决</strong>：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p><p><strong>何时使用</strong>：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</p><p><strong>如何解决</strong>：通过一个备忘录类专门存储对象状态。</p><p><strong>关键代码</strong>：客户不与备忘录类耦合，与备忘录管理类耦合。</p><p><strong>应用实例：</strong> 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctrl + z。 4、IE 中的后退。 5、数据库的事务管理。</p><p><strong>优点：</strong> 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p><p><strong>缺点</strong>：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p><p><strong>使用场景：</strong> 1、需要保存&#x2F;恢复数据的相关状态场景。 2、提供一个可回滚的操作。</p><p><strong>注意事项：</strong> 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/20/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.png" alt="备忘录模式"></p><ul><li>发起人角色(Originator)：负责创建一个备忘录，记录自身需要保存的状态，而且需要具备状态的回滚功能。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String state;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.state = state;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">saveStateToMemento</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getStateFromMemento</span><span class="params">(Memento Memento)</span>&#123;  </span><br><span class="line">        state = Memento.getState();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>备忘录角色(Memento)：用于存储Originator角色的内部状态，且可以防止Originator以外的对象进行访问。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String state;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.state = state;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>备忘录管理员角色(Caretaker)：负责存储，管理备忘录功能。且其本身应该无法对备忘录的内容进行访问。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CareTaker</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Memento&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Memento state)</span>&#123;  </span><br><span class="line">        mementoList.add(state);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> mementoList.get(index);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="/2023/08/19/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/19/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p><strong>主要解决</strong>：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p><p><strong>何时使用</strong>：多个类相互耦合，形成了网状结构。</p><p><strong>如何解决</strong>：将上述网状结构分离为星型结构。</p><p><strong>关键代码</strong>：对象 Colleague 之间的通信封装到一个类中单独处理。</p><p><strong>应用实例：</strong> 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</p><p><strong>优点：</strong> 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。</p><p><strong>缺点</strong>：中介者会庞大，变得复杂难以维护。</p><p><strong>使用场景：</strong> 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/19/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="中介者模式"></p><ul><li><p>中介者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatRoom</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">(User user,String msg)</span>&#123;  </span><br><span class="line">        System.out.println(user.getName() + <span class="string">&quot;：&quot;</span> + msg);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.name  = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span>&#123;  </span><br><span class="line">        ChatRoom.showMessage(<span class="built_in">this</span>,message);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">//用户之间并不直接联系，而通过中间平台进行消息的发送，常见的qq群，聊天室，短信平台等都有中介者的影子  </span></span><br><span class="line">        <span class="comment">//这样每个用户并不需要直接依赖其他用户，只需要依赖中间的这个平台就行，从而降低的耦合性  </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">robert</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Robert&quot;</span>);  </span><br><span class="line">        <span class="type">User</span> <span class="variable">john</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        robert.sendMessage(<span class="string">&quot;Hi! John!&quot;</span>);  </span><br><span class="line">        john.sendMessage(<span class="string">&quot;Hello! Robert!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2023/08/18/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/18/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。</p><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><strong>主要解决</strong>：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p><strong>何时使用</strong>：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p><p><strong>如何解决</strong>：使用面向对象技术，可以将这种依赖关系弱化。</p><p><strong>关键代码</strong>：在抽象类里有一个 ArrayList 存放观察者们。</p><p><strong>应用实例：</strong> 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p><p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p><p><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><p><strong>使用场景：</strong></p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><p><strong>注意事项：</strong> 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/18/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式"></p><ul><li>主题（Subject）：也称为被观察者或可观察者，它是具有状态的对象，并维护着一个观察者列表。主题提供了添加、删除和通知观察者的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer o)</span>;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>观察者（Observer）：观察者是接收主题通知的对象。观察者需要实现一个更新方法，当收到主题的通知时，调用该方法进行更新操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> state)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>具体主题（Concrete Subject）：具体主题是主题的具体实现类。它维护着观察者列表，并在状态发生改变时通知观察者。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> state;  </span><br><span class="line">    List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> state;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.state = state;  </span><br><span class="line">        notifyAllObservers();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer o)</span> &#123;  </span><br><span class="line">        observers.add(o);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;  </span><br><span class="line">        observers.remove(o);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllObservers</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (Observer o: observers  </span><br><span class="line">             ) &#123;  </span><br><span class="line">            o.update(<span class="built_in">this</span>.state);  </span><br><span class="line">        &#125;    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>具体观察者（Concrete Observer）：具体观察者是观察者的具体实现类。它实现了更新方法，定义了在收到主题通知时需要执行的具体操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> state)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;BinaryObserver &quot;</span>+state);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OctalObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> state)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;OctalObserver &quot;</span>+state);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Client<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();  </span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> <span class="title class_">BinaryObserver</span>());  </span><br><span class="line">        subject.addObserver(<span class="keyword">new</span> <span class="title class_">OctalObserver</span>());  </span><br><span class="line">  </span><br><span class="line">        subject.setState(<span class="number">20</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Java-中-Observable-使用的观察者模式"><a href="#Java-中-Observable-使用的观察者模式" class="headerlink" title="Java 中 Observable 使用的观察者模式"></a>Java 中 Observable 使用的观察者模式</h1><blockquote><p>在java 9 中已弃用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Observable</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;  </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Observable</span><span class="params">()</span> &#123;  </span><br><span class="line">        obs = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer o)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();  </span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;  </span><br><span class="line">            obs.addElement(o);  </span><br><span class="line">        &#125;   </span><br><span class="line">     &#125;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deleteObserver</span><span class="params">(Observer o)</span> &#123;  </span><br><span class="line">        obs.removeElement(o);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;  </span><br><span class="line">        notifyObservers(<span class="literal">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Object arg)</span> &#123;        </span><br><span class="line">    Object[] arrLocal;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!changed)  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            arrLocal = obs.toArray();  </span><br><span class="line">            clearChanged();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)  </span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="built_in">this</span>, arg);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deleteObservers</span><span class="params">()</span> &#123;  </span><br><span class="line">        obs.removeAllElements();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setChanged</span><span class="params">()</span> &#123;  </span><br><span class="line">        changed = <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">clearChanged</span><span class="params">()</span> &#123;  </span><br><span class="line">        changed = <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">hasChanged</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> changed;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">countObservers</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> obs.size();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="/2023/08/17/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/17/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p><p>迭代器模式属于行为型模式。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p><p><strong>主要解决</strong>：不同的方式来遍历整个整合对象。</p><p><strong>何时使用</strong>：遍历一个聚合对象。</p><p><strong>如何解决</strong>：把在元素之间游走的责任交给迭代器，而不是聚合对象。</p><p><strong>关键代码</strong>：定义接口：hasNext, next。</p><p><strong>应用实例</strong>：JAVA 中的 iterator。</p><p><strong>优点：</strong> 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p><p><strong>缺点</strong>：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p><p><strong>使用场景：</strong> 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。</p><p><strong>注意事项</strong>：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/17/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="迭代器模式"></p><ul><li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Container</span> &#123;  </span><br><span class="line">    Iterator <span class="title function_">getIterator</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameRepository</span> <span class="keyword">implements</span> <span class="title class_">Container</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> String[] args = &#123;<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Lora&quot;</span>&#125;;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">getIterator</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringArrayIterator</span>(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;  </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;  </span><br><span class="line">    Object <span class="title function_">next</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringArrayIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;  </span><br><span class="line">    String[] args;  </span><br><span class="line">    <span class="type">int</span> index;  </span><br><span class="line">  </span><br><span class="line">    StringArrayIterator(String[] args)&#123;  </span><br><span class="line">        <span class="built_in">this</span>.args = args;  </span><br><span class="line">        index = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> index &lt; args.length;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span>(index &lt; args.length)&#123;  </span><br><span class="line">            <span class="keyword">return</span> args[index++];  </span><br><span class="line">        &#125;        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="ArrayList-中的迭代器模式"><a href="#ArrayList-中的迭代器模式" class="headerlink" title="ArrayList 中的迭代器模式"></a>ArrayList 中的迭代器模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * <span class="doctag">@return</span> an iterator over the elements in this list in proper sequence  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * An optimized version of AbstractList.Itr */</span><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;  </span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// prevent creating a synthetic constructor  </span></span><br><span class="line">    Itr() &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> cursor != size;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;  </span><br><span class="line">        checkForComodification();  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;  </span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();  </span><br><span class="line">        Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;  </span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();  </span><br><span class="line">        cursor = i + <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();  </span><br><span class="line">        checkForComodification();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            ArrayList.<span class="built_in">this</span>.remove(lastRet);  </span><br><span class="line">            cursor = lastRet;  </span><br><span class="line">            lastRet = -<span class="number">1</span>;  </span><br><span class="line">            expectedModCount = modCount;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();  </span><br><span class="line">        &#125;    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;  </span><br><span class="line">        Objects.requireNonNull(action);  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.size;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;  </span><br><span class="line">        <span class="keyword">if</span> (i &lt; size) &#123;  </span><br><span class="line">            <span class="keyword">final</span> Object[] es = elementData;  </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= es.length)  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();  </span><br><span class="line">            <span class="keyword">for</span> (; i &lt; size &amp;&amp; modCount == expectedModCount; i++)  </span><br><span class="line">                action.accept(elementAt(es, i));  </span><br><span class="line">            <span class="comment">// update once at end to reduce heap write traffic  </span></span><br><span class="line">            cursor = i;  </span><br><span class="line">            lastRet = i - <span class="number">1</span>;  </span><br><span class="line">            checkForComodification();  </span><br><span class="line">        &#125;    &#125;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();  </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问者模式</title>
      <link href="/2023/08/14/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/14/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：主要将数据结构与数据操作分离。</p><p><strong>主要解决</strong>：稳定的数据结构和易变的操作耦合问题。</p><p><strong>何时使用</strong>：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</p><p><strong>如何解决</strong>：在被访问的类里面加一个对外提供接待访问者的接口。</p><p><strong>关键代码</strong>：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p><p><strong>应用实例</strong>：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p><p><strong>优点：</strong> 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。</p><p><strong>缺点：</strong> 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p><p><strong>使用场景：</strong> 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</p><p><strong>注意事项</strong>：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/14/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="访问者模式"></p><ul><li>ObjectStructure</li></ul><p>这个角色就是我们的对象结构，对应上面的大忽悠科技有限公司：<code>BigHuYouCompany</code>。此对象结构包含各种元素，而且要求元素稳定且可以迭代访问这些元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectStructure</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> List&lt;CorporateSlave&gt; employee= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectStructure</span><span class="params">()</span> &#123;  </span><br><span class="line">        employee.add(<span class="keyword">new</span> <span class="title class_">Programmer</span>(<span class="string">&quot;王二狗&quot;</span>));  </span><br><span class="line">        employee.add(<span class="keyword">new</span> <span class="title class_">HumanSource</span>(<span class="string">&quot;上官无需&quot;</span>));  </span><br><span class="line">        employee.add(<span class="keyword">new</span> <span class="title class_">Tester</span>(<span class="string">&quot;牛翠花&quot;</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startProject</span><span class="params">(CorporateSlaveVisitor visitor)</span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (CorporateSlave slave : employee) &#123;  </span><br><span class="line">            slave.accept(visitor);  </span><br><span class="line">        &#125;    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Visitor</li></ul><p>大名鼎鼎的访问者，它是一个接口。里面定义了与元素对应的<code>visite(Element)</code>方法，一般是有几个元素就相应的有几个visite方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CorporateSlaveVisitor</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Programmer programmer)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(HumanSource humanSource)</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Tester tester)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConcreteVisitor</li></ul><p>visitor的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiveApp</span> <span class="keyword">implements</span> <span class="title class_">CorporateSlaveVisitor</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Programmer programmer)</span> &#123;  </span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%s: 最近小视频很火啊，咱能不能抄袭下抖音，搞他一炮,将来公司上市了，你的身价至少也是几千万，甚至上亿...&quot;</span>,programmer.getName()));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(HumanSource humanSource)</span> &#123;  </span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%s: 咱公司就数你长得靓，哪天化化妆，把你的事业线适当露一露，要是火了你在北京买房都不是梦...&quot;</span>,humanSource.getName()));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Tester tester)</span> &#123;  </span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;%s: 你也开个账户，边测试边直播，两不耽误...&quot;</span>,tester.getName()));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Element</li></ul><p>是一个接口，代表在ObjectStructure里面的元素。里面定义了一个<code>accept(Visiotr)</code>的方法，通过此方法元素可以将自己交给Visitor访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CorporateSlave</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(CorporateSlaveVisitor visitor)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConcreteElement</li></ul><p>element 的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Programmer</span> <span class="keyword">implements</span> <span class="title class_">CorporateSlave</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Programmer</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(CorporateSlaveVisitor visitor)</span> &#123;  </span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Client<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startProject</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="comment">//访问者模式适用于结构稳定，即元素不常变动，但元素的功能或者说是用途发生改变的情况  </span></span><br><span class="line">        ObjectStructure bigHuYou= <span class="keyword">new</span> <span class="title class_">ObjectStructure</span>();  </span><br><span class="line">        <span class="comment">//可以很轻松的更换Visitor，但是要求BigHuYouCompany的结构稳定  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------启动社交APP项目--------------------&quot;</span>);  </span><br><span class="line">        bigHuYou.startProject(<span class="keyword">new</span> <span class="title class_">SocialApp</span>());  </span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------启动短视频APP项目--------------------&quot;</span>);  </span><br><span class="line">        bigHuYou.startProject(<span class="keyword">new</span> <span class="title class_">LiveApp</span>());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/2023/08/13/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/13/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p><p><strong>主要解决</strong>：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p><p><strong>何时使用</strong>：在某些场合，比如要对行为进行”记录、撤销&#x2F;重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p><p><strong>如何解决</strong>：通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。</p><p><strong>定义三个角色</strong>：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口</p><p><strong>应用实例</strong>：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p><p><strong>优点：</strong> 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。</p><p><strong>缺点</strong>：使用命令模式可能会导致某些系统有过多的具体命令类。</p><p><strong>使用场景</strong>：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</p><p><strong>注意事项</strong>：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/13/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" alt="命令模式"></p><ul><li><strong>Receiver接受者角色</strong>：该角色就是干活的角色，命令传递到这里是应该被执行的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stock</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;ABC&quot;</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> <span class="number">10</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Stock [ Name: &quot;</span>+ name + <span class="string">&quot;, Quantity: &quot;</span> + quantity +<span class="string">&quot; ] bought&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Stock [ Name: &quot;</span>+name+<span class="string">&quot;, Quantity: &quot;</span> + quantity +<span class="string">&quot; ] sold&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>Command命令角色</strong>：需要执行的所有命令都在这里声明<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Order</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyStock</span> <span class="keyword">implements</span> <span class="title class_">Order</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Stock abcStock;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BuyStock</span><span class="params">(Stock abcStock)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.abcStock = abcStock;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;  </span><br><span class="line">        abcStock.buy();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellStock</span> <span class="keyword">implements</span> <span class="title class_">Order</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Stock abcStock;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SellStock</span><span class="params">(Stock abcStock)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.abcStock = abcStock;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;  </span><br><span class="line">        abcStock.sell();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Invoker调用者角色</strong>：接收到命令，并执行命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Broker</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orderList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Order&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeOrder</span><span class="params">(Order order)</span>&#123;  </span><br><span class="line">        orderList.add(order);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrders</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (Order order : orderList) &#123;  </span><br><span class="line">            order.execute();  </span><br><span class="line">        &#125;        orderList.clear();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Stock</span> <span class="variable">abcStock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stock</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">BuyStock</span> <span class="variable">buyStockOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyStock</span>(abcStock);  </span><br><span class="line">        <span class="type">SellStock</span> <span class="variable">sellStockOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellStock</span>(abcStock);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Broker</span> <span class="variable">broker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Broker</span>();  </span><br><span class="line">        broker.takeOrder(buyStockOrder);  </span><br><span class="line">        broker.takeOrder(sellStockOrder);  </span><br><span class="line">  </span><br><span class="line">        broker.placeOrders();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板模式</title>
      <link href="/2023/08/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决</strong>：一些方法通用，却在每一个子类都重新写了这一方法。</p><p><strong>何时使用</strong>：有一些通用的方法。</p><p><strong>如何解决</strong>：将这些通用算法抽象出来。</p><p><strong>关键代码</strong>：在抽象类实现，其他步骤在子类实现。</p><p><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p><p><strong>优点：</strong> 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。</p><p><strong>缺点</strong>：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><p><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p><p><strong>注意事项</strong>：为防止恶意操作，一般模板方法都加上 final 关键词。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/12/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F.png" alt="模板模式"></p><ul><li><strong>AblstractClass（抽象类）</strong>：在抽象类中定义了一系列的操作PrimitiveOperation，每个操作可以使具体的，也可以是抽象的，每个操作对应一个算法的步骤，在子类中可以重新定义或实现这些步骤。TmplateMethod()这个方法用于定义一个算法结构，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;  </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>;  </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;  </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="comment">//初始化  </span></span><br><span class="line">        init();  </span><br><span class="line">        <span class="comment">//开始  </span></span><br><span class="line">        start();  </span><br><span class="line">        <span class="comment">//结束  </span></span><br><span class="line">        end();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>ConcreteClass（具体子类）</strong>：用于实现在父类中声明的抽象基本操作，也可以覆盖在父类中已经实现的具体基本操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FootBall</span> <span class="keyword">extends</span> <span class="title class_">Game</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Initialized! Start playing.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Started. Enjoy the game!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Finished!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasketBall</span> <span class="keyword">extends</span> <span class="title class_">Game</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;BasketBall Game Initialized! Start playing.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;BasketBall Game Started. Enjoy the game!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;BasketBall Game Finished!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2023/08/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：为其他对象提供一种代理以控制对这个对象的访问。</p><p><strong>主要解决</strong>：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p><p><strong>何时使用</strong>：想在访问一个类时做一些控制。</p><p><strong>如何解决</strong>：增加中间层。</p><p><strong>关键代码</strong>：实现与被代理类组合。</p><p><strong>应用实例：</strong> 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。</p><p><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。</p><p><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p><p><strong>使用场景</strong>：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p><p><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="代理模式"></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ul><li>抽象角色：通过接口或抽象类声明真实角色实现的业务方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Image</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProxy</span> <span class="keyword">implements</span> <span class="title class_">Image</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RealImage realImage;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageProxy</span><span class="params">(RealImage realImage)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.realImage = realImage;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;前置要求。。。&quot;</span>);  </span><br><span class="line">        realImage.display();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealImage</span> <span class="keyword">implements</span> <span class="title class_">Image</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;display&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><strong>JDK动态代理</strong>：代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理，只能够代理实现了接口的委托类，底层使用反射机制进行方法的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Image</span> <span class="variable">realImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealImage</span>();  </span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(realImage);  </span><br><span class="line">        <span class="type">Image</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Image) Proxy.newProxyInstance(realImage.getClass().getClassLoader(),   </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Image.class&#125;,   </span><br><span class="line">invocationHandler);  </span><br><span class="line">        proxyInstance.display();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Object target;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.target = target;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;jdk动态代理&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CGLIB"><a href="#CGLIB" class="headerlink" title="CGLIB"></a>CGLIB</h2><p><strong>CGLib动态代理</strong>：代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理。不能对final类以及final方法进行代理，底层将方法全部存入一个数组中，通过数组索引直接进行方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似jdk动态代理中的Proxy类  </span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();  </span><br><span class="line">        <span class="comment">//设置目标类的字节码文件  </span></span><br><span class="line">        enhancer.setSuperclass(RealImage.class);  </span><br><span class="line">        <span class="comment">//设置回调函数  </span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>());  </span><br><span class="line">        <span class="comment">//调用create方法正式创建代理对象  </span></span><br><span class="line">        <span class="type">RealImage</span> <span class="variable">o</span> <span class="operator">=</span> (RealImage) enhancer.create();  </span><br><span class="line">  </span><br><span class="line">        o.display();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     *     * <span class="doctag">@param</span> o 表示要增强的类  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 表示要拦截的方法  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 表示要被拦截的方法的参数  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 表示要触发父类的方法对象  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable 异常  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">&quot;cglib动态代理&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(o, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/2023/08/10/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/10/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：运用共享技术有效地支持大量细粒度的对象。</p><p><strong>主要解决</strong>：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p><p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p><p><strong>如何解决</strong>：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p><p><strong>关键代码</strong>：用 HashMap 存储这些对象。</p><p><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的连接池。</p><p><strong>优点</strong>：大大减少对象的创建，降低系统的内存，使效率提高。</p><p><strong>缺点</strong>：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p><p><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。</p><p><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/10/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png" alt="享元模式"></p><ul><li><p>享元工厂（ShapeFactory）：用于创建具体享元类，维护相同的享元对象。当请求对象已经存在时，直接返回对象，不存在时，在创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String,Shape&gt; circleMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title function_">getCircle</span><span class="params">(String color)</span>&#123;  </span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> (Circle) circleMap.get(color);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span>(circle == <span class="literal">null</span>)&#123;  </span><br><span class="line">            circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(color);  </span><br><span class="line">            circleMap.put(color,circle);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> circle;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象享元（Shape）：定义需要共享的对象业务接口。享元类被创建出来总是为了实现某些特定的业务逻辑.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体享元（ConcreteBook）：实现抽象享元类的接口，完成某一具体逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String color;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> radius;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(String color)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.color = color;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.x = x;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">int</span> y)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.y = y;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">int</span> radius)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.radius = radius;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Circle: Draw() [Color : &quot;</span> + color  </span><br><span class="line">                +<span class="string">&quot;, x : &quot;</span> + x +<span class="string">&quot;, y :&quot;</span> + y +<span class="string">&quot;, radius :&quot;</span> + radius);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: DesignPattern  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 享元模式，换句话说就是共享对象，在某些对象需要重复创建，且最终只需要得到单一结果的情况下使用。因为此种模式是利用先前创建的已有对象，  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 通过某种规则去判断当前所需对象是否可以利用原有对象做相应修改后得到想要的效果，如以上教程的实例，创建了20个不同效果的圆，但相同颜色的圆只需要创建一次便可，  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 相同颜色的只需要引用原有对象，改变其坐标值便可。此种模式下，同一颜色的圆虽然位置不同，但其地址都是同一个，所以说此模式适用于结果注重单一结果的情况。  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: kris  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2023-08-10 14:59  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String colors[] =  </span><br><span class="line">            &#123; <span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Blue&quot;</span>, <span class="string">&quot;White&quot;</span>, <span class="string">&quot;Black&quot;</span> &#125;;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;  </span><br><span class="line">            <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span>  </span><br><span class="line">                    (Circle)ShapeFactory.getCircle(getRandomColor());  </span><br><span class="line">            circle.setX(getRandomX());  </span><br><span class="line">            circle.setY(getRandomY());  </span><br><span class="line">            circle.setRadius(<span class="number">100</span>);  </span><br><span class="line">            circle.draw();  </span><br><span class="line">        &#125;    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getRandomColor</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> colors[(<span class="type">int</span>)(Math.random()*colors.length)];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRandomX</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(Math.random()*<span class="number">100</span> );  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRandomY</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(Math.random()*<span class="number">100</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Integer类中的享元模式"><a href="#Integer类中的享元模式" class="headerlink" title="Integer类中的享元模式"></a>Integer类中的享元模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="comment">// high value may be configured by property  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span>  </span><br><span class="line">            VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);  </span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);  </span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);  </span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE  </span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;  </span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;        high = h;  </span><br><span class="line">  </span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];  </span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)  </span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)  </span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在该类中，会先将-128–127的数存入缓存中，当获取这个范围中的数时将会直接返回这个缓存中的已经创建好的对象</strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观模式</title>
      <link href="/2023/08/04/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/04/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</p><p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p><strong>主要解决</strong>：降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。</p><p><strong>何时使用：</strong> 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。</p><p><strong>如何解决</strong>：客户端不与系统耦合，外观类与系统耦合。</p><p><strong>关键代码</strong>：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p><p><strong>应用实例：</strong> 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。</p><p><strong>优点：</strong> 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。</p><p><strong>缺点</strong>：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p><p><strong>使用场景：</strong> 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。</p><p><strong>注意事项</strong>：在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/04/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/Client.png" alt="Client"></p><ul><li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Cpu cpu;  </span><br><span class="line">    <span class="keyword">private</span> Ssd ssd;  </span><br><span class="line">    <span class="keyword">private</span> Ddr ddr;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Facade</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.cpu = <span class="keyword">new</span> <span class="title class_">Cpu</span>();  </span><br><span class="line">        <span class="built_in">this</span>.ssd = <span class="keyword">new</span> <span class="title class_">Ssd</span>();  </span><br><span class="line">        <span class="built_in">this</span>.ddr = <span class="keyword">new</span> <span class="title class_">Ddr</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;  </span><br><span class="line">        cpu.start();  </span><br><span class="line">        ssd.start();  </span><br><span class="line">        ddr.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cpu</span> <span class="keyword">implements</span> <span class="title class_">Computer</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;CPU start&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure></li><li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Facade</span> <span class="variable">facade</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();  </span><br><span class="line">        facade.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/2023/08/03/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/03/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p><p>我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p><strong>主要解决</strong>：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><p><strong>何时使用：</strong> 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p><strong>如何解决</strong>：树枝和叶子实现统一接口，树枝内部组合该接口。</p><p><strong>关键代码</strong>：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p><p><strong>应用实例：</strong> 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p><p><strong>优点：</strong> 1、高层模块调用简单。 2、节点自由增加。</p><p><strong>缺点</strong>：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p><p><strong>使用场景</strong>：部分、整体场景，如树形菜单，文件、文件夹的管理。</p><p><strong>注意事项</strong>：定义时为具体类。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/03/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/Bags.png" alt="Compisite"></p><ul><li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 抽象构件：物品  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Articles</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">calculation</span><span class="params">()</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Articles</span>&#123;  </span><br><span class="line">    <span class="comment">//名字  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="comment">//数量  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> quantity;  </span><br><span class="line">    <span class="comment">//单价  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> unitPrice;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Goods</span><span class="params">(String name, <span class="type">int</span> quantity, <span class="type">float</span> unitPrice)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">        <span class="built_in">this</span>.quantity = quantity;  </span><br><span class="line">        <span class="built_in">this</span>.unitPrice = unitPrice;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">calculation</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> quantity * unitPrice;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(name + <span class="string">&quot;(数量：&quot;</span> + quantity + <span class="string">&quot;，单价：&quot;</span> + unitPrice + <span class="string">&quot;元)&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>树枝构件（Composite）角色 &#x2F; 中间构件：是组合中的分支节点对象，它有子节点，用于继承和实现抽象构件。它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 树枝构件：袋子  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bags</span> <span class="keyword">implements</span> <span class="title class_">Articles</span> &#123;  </span><br><span class="line">    <span class="comment">//名字  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Articles&gt; bags = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Articles&gt;();  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bags</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Articles c)</span> &#123;  </span><br><span class="line">        bags.add(c);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Articles c)</span> &#123;  </span><br><span class="line">        bags.remove(c);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> Articles <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> bags.get(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">calculation</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">float</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (Object obj : bags) &#123;  </span><br><span class="line">            s += ((Articles) obj).calculation();  </span><br><span class="line">        &#125;        <span class="keyword">return</span> s;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (Object obj : bags) &#123;  </span><br><span class="line">            ((Articles) obj).show();  </span><br><span class="line">        &#125;    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰者模式</title>
      <link href="/2023/08/02/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/02/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>装饰器模式通过将对象包装在装饰器类中，以便动态地修改其行为。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p><strong>主要解决</strong>：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><p><strong>何时使用</strong>：在不想增加很多子类的情况下扩展类。</p><p><strong>如何解决</strong>：将具体功能职责划分，同时继承装饰者模式。</p><p><strong>关键代码：</strong> 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p><p><strong>应用实例：</strong> 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p><p><strong>优点</strong>：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p><strong>缺点</strong>：多层装饰比较复杂。</p><p><strong>使用场景：</strong> 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p><p><strong>注意事项</strong>：可代替继承。</p><p>装饰器模式通过嵌套包装多个装饰器对象，可以实现多层次的功能增强。每个具体装饰器类都可以选择性地增加新的功能，同时保持对象接口的一致性。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/02/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/Drink.png" alt="Drink"></p><ul><li><p>抽象组件（Component）：定义了原始对象和装饰器对象的公共接口或抽象类，可以是具体组件类的父类或接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Drink</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">des</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">    <span class="type">float</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0.0f</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> des;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDes</span><span class="params">(String des)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.des = des;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> price;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">float</span> price)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.price = price;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体组件（Concrete Component）：是被装饰的原始对象，它定义了需要添加新功能的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">Drink</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    Coffee()&#123;  </span><br><span class="line">        setDes(<span class="string">&quot;coffee&quot;</span>);  </span><br><span class="line">        setPrice(<span class="number">10.0f</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> getPrice();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象装饰器（Decorator）：继承自抽象组件，它包含了一个抽象组件对象，并定义了与抽象组件相同的接口，同时可以通过组合方式持有其他装饰器对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Drink</span>&#123;  </span><br><span class="line">    Drink drink;  </span><br><span class="line">  </span><br><span class="line">    Decorator(Drink drink)&#123;  </span><br><span class="line">        <span class="built_in">this</span>.drink = drink;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> getPrice() + drink.cost();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDes</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> des + <span class="string">&quot; &quot;</span> + getPrice() +<span class="string">&quot; &quot;</span>+ drink.getDes() ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体装饰器（Concrete Decorator）：实现了抽象装饰器的接口，负责向抽象组件添加新的功能。具体装饰器通常会在调用原始对象的方法之前或之后执行自己的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Clip</span>  <span class="keyword">extends</span>  <span class="title class_">Decorator</span>&#123;  </span><br><span class="line">    Clip(Drink drink) &#123;  </span><br><span class="line">        <span class="built_in">super</span>(drink);  </span><br><span class="line">        setDes(<span class="string">&quot;Clip&quot;</span>);  </span><br><span class="line">        setPrice(<span class="number">1.0f</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"><span class="comment">// 对于饮料与零食的组合有很多，使用装饰者模式进行一层套一层可以实现不同的组合方式  </span></span><br><span class="line"><span class="comment">//当想拓展饮料或者零食的种类时，只需要继承对应的类，然后进行嵌套即可</span></span><br><span class="line">        <span class="comment">//我需要一杯Cola 加上 Clip 和 Chocolate        Drink drink = new Cola();  </span></span><br><span class="line">        System.out.println(drink.cost());  </span><br><span class="line">        System.out.println(drink.getDes());  </span><br><span class="line">  </span><br><span class="line">        drink = <span class="keyword">new</span> <span class="title class_">Clip</span>(drink);  </span><br><span class="line">        System.out.println(drink.cost());  </span><br><span class="line">        System.out.println(drink.getDes());  </span><br><span class="line">  </span><br><span class="line">        drink = <span class="keyword">new</span> <span class="title class_">Chocolate</span>(drink);  </span><br><span class="line">        System.out.println(drink.cost());  </span><br><span class="line">        System.out.println(drink.getDes());  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//        Drink drink1 = new Chocolate(new Chocolate(new Clip(new Cola())));  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Java-IO-中的装饰者模式"><a href="#Java-IO-中的装饰者模式" class="headerlink" title="Java IO 中的装饰者模式"></a>Java IO 中的装饰者模式</h1><p><img src="/2023/08/02/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/FileInputStream.png" alt="FileInputStream"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="/2023/08/01/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/01/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p><p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类，这两种类型的类可被结构化改变而互不影响。</p><p>桥接模式的目的是将抽象与实现分离，使它们可以独立地变化，该模式通过将一个对象的抽象部分与它的实现部分分离，使它们可以独立地改变。它通过组合的方式，而不是继承的方式，将抽象和实现的部分连接起来。</p><p>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：将抽象部分与实现部分分离，使它们都可以独立的变化。</p><p><strong>主要解决</strong>：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p><p><strong>何时使用</strong>：实现系统可能有多个角度分类，每一种角度都可能变化。</p><p><strong>如何解决</strong>：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p><p><strong>关键代码</strong>：抽象类依赖实现类。</p><p><strong>应用实例：</strong> 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</p><p><strong>优点：</strong> 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。</p><p><strong>缺点</strong>：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p><p><strong>使用场景：</strong> 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p><p><strong>注意事项</strong>：对于两个独立变化的维度，使用桥接模式再适合不过了。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/08/01/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/Coffee.png" alt="Coffee"></p><ul><li>抽象（Abstraction）：定义抽象接口，通常包含对实现接口的引用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;  </span><br><span class="line">    CoffeeOperation coffeeOperation;  </span><br><span class="line">  </span><br><span class="line">    Coffee(CoffeeOperation coffeeOperation)&#123;  </span><br><span class="line">        <span class="built_in">this</span>.coffeeOperation = coffeeOperation;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">orderCoffee</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>扩展抽象（Refined Abstraction）：对抽象的扩展，可以是抽象类的子类或具体实现类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargerCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;  </span><br><span class="line">    LargerCoffee(CoffeeOperation coffeeOperation) &#123;  </span><br><span class="line">        <span class="built_in">super</span>(coffeeOperation);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderCoffee</span><span class="params">()</span> &#123;  </span><br><span class="line">        coffeeOperation.add();  </span><br><span class="line">        System.out.println(<span class="string">&quot;大杯咖啡&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实现（Implementor）：定义实现接口，提供基本操作的接口。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeOperation</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>具体实现（Concrete Implementor）：实现实现接口的具体类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkCoffee</span> <span class="keyword">implements</span> <span class="title class_">CoffeeOperation</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;加奶&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SugarCoffee</span> <span class="keyword">implements</span> <span class="title class_">CoffeeOperation</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;加糖&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Client<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 通过将咖啡的类型 和 咖啡操作的不同组合分别抽象聚合起来 实现两个抽象的部分可以自己独立的发展  </span></span><br><span class="line"><span class="comment"> * 即当我想点smallCoffee时，只需要继承Coffee这个抽象类，我就同时获得了加糖和加奶这两种操作，解决了类爆炸问题  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LargerCoffee</span>(<span class="keyword">new</span> <span class="title class_">MilkCoffee</span>());  </span><br><span class="line">        coffee.orderCoffee();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2023/07/31/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/07/31/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p><p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p><p>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>主要解决</strong>：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><p><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p><p><strong>如何解决</strong>：继承或依赖（推荐）。</p><p><strong>关键代码</strong>：适配器继承或依赖已有的对象，实现想要的目标接口。</p><p><strong>应用实例：</strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</p><p><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p><p><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p><p><strong>使用场景</strong>：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p><strong>注意事项</strong>：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul><li><strong>Target</strong>  是一个接口，它是我们客户端使用的目标接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;sdcard read a msg :hello word SD&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;      </span><br><span class="line">        System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Adaptee</strong> 我们想要使用的接口与<code>Target</code>不兼容的类，它可以是一个接口，也可以是一个类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> &#123;    </span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">&quot;tf card reade msg : hello word tf card&quot;</span>;        </span><br><span class="line">        <span class="keyword">return</span> msg;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> &#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Adapter</strong> 适配器类，此模式的核心。它需要实现目标接口<code>Target</code>，而且必须要引用<code>Adaptee</code>，因为我们要在此类中包装<code>Adaptee</code>的功能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;    </span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> &#123;        </span><br><span class="line">        <span class="built_in">this</span>.tfCard = tfCard;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);        </span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);        </span><br><span class="line">        <span class="keyword">return</span> tfCard.writeTF(msg);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2023/07/29/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/07/29/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图</strong>：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>主要解决</strong>：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p><strong>何时使用</strong>：一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>如何解决</strong>：将变与不变分离开。</p><p><strong>关键代码</strong>：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。</p><p><strong>优点：</strong></p><ul><li>分离构建过程和表示，使得构建过程更加灵活，可以构建不同的表示。</li><li>可以更好地控制构建过程，隐藏具体构建细节。</li><li>代码复用性高，可以在不同的构建过程中重复使用相同的建造者。</li></ul><p><strong>缺点：</strong></p><ul><li>如果产品的属性较少，建造者模式可能会导致代码冗余。</li><li>建造者模式增加了系统的类和对象数量。</li></ul><p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p><p>建造者模式在创建复杂对象时非常有用，特别是当对象的构建过程涉及多个步骤或参数时。它可以提供更好的灵活性和可维护性，同时使得代码更加清晰可读。</p><p><strong>注意事项</strong>：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/2023/07/29/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8FUML%E5%9B%BE.png" alt="建造者模式UML图.drawio"></p><ul><li> <strong>建造者角色</strong>：定义生成实例所需要的所有方法；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPart1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPart2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildPart3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li> <strong>具体的建造者角色</strong>：实现生成实例所需要的所有方法，并且定义获取最终生成实例的方法；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildPart1</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;1111&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildPart2</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;2222&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildPart3</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;3333&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li> <strong>监工角色</strong>：定义使用建造者角色中的方法来生成实例的方法；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> Builder builder;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.builder = builder;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBuilder</span><span class="params">(Builder builder)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.builder = builder;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 在construct方法中构建算法，来确认不同步骤的组合方式  </span></span><br><span class="line"><span class="comment">     * 以肯德基点餐为例  可以单点，点套餐  </span></span><br><span class="line"><span class="comment">     * 其组合方式是不确定的，就可以在在construct方法中来构建组合而不会影响到Client端的调用  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">construct</span><span class="params">()</span>&#123;  </span><br><span class="line">        builder.buildPart1();  </span><br><span class="line">        builder.buildPart2();  </span><br><span class="line">        builder.buildPart2();  </span><br><span class="line">        builder.buildPart3();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li> <strong>使用者</strong>：使用建造者模式。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">//建造者  </span></span><br><span class="line">        <span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteBuilder</span>();  </span><br><span class="line">        <span class="comment">//监工  </span></span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);  </span><br><span class="line">        <span class="comment">//创建  </span></span><br><span class="line">        director.construct();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="传统Builder方式的变种"><a href="#传统Builder方式的变种" class="headerlink" title="传统Builder方式的变种"></a>传统Builder方式的变种</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Computer</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu=builder.cpu;</span><br><span class="line">        <span class="built_in">this</span>.ram=builder.ram;</span><br><span class="line">        <span class="built_in">this</span>.usbCount=builder.usbCount;</span><br><span class="line">        <span class="built_in">this</span>.keyboard=builder.keyboard;</span><br><span class="line">        <span class="built_in">this</span>.display=builder.display;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">        <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(String cup,String ram)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.cpu=cup;</span><br><span class="line">            <span class="built_in">this</span>.ram=ram;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setUsbCount</span><span class="params">(<span class="type">int</span> usbCount)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.usbCount = usbCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setKeyboard</span><span class="params">(String keyboard)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.keyboard = keyboard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setDisplay</span><span class="params">(String display)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//省略getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Computer computer=<span class="keyword">new</span> <span class="title class_">Computer</span>.Builder(<span class="string">&quot;因特尔&quot;</span>,<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">                .setDisplay(<span class="string">&quot;三星24寸&quot;</span>)</span><br><span class="line">                .setKeyboard(<span class="string">&quot;罗技&quot;</span>)</span><br><span class="line">                .setUsbCount(<span class="number">2</span>)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure></li></ul><p><strong>省略了director 这个角色，将构建算法交给了client端，其次将builder 写到了要构建的产品类里面，最后采用了链式调用</strong></p><h1 id="StringBuilder中的建造者模式"><a href="#StringBuilder中的建造者模式" class="headerlink" title="StringBuilder中的建造者模式"></a>StringBuilder中的建造者模式</h1><p><img src="/2023/07/29/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/StringBuilder%E4%B8%AD%E7%9A%84%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="StringBuilder中的建造者模式"></p><p>StringBuilder 中 并没有使用传统的建造者模式，而是使用了建筑模式的变种将组合方式交给了Client采用了链式调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(CharSequence s)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>.append(s);  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(CharSequence s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>.append(s, start, end);  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(<span class="type">char</span>[] str)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>.append(str);  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2023/07/28/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/07/28/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。</p><p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p><strong>主要解决：</strong>在运行期建立和删除原型。</p><p><strong>何时使用：</strong> 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p><p><strong>如何解决：</strong>利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p><p><strong>关键代码：</strong> 1、实现克隆操作，在 JAVA 实现 Cloneable 接口，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。</p><p><strong>应用实例：</strong> 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。</p><p><strong>优点：</strong> 1、性能提高。 2、逃避构造函数的约束。</p><p><strong>缺点：</strong> 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</p><p><strong>使用场景：</strong> 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p><p><strong>注意事项：</strong>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul><li><p><strong>原型角色</strong> ：定义用于复杂现有实例来生成新实例的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以贴主示例代码为例  </span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Cloneable</span>   <span class="comment">// 1.（抽象类或者接口）实现 java.lang.Cloneable 接口</span></span><br><span class="line"><span class="keyword">public</span> Shape <span class="title function_">clone</span><span class="params">()</span>;  <span class="comment">// 2.定义复制现有实例来生成新实例的方法</span></span><br></pre></td></tr></table></figure></li><li><p><strong>具体原型角色</strong> ：实现用于复制现有实例来生成新实例的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shape <span class="title function_">clone</span><span class="params">()</span> &#123;<span class="comment">// 2.实现复制现有实例来生成新实例的方法（也可以由超类完成）</span></span><br><span class="line">    <span class="type">Shape</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clone = (Shape) clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用者角色</strong> ：维护一个注册表，并提供一个找出正确实例原型的方法。最后，提供一个获取新实例的方法，用来委托复制实例的方法生成新实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Hashtable&lt;String, Shape&gt; shapeMap = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;String, Shape&gt;();<span class="comment">//维护一个注册表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadCache</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">    circle.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    shapeMap.put(circle.getId(),circle);</span><br><span class="line"></span><br><span class="line">    <span class="type">Square</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">    square.setId(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    shapeMap.put(square.getId(),square);</span><br><span class="line"></span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">    rectangle.setId(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    shapeMap.put(rectangle.getId(),rectangle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeId)</span> &#123;<span class="comment">//提供一个获取新实例的方法</span></span><br><span class="line">    <span class="type">Shape</span> <span class="variable">cachedShape</span> <span class="operator">=</span> shapeMap.get(shapeId);<span class="comment">//提供一个找出正确实例原型的方法</span></span><br><span class="line">    <span class="keyword">return</span> (Shape) cachedShape.clone();<span class="comment">//委托复制实例的方法生成新实例。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2023/07/27/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/07/27/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>工厂模式提供了一种将对象的实例化过程封装在工厂类中的方式。通过使用工厂模式，可以将对象的创建与使用代码分离，提供一种统一的接口来创建不同类型的对象。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><span id="more"></span><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><blockquote><p>简单工厂不算是一个真正的设计模式，而更像是一种我们的编程习惯，但是在平时编码中这不失为一个简单的方法，可以将客户程序从具体类解耦。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>工厂类拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。</p><p><img src="/2023/07/27/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="简单工厂模式"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><p>优点：</p><ul><li>很明显，简单工厂的特点就是“简单粗暴”，通过一个含参的工厂方法，我们可以实例化任何产品类，上至飞机火箭，下至土豆面条，无所不能。</li></ul></li><li><p>缺点：</p><ul><li>任何”东西“的子类都可以被生产，负担太重。当所要生产产品种类非常多时，工厂方法的代码量可能会很庞大。</li><li>在遵循开闭原则（对拓展开放，对修改关闭）的条件下，简单工厂对于增加新的产品，无能为力。因为增加新产品只能通过修改工厂方法来实现。</li></ul></li></ul><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><blockquote><p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类。<br><img src="/2023/07/27/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="工厂模式"></p></blockquote><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h2><ul><li><p>优点</p><ul><li>工厂方法模式就很好的减轻了工厂类的负担，把某一类&#x2F;某一种东西交由一个工厂生产；（对应简单工厂的缺点1。</li><li>同时增加某一类 ”东西“ 并不需要修改工厂类，只需要添加生产这类 ”东西“ 的工厂即可，使得工厂类符合开放-封闭原则。</li></ul></li><li><p>缺点</p><ul><li>对于某些可以形成产品族（一组产品）的情况处理比较复杂。</li></ul></li></ul><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><blockquote><p>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p></blockquote><p><img src="/2023/07/27/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="抽象工厂模式"></p><h1 id="工厂模式区别"><a href="#工厂模式区别" class="headerlink" title="工厂模式区别"></a>工厂模式区别</h1><ul><li>简单工厂 ： 使用一个工厂对象用来生产同一等级结构中的任意产品。（不支持拓展增加产品）</li><li>工厂方法 ： 使用多个工厂对象用来生产同一等级结构中对应的固定产品。（支持拓展增加产品）</li><li>抽象工厂 ： 使用多个工厂对象用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）</li></ul><h1 id="工厂模式在JDK中的使用"><a href="#工厂模式在JDK中的使用" class="headerlink" title="工厂模式在JDK中的使用"></a>工厂模式在JDK中的使用</h1><h2 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h2><ul><li>使用了简单工厂模式</li></ul><p><img src="/2023/07/27/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/JDK%E4%B8%AD%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8.png" alt="JDK中简单工厂模式的使用"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断二分图</title>
      <link href="/2023/07/26/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
      <url>/2023/07/26/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。给你一个二维数组 <code>graph</code> ，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于 <code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：</p><ul><li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li><li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li><li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li><li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li></ul><p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p><p>如果图是二分图，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><span id="more"></span><h1 id="染色问题-DFS"><a href="#染色问题-DFS" class="headerlink" title="染色问题 DFS"></a>染色问题 DFS</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">UNCOLORED</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">RED</span>  <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">GREEN</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 染色问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//节点个数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line"></span><br><span class="line">        color = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历节点进行染色</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果该点没有被染色 则进行染色</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(color[i] == UNCOLORED)&#123;</span><br><span class="line"></span><br><span class="line">                colored(graph,RED,i);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">colored</span><span class="params">(<span class="type">int</span>[][] graph,<span class="type">int</span> c,<span class="type">int</span> index)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//染色</span></span><br><span class="line"></span><br><span class="line">        color[index] = c;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下次染色的颜色</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nc</span> <span class="operator">=</span> c == RED ? GREEN : RED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历与该点相邻的点，对其进行染色</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> point : graph[index]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果该点没有被染色 则进行染色</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(color[point] == UNCOLORED)&#123;</span><br><span class="line"></span><br><span class="line">                colored(graph, nc, point);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果该点已经有颜色且与本次要染的颜色不一致</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//说明该图不是二分图</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(color[point] != nc)&#123;</span><br><span class="line"></span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>743.网络延迟时间</title>
      <link href="/2023/07/24/%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/"/>
      <url>/2023/07/24/%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有 <code>n</code> 个网络节点，标记为 <code>1</code> 到 <code>n</code>。</p><p>给你一个列表 <code>times</code>，表示信号经过 <strong>有向</strong> 边的传递时间。 <code>times[i] = (ui, vi, wi)</code>，其中 <code>ui</code> 是源节点，<code>vi</code> 是目标节点， <code>wi</code> 是一个信号从源节点传递到目标节点的时间。</p><p>现在，从某个节点 <code>K</code> 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 <code>-1</code> 。</p><span id="more"></span><h1 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化图  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//graph[i][j] 为 i 到 j 的距离 刚开始初始化为无穷</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] graph = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            Arrays.fill(graph[i], Integer.MAX_VALUE/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] is : times) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">source</span> <span class="operator">=</span> is[<span class="number">0</span>]-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">des</span> <span class="operator">=</span> is[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> is[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            graph[source][des] = weight;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录已经选中的点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//距离表,记录当前节点距离以及选中的节点集合的最短距离</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(dist,Integer.MAX_VALUE/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化最开始的节点为0</span></span><br><span class="line"></span><br><span class="line">        dist[k-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一次选中一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//寻找最短距离的节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!visited[j] &amp;&amp; (cur == -<span class="number">1</span> || dist[j] &lt; dist[cur]))&#123;</span><br><span class="line"></span><br><span class="line">                    cur = j;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到之后将其加入</span></span><br><span class="line"></span><br><span class="line">            visited[cur] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新与其相邻节点的距离</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"></span><br><span class="line">                dist[j] = Math.min(dist[j], dist[cur]+graph[cur][j]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历距离表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果还有无穷大的节点说明无法到达，返回-1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//否则返回最远的节点距离</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(dist[j] == Integer.MAX_VALUE/<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = Math.max(res, dist[j]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>207.课程表问题</title>
      <link href="/2023/07/22/%E8%AF%BE%E7%A8%8B%E8%A1%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/22/%E8%AF%BE%E7%A8%8B%E8%A1%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程  <code>bi</code> 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><span id="more"></span><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录节点的入度</span></span><br><span class="line"></span><br><span class="line">        Map&lt;Integer,Integer&gt; inDegree = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将节点放入哈希表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line"></span><br><span class="line">            inDegree.put(i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录节点的邻接表</span></span><br><span class="line"></span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; adj = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] is : prerequisites) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> is[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> is[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新节点的入度</span></span><br><span class="line"></span><br><span class="line">            inDegree.put(next, inDegree.get(next) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建该节点的邻接表</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!adj.containsKey(cur))&#123;</span><br><span class="line"></span><br><span class="line">                adj.put(cur, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            adj.get(cur).add(next);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//将入度为0的节点放入队列中</span></span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> key : inDegree.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(inDegree.get(key) == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                queue.offer(key);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//从入度为0的节点开始遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//每遍历一个节点就减少它连接节点的入度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这个节点没有相连节点就继续</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!adj.containsKey(cur))&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//有的话减少其节点的入度</span></span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; otherNode = adj.get(cur);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Integer integer : otherNode) &#123;</span><br><span class="line"></span><br><span class="line">                inDegree.put(integer, inDegree.get(integer) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果节点的入度减为了0 则入队</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(inDegree.get(integer) == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    queue.offer(integer);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历入度表，如果还有入度不为0的节点，则这个图出现了环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer integer : inDegree.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(inDegree.get(integer) != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>98.验证二叉搜索树</title>
      <link href="/2023/07/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2023/07/05/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre!= <span class="literal">null</span> &amp;&amp; pre.val &gt;=  root.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">preValue</span> <span class="operator">=</span> -Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.empty() || root != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//先将左侧节点入栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                stack.push(root);</span><br><span class="line"></span><br><span class="line">                root = root.left;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前节点</span></span><br><span class="line"></span><br><span class="line">            root = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前节点的值小于前一个节点的值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//返回false</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.val &lt;= preValue)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//要进行下一个节点的比较</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前节点变为前一个节点，记录值</span></span><br><span class="line"></span><br><span class="line">            preValue = root.val;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历右子树</span></span><br><span class="line"></span><br><span class="line">            root = root.right;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>700.二叉搜索树中的搜索</title>
      <link href="/2023/07/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
      <url>/2023/07/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val == val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> searchBST(root.left, val);</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> searchBST(root.right, val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>617.合并二叉树</title>
      <link href="/2023/07/05/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/07/05/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root1 == <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root2 == <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val+root2.val);</span><br><span class="line"></span><br><span class="line">        root.left = mergeTrees(root1.left, root2.left);</span><br><span class="line"></span><br><span class="line">        root.right = mergeTrees(root1.right, root2.right);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>105.从前序与中序遍历序列构造二叉树</title>
      <link href="/2023/06/24/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/06/24/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> preIndex;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] inorder;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.inorder = inorder;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.preIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> backTracking(<span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preIndex];</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        preIndex++;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(rootVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line"></span><br><span class="line">        root.left = backTracking(left, index-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line"></span><br><span class="line">        root.right = backTracking(index+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>106.从中序与后序遍历序列构造二叉树</title>
      <link href="/2023/06/24/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/06/24/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> postIndex;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] postorder;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] inorder;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.inorder  = inorder;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.postorder = postorder;</span><br><span class="line"></span><br><span class="line">        postIndex = postorder.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数组中的值放入哈希表中，可以更快查找到对应下标的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> backTracking(<span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左下标大于又下标，说明没有节点了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postIndex];</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        postIndex--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到根节点在前序遍历中的位置，将其分为左子树和右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(rootVal);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建右子树</span></span><br><span class="line"></span><br><span class="line">        root.right = backTracking(index+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建左子树</span></span><br><span class="line"></span><br><span class="line">        root.left = backTracking(left, index-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>654.最大二叉树</title>
      <link href="/2023/06/23/%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/06/23/%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> <strong><em>最大二叉树</em></strong> 。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> createTree(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">createTree</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left+<span class="number">1</span>;i &lt;= right;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[max])</span><br><span class="line"></span><br><span class="line">                max = i;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[max]);</span><br><span class="line"></span><br><span class="line">        root.left = createTree(nums, left, max-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        root.right = createTree(nums, max+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(left, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.fill(right, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        TreeNode[] nodes = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            nodes[i] = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当栈不为空时，判断当前的值是否大于之前的值，</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果大于，则将之前节点的右节点指向当前的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; nums[i] &gt; nums[stack.peek()])&#123;</span><br><span class="line"></span><br><span class="line">                right[stack.pop()] = i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前栈不为空，栈顶的值就是左侧的最大值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!stack.empty())&#123;</span><br><span class="line"></span><br><span class="line">                left[i] = stack.peek();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">            stack.push(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建二叉树</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左边没有最大的右边也没有最大的，表示自身就是最大的，作为根节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(left[i] == -<span class="number">1</span> &amp;&amp; right[i] == -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">                root = nodes[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右边没有更大的 或者 两边都有比自己更大的但是右边的值更大</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//则本身放置于左边最大的节点的右边，</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right[i] == -<span class="number">1</span> ||(left[i] != -<span class="number">1</span> &amp;&amp; nums[left[i]] &lt; nums[right[i]]))&#123;</span><br><span class="line"></span><br><span class="line">                nodes[left[i]].right = nodes[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其余情况则放置于右边最大节点的左侧</span></span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                nodes[right[i]].left = nodes[i];</span><br><span class="line"></span><br><span class="line">            &#125;    </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>113.路径总和 II</title>
      <link href="/2023/06/23/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/"/>
      <url>/2023/06/23/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        backTracking(root, targetSum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(TreeNode root,<span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将当前节点加入路径</span></span><br><span class="line"></span><br><span class="line">        path.add(root.val);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前节点的值等于目标值，将路径中的所有节点存下</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.val == targetSum)&#123;</span><br><span class="line"></span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左节点不为空进行左递归</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            backTracking(root.left, targetSum-root.val);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回溯时去掉加入的值</span></span><br><span class="line"></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右节点同理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            backTracking(root.right, targetSum-root.val);</span><br><span class="line"></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>112.路径总和</title>
      <link href="/2023/06/23/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
      <url>/2023/06/23/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果根节点为空，则直接返回false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果该节点为叶子节点，则判断值是否与目标值相等</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(targetSum == root.val)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行左递归和右递归，目标值需要减去当前节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, targetSum-root.val) || hasPathSum(root.right, targetSum-root.val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>513.找树左下角的值</title>
      <link href="/2023/06/20/%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/"/>
      <url>/2023/06/20/%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><span id="more"></span><h1 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h1><blockquote><p> 可以从右到左进行遍历，这样最后一个节点就是最左边的节点</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从左往右进行层序遍历，需要保存每层遍历时的第一个节点的值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//层序遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//记录该层最左边的节点</span></span><br><span class="line"></span><br><span class="line">                    res = poll.val;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    queue.offer(poll.left);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    queue.offer(poll.right);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从右到左进行层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(p.left);</span><br><span class="line">            &#125;</span><br><span class="line">            ret = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> curVal,curHeight;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curVal;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> height)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        height++;</span><br><span class="line"></span><br><span class="line">        dfs(root.left, height);</span><br><span class="line"></span><br><span class="line">        dfs(root.right, height);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(height &gt; curHeight)&#123;</span><br><span class="line"></span><br><span class="line">            curHeight = height;</span><br><span class="line"></span><br><span class="line">            curVal = root.val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>404.左叶子之和</title>
      <link href="/2023/06/20/%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/06/20/%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><blockquote><p>我自己的解法，判断条件过于繁琐了，直接root.left!&#x3D;null &amp;&amp; root.left.left &#x3D; null &amp;&amp; root.left.right &#x3D; null就可以判断是否是左叶子，参考后面的迭代写法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只有根节点时不计算</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只在刚开始会出现根节点为空得情况，后面得递归会避免空得情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根节点为空则返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是叶子节点直接返回值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在之前得条件就会往左递归而忽略右边</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//所以不用考虑是右叶子节点得情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有左子节点得时候直接进行递归</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            left = sum(root.left);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有右子节点得时候判断他是不是叶子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不是叶子节点才进行递归</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.right.left != <span class="literal">null</span> || root.right.right != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                right = sum(root.right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回左子树和右子树的左叶子节点的和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt; ();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                result += node.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) stack.add(node.right);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) stack.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>257.二叉树的所有路径</title>
      <link href="/2023/06/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
      <url>/2023/06/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        backTracking(root, list,list2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(TreeNode root,List&lt;String&gt; res,List&lt;Integer&gt; path)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前序遍历</span></span><br><span class="line"></span><br><span class="line">        path.add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遇到叶子节点，对路径进行处理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出</span></span><br><span class="line"></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();<span class="comment">// StringBuilder用来拼接字符串，速度更快</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                sb.append(path.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sb.append(path.get(path.size() - <span class="number">1</span>));<span class="comment">// 记录最后一个节点</span></span><br><span class="line"></span><br><span class="line">            res.add(sb.toString());<span class="comment">// 收集一个路径</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左节点不为空不时进行递归</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            backTracking(root.left, res, path);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回溯时将之前加入的节点去掉</span></span><br><span class="line"></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右节点不为空时进行递归</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            backTracking(root.right, res, path);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回溯时将之前的加入的节点去掉</span></span><br><span class="line"></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>110.平衡二叉树</title>
      <link href="/2023/06/18/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/06/18/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><span id="more"></span><h1 id="自顶向上的递归"><a href="#自顶向上的递归" class="headerlink" title="自顶向上的递归"></a>自顶向上的递归</h1><blockquote><p>进行了双层递归，对节点后续节点的高度进行了重复的计算，效率较低</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算左右节点的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//高度差大于1返回false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Math.abs(right - left) &gt; <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归判断左右子树是否是平衡的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归计算左右子树的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加上本身的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自底向上的递归"><a href="#自底向上的递归" class="headerlink" title="自底向上的递归"></a>自底向上的递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count(root) &gt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归计算左右子树的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在递归的过程中就判断左右子树的平衡</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要有一个不平衡后面都会直接返回-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span> || right == -<span class="number">1</span> || Math.abs(right - left) &gt; <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加上本身的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>222.完全二叉树的节点个数</title>
      <link href="/2023/06/16/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/"/>
      <url>/2023/06/16/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin" title="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p><span id="more"></span><h1 id="层序"><a href="#层序" class="headerlink" title="层序"></a>层序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//层序</span></span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        deque.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                deque.offer(node.left);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                deque.offer(node.right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//叶子节点个数加1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            left = countNodes(root.left);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右递归</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            right = countNodes(root.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>111.二叉树的最小深度</title>
      <link href="/2023/06/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
      <url>/2023/06/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>&amp;&amp;root.right == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+minDepth(root.left);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span>&amp;&amp;root.right != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+minDepth(root.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//层序遍历</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        deque.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当队列不为空时</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> deque.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//深度加1</span></span><br><span class="line"></span><br><span class="line">            depth++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将该层节点的子节点都入队</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//若该层某个节点没有子节点，即叶子节点，说明该层是最小深度</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//直接返回深度即可</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    deque.offer(node.left);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    deque.offer(node.right);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>104.二叉树的最大深度</title>
      <link href="/2023/06/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/2023/06/16/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//层序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        deque.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当队列不为空时</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;          </span><br><span class="line"></span><br><span class="line">            <span class="comment">//将该层的子节点全部加入队列中</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果没有子节点队列将为空，说明没有下一层</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> deque.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.poll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;                  </span><br><span class="line"></span><br><span class="line">                    deque.offer(node.left);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    deque.offer(node.right);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//层数加1</span></span><br><span class="line"></span><br><span class="line">            depth++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>101.对称二叉树</title>
      <link href="/2023/06/15/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/06/15/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> compare(left.right, right.left) &amp;&amp; compare(left.left, right.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">null</span> || (root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用队列保存节点</span></span><br><span class="line">LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line"><span class="comment">//将根节点的左右孩子放到队列中</span></span><br><span class="line">queue.add(root.left);</span><br><span class="line">queue.add(root.right);</span><br><span class="line"><span class="keyword">while</span>(queue.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//从队列中取出两个节点，再比较这两个节点</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line"><span class="comment">//如果两个节点都为空就继续循环，两者有一个为空就返回false</span></span><br><span class="line"><span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left==<span class="literal">null</span> || right==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left.val!=right.val) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将左节点的左孩子， 右节点的右孩子放入队列</span></span><br><span class="line">queue.add(left.left);</span><br><span class="line">queue.add(right.right);</span><br><span class="line"><span class="comment">//将左节点的右孩子，右节点的左孩子放入队列</span></span><br><span class="line">queue.add(left.right);</span><br><span class="line">queue.add(right.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>226.翻转二叉树</title>
      <link href="/2023/06/15/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/06/15/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将左右子树互换</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line"></span><br><span class="line">        root.left = root.right;</span><br><span class="line"></span><br><span class="line">        root.right = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归左子树</span></span><br><span class="line"></span><br><span class="line">        invertTree(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归右子树</span></span><br><span class="line"></span><br><span class="line">        invertTree(root.right);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当栈不为空时</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line">            swap(node);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                stack.push(node.left);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                stack.push(node.right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将左右子树互换</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line"></span><br><span class="line">        root.left = root.right;</span><br><span class="line"></span><br><span class="line">        root.right = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="层序"><a href="#层序" class="headerlink" title="层序"></a>层序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">            swap(node);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                queue.offer(node.left);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                queue.offer(node.right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将左右子树互换</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line"></span><br><span class="line">        root.left = root.right;</span><br><span class="line"></span><br><span class="line">        root.right = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>347.前K个高频元素</title>
      <link href="/2023/06/15/%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
      <url>/2023/06/15/%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><span id="more"></span><h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//优先队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//使用map来统计频率</span></span><br><span class="line"></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line"></span><br><span class="line">                map.put(nums[i], map.get(nums[i])+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                map.put(nums[i], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用优先队列来获取前k个元素</span></span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2)-&gt;pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line"></span><br><span class="line">            priorityQueue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结果数组</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"></span><br><span class="line">            result[index++] = priorityQueue.poll()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快排-官方题解"><a href="#快排-官方题解" class="headerlink" title="快排(官方题解)"></a>快排(官方题解)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; occurrences = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            occurrences.put(num, occurrences.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> entry.getKey(), count = entry.getValue();</span><br><span class="line">            values.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;num, count&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        qsort(values, <span class="number">0</span>, values.size() - <span class="number">1</span>, ret, <span class="number">0</span>, k);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">qsort</span><span class="params">(List&lt;<span class="type">int</span>[]&gt; values, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] ret, <span class="type">int</span> retIndex, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">picked</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * (end - start + <span class="number">1</span>)) + start;</span><br><span class="line">        Collections.swap(values, picked, start);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> values.get(start)[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (values.get(i)[<span class="number">1</span>] &gt;= pivot) &#123;</span><br><span class="line">                Collections.swap(values, index + <span class="number">1</span>, i);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.swap(values, start, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &lt;= index - start) &#123;</span><br><span class="line">            qsort(values, start, index - <span class="number">1</span>, ret, retIndex, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= index; i++) &#123;</span><br><span class="line">                ret[retIndex++] = values.get(i)[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; index - start + <span class="number">1</span>) &#123;</span><br><span class="line">                qsort(values, index + <span class="number">1</span>, end, ret, retIndex, k - (index - start + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>239.滑动窗口最大值</title>
      <link href="/2023/06/13/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2023/06/13/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><span id="more"></span><h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 优先队列存放的是二元组(num,index) : 大顶堆（元素大小不同按元素大小排列，元素大小相同按下标进行排列）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// num :   是为了比较元素大小</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// index : 是为了判断窗口的大小是否超出范围</span></span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] pair1,<span class="type">int</span>[] pair2)</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> pair1[<span class="number">0</span>] != pair2[<span class="number">0</span>] ? pair2[<span class="number">0</span>] - pair1[<span class="number">0</span>]:pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 优选队列初始化 : k个元素的堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line"></span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[i],i&#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 处理堆逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];         <span class="comment">// 初始化结果数组长度 ：一共有 n - k + 1个窗口</span></span><br><span class="line"></span><br><span class="line">        res[<span class="number">0</span>] = pq.peek()[<span class="number">0</span>];                  <span class="comment">// 初始化res[0] ： 拿出目前堆顶的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k;i &lt; n;i++)&#123;               <span class="comment">// 向右移动滑动窗口</span></span><br><span class="line"></span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[i],i&#125;);     <span class="comment">// 加入大顶堆中</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(pq.peek()[<span class="number">1</span>] &lt;= i - k)&#123;       <span class="comment">// 将下标不在滑动窗口中的元素都干掉</span></span><br><span class="line"></span><br><span class="line">                pq.poll();                      <span class="comment">// 维护：堆的大小就是滑动窗口的大小</span></span><br><span class="line"></span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            res[i - k + <span class="number">1</span>] = pq.peek()[<span class="number">0</span>];      <span class="comment">// 此时堆顶元素就是滑动窗口的最大值</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyQueue</span> <span class="variable">myQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先将前k个值入队</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"></span><br><span class="line">            myQueue.push(nums[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n-k+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        res[index++] = myQueue.front();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            myQueue.pop(nums[i-k]);</span><br><span class="line"></span><br><span class="line">            myQueue.push(nums[i]);</span><br><span class="line"></span><br><span class="line">            res[index++] = myQueue.front();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单调队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>&#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    MyQueue()&#123;</span><br><span class="line"></span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 当push得值与队首的值比较，大于时将其弹出，知道没有比其更大的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 小于时直接push  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 加入队列得值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; x &gt; deque.getLast())&#123;</span><br><span class="line"></span><br><span class="line">            deque.removeLast();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deque.add(x);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 当弹出的值等于队首的值时进行弹出，否则不进行操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 因为我们维护的是最大值，如果弹出的值不是当前队列的最大值，说明队列的最大值在</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 后面，不需要进行弹出，因为我们并没对现在这个值进行维护</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 弹出的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!deque.isEmpty() &amp;&amp; value == deque.peek())&#123;</span><br><span class="line"></span><br><span class="line">            deque.poll();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 获取队首值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">front</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deque.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>150.逆波兰表达式求值</title>
      <link href="/2023/06/13/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
      <url>/2023/06/13/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" title="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a>，求表达式的值。</p><p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>注意</strong> 两个整数之间的除法只保留整数部分。</p><p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><span id="more"></span><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String string : tokens) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> string.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(string.charAt(string.length()-<span class="number">1</span>) &gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; string.charAt(string.length()-<span class="number">1</span>) &lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">                stack.push(Integer.parseInt(string));</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> temp ;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> :  temp = x - y ; stack.push(temp);<span class="keyword">break</span>;              </span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :  temp = x + y ; stack.push(temp);<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span> :  temp = x * y ; stack.push(temp);<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span> :  temp = x / y ; stack.push(temp);<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1047.删除字符串中的所有相邻重复项</title>
      <link href="/2023/06/11/%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2023/06/11/%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><span id="more"></span><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当栈不为空时进行比较与弹栈操作</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(top &gt;= <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当字符与栈顶的字符相同时弹栈</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ch == stack.charAt(top))&#123;</span><br><span class="line"></span><br><span class="line">                    stack.deleteCharAt(top);</span><br><span class="line"></span><br><span class="line">                    top--;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                    stack.append(ch);</span><br><span class="line"></span><br><span class="line">                    top++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                stack.append(ch);</span><br><span class="line"></span><br><span class="line">                top++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.toString();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &lt; s.length()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接用fast指针覆盖slow指针的值</span></span><br><span class="line"></span><br><span class="line">            ch[slow] = ch[fast];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遇到前后相同值，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slow &gt; <span class="number">0</span> &amp;&amp; ch[slow] == ch[slow - <span class="number">1</span>]) &#123;</span><br><span class="line"></span><br><span class="line">                slow--;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                slow++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fast++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch, <span class="number">0</span>, slow);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20.有效的括号</title>
      <link href="/2023/06/11/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>/2023/06/11/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><span id="more"></span><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当括号是左半边的时候将其存入栈中</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;[&#x27;</span> || ch == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">                stack.push(ch);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//是右边的时候判断时候与栈顶相匹配</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果这时队列为空也返回false</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//匹配则弹栈 最终如果栈为空则是有效括号</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(isMatch(stack.peek(), ch))&#123;</span><br><span class="line"></span><br><span class="line">                    stack.pop();</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 判断两个括号是否匹配</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span> s1,<span class="type">char</span> s2)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s1 == <span class="string">&#x27;(&#x27;</span> &amp;&amp; s2 == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s1 == <span class="string">&#x27;[&#x27;</span> &amp;&amp; s2 == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s1 == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s2 == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>225.用队列实现栈</title>
      <link href="/2023/06/11/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>/2023/06/11/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><span id="more"></span><h1 id="一个队列"><a href="#一个队列" class="headerlink" title="一个队列"></a>一个队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">        deque.add(x);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            deque.add(deque.poll());</span><br><span class="line"></span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deque.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>  deque.peekLast();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>232.用栈实现队列</title>
      <link href="/2023/06/10/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2023/06/10/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p><p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><span id="more"></span><h1 id="双栈"><a href="#双栈" class="headerlink" title="双栈"></a>双栈</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stackIn,stackOut;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">        stackIn.push(x);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stackOut.empty())&#123;</span><br><span class="line"></span><br><span class="line">            inOut();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stackOut.empty())&#123;</span><br><span class="line"></span><br><span class="line">            inOut();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stackIn.empty() &amp;&amp; stackOut.empty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOut</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stackIn.empty())&#123;</span><br><span class="line"></span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>495.重复的子字符串</title>
      <link href="/2023/06/10/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/06/10/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p><span id="more"></span><h1 id="我の愚蠢的解法"><a href="#我の愚蠢的解法" class="headerlink" title="我の愚蠢的解法"></a>我の愚蠢的解法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逐渐增长子字符串的长度，然后往后匹配</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//i 为长度 sub为子字符串</span></span><br><span class="line"></span><br><span class="line">            sub = s.substring(<span class="number">0</span>,<span class="number">0</span>+i);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(match(sub, start, s))&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(String sub,<span class="type">int</span> start,String s)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> sub.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(start &lt; s.length())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//进行匹配判断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(start+i &gt;= s.length())&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(sub.charAt(i) != s.charAt(start+i))&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            start+=length;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举   如果重复，则前面第i个字符往后都会与之对应</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//长度超过一半则不可能重复</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i*<span class="number">2</span> &lt;= length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//只有整除才可能重复</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(length % i == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; length; j++) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(j) != s.charAt(j-i))&#123;</span><br><span class="line"></span><br><span class="line">                        match = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(match)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">        s = <span class="string">&quot; &quot;</span>+s;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(chars[i] == chars[j+<span class="number">1</span>]) j++;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">            next[i] = j;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>28.实现strStr</title>
      <link href="/2023/06/07/%E5%AE%9E%E7%8E%B0strStr/"/>
      <url>/2023/06/07/%E5%AE%9E%E7%8E%B0strStr/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p><span id="more"></span><h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + m &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (haystack.charAt(i + j) != needle.charAt(j)) &#123;</span><br><span class="line"></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//KMP算法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> needle.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//原串和匹配串前面都加空格，使其下标从1开始</span></span><br><span class="line"></span><br><span class="line">        haystack = <span class="string">&quot; &quot;</span> + haystack;</span><br><span class="line"></span><br><span class="line">        needle = <span class="string">&quot; &quot;</span> + needle;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] s = haystack.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] p = needle.toCharArray();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建next数组  数组长度为匹配串的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造过程 i = 2,j = 0开始，i小于等于匹配串长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>,j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//匹配不成功 j = next[j]</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//匹配成功  先让j++</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新next[i],结束本次循环 i++</span></span><br><span class="line"></span><br><span class="line">            next[i] = j;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配过程 i = 1，j = 0开始，i 小于等于原串长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>,j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//匹配不成功</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//匹配成功 j++</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>])j++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//整一段匹配成功  直接返回下标</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j == m) <span class="keyword">return</span> i - m;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>151.颠倒字符串中得单词</title>
      <link href="/2023/06/06/%E9%A2%A0%E5%80%92%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%BE%97%E5%8D%95%E8%AF%8D/"/>
      <url>/2023/06/06/%E9%A2%A0%E5%80%92%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%BE%97%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p>**注意：输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><span id="more"></span><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从后往前确定单词，然后依次加入字符串中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s.length() == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(r &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> r;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到第一个单词的尾部</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(end &gt; <span class="number">0</span> &amp;&amp; s.charAt(end) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">                end--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(end == <span class="number">0</span> &amp;&amp; s.charAt(end) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到第一个单词的头部</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> end;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(start &gt;= <span class="number">0</span> &amp;&amp; s.charAt(start) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">                start--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            temp += s.substring(start+<span class="number">1</span>, end+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            temp += <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">            r = start;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp.substring(<span class="number">0</span>, temp.length()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>大佬の优雅写法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s; <span class="comment">// 特殊情况转为统一处理</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> n - <span class="number">1</span>, right = n; left &gt;= <span class="number">0</span>;</span><br><span class="line">     left--) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;   <span class="comment">// 遇到空格，说明获得一个完整单词</span></span><br><span class="line">            <span class="keyword">if</span> (left + <span class="number">1</span> &lt; right) &#123;    <span class="comment">// 防止连续空格的情况</span></span><br><span class="line">                ans.append(s, left + <span class="number">1</span>, right);</span><br><span class="line">                ans.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            right = left; <span class="comment">// 让right紧跟left，避免连续多个空格被甩开，导致添加单词时候里面有多余空格</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.substring(<span class="number">0</span>, ans.length() - <span class="number">1</span>);  <span class="comment">//结尾处理一下多余空格</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;String&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">word</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="keyword">if</span> ((word.length() != <span class="number">0</span>) &amp;&amp; (c == <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 将单词 push 到队列的头部</span></span><br><span class="line">                d.offerFirst(word.toString());</span><br><span class="line">                word.setLength(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                word.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        d.offerFirst(word.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot; &quot;</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>541.反转字符串II</title>
      <link href="/2023/06/06/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II/"/>
      <url>/2023/06/06/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><span id="more"></span><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i+=<span class="number">2</span>*k) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//结尾位置要么是最末尾，要么是k个字符</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(ch.length-<span class="number">1</span>, start+k-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            reverseString(ch, start,end);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s,<span class="type">int</span> start,<span class="type">int</span> end)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> start;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line"></span><br><span class="line">            swap(l, r, s);</span><br><span class="line"></span><br><span class="line">            l++;</span><br><span class="line"></span><br><span class="line">            r--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">char</span>[] s)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[l];</span><br><span class="line"></span><br><span class="line">        s[l] = s[r];</span><br><span class="line"></span><br><span class="line">        s[r] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>344.反转字符串</title>
      <link href="/2023/06/06/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/06/06/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p><span id="more"></span><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line"></span><br><span class="line">            swap(l, r, s);</span><br><span class="line"></span><br><span class="line">            l++;</span><br><span class="line"></span><br><span class="line">            r--;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">char</span>[] s)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[l];</span><br><span class="line"></span><br><span class="line">        s[l] = s[r];</span><br><span class="line"></span><br><span class="line">        s[r] = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基本知识</title>
      <link href="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><span id="more"></span><h2 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h2><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="常见的计算机网络体系结构"><br>原理体系结构与其协议<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%8E%9F%E7%90%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="原理体系结构"></p><h2 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h2><blockquote><p>对五层体系架构进行分析</p></blockquote><p><strong>应用层</strong> ： 解决通过应用进程的交互来实现特定网络应用的问题  创建一个HTTP网络报文然后传给运输层<br><strong>运输层</strong> ： 解决进程之间基于网络的通信问题    将报文首部添加一个TCP首部使其成为TCP报文段然后传给网络层<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E6%A0%BC%E5%BC%8F.png" alt="TCP报文段格式"><br><strong>网络层</strong> ： 解决分组在多个网络 上传输(路由)的问题  网络层给TCP报文段添加一个IP头部使其成为IP数据报  该首部的作用是使其可以在互联网上传输<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IP数据报格式"><br><strong>数据链路层</strong> ： 解决分组在一个网络(或一段链路)上传输的问题  数据链路层给IP数据报添加一个首部和一个尾部使其成为帧  作用是使其能在一段网络或链路上传输，能被对应的目的主机给接收<br><strong>物理层</strong> ： 解决使用何种信号来传输比特的问题 物理层将其看成比特流并在其前面加上一个前导码，作用是让目的主机做好接收帧的准备</p><h2 id="计算机网络体系结构中的专业术语"><a href="#计算机网络体系结构中的专业术语" class="headerlink" title="计算机网络体系结构中的专业术语"></a>计算机网络体系结构中的专业术语</h2><ul><li><strong>实体</strong>：任何课发送或接收信息的硬件或软件进程</li><li><strong>对等实体</strong>： 手法双方相同层次中的实体</li><li><strong>协议</strong>：控制两个对等实体进行逻辑通信的规则的集合</li><li><strong>协议的三要素</strong>：<ul><li><strong>语法</strong>：定义所交换信息的格式</li><li><strong>语义</strong>：定义收发双方所要完成的操作</li><li><strong>同步</strong>：定义收发双方的时序关系</li></ul></li><li><strong>服务</strong>：在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务<ul><li>要实现本层协议，还需要使用下面一层所提供的服务</li><li>协议是“水平的”，服务是“垂直的”</li><li>实体看得见相邻下层所提供得服务，但并不知道实现该服务得具体协议。也就是说，下面得协议对上面得实体是透明的</li></ul></li><li><strong>服务访问点</strong>：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型</li><li><strong>服务原语</strong>：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令成为服务原语</li><li><strong>协议数据单元PDU</strong>：对等层次之间传送的数据包称为该层的协议数据单元</li><li><strong>服务数据单元SDU</strong>：同一系统内，层与层之间交换的数据包我们称之为服务数据单元</li></ul><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流</li><li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么</li><li><strong>主要任务</strong>：<ul><li><strong>机械特性</strong>：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置</li><li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压的范围</li><li><strong>功能特性</strong>：指明某条线上出现的某一电平的电压表示何种意义</li><li><strong>过程特性</strong>：指明对于不同功能的各种可能时间的出现顺序</li></ul></li></ul><h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><ul><li>同轴电缆</li><li>双绞线</li><li>光纤</li><li>电力线</li></ul><h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><ul><li>无线电波</li><li>微波</li><li>红外线</li><li>可见光</li></ul><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><ul><li>不归零编码：存在同步问题</li><li>归零编码：自同步，编码效率低</li><li>曼彻斯特编码：码元之间的跳变即表示时钟，又表示数据</li><li>差分曼彻斯特编码：比曼彻斯特编码变化少，更适合较高的传输速率<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81.png" alt="常用编码"></li></ul><h3 id="基本调制方法"><a href="#基本调制方法" class="headerlink" title="基本调制方法"></a>基本调制方法</h3><ul><li>数字基带信号</li><li>调幅（AM）</li><li>调频（FM）</li><li>调相（PM）<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%9F%BA%E6%9C%AC%E8%B0%83%E5%88%B6%E6%96%B9%E6%B3%95.png" alt="基本调制方法"></li></ul><h3 id="混合调制"><a href="#混合调制" class="headerlink" title="混合调制"></a>混合调制</h3><ul><li>QAM-16<ul><li>12种相位</li><li>每种相位有1或2种振幅可选</li><li>可以调制出16种码元(波形)，每种码元可以对应表示4个比特</li><li>码元与4个比特的对应关系采用格雷码（任意两个相邻码元之间只有1个比特不同）<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E6%B7%B7%E5%90%88%E8%B0%83%E5%88%B6.png" alt="混合调制"></li></ul></li></ul><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><h3 id="奈式准则"><a href="#奈式准则" class="headerlink" title="奈式准则"></a>奈式准则</h3><blockquote><p>在假定的理想条件下，为了避免码间串扰，码元的传输速率是有上限的</p></blockquote><p>理想低通信道的最高码元传输速率 &#x3D; 2W Baud &#x3D; 2W 码元&#x2F;秒<br>理想带通信道的最高码元传输速率 &#x3D; W Baud &#x3D; W 码元&#x2F;秒<br>    - W：信道带宽   Hz<br>    - Baud 波特，即码元&#x2F;秒</p><ul><li>码元传输速率又称为波特率、调制速度、或符号速率。它与比特率有一定关系：<ul><li>当一个码元只携带1比特的信息量时，则波特率与比特率在数值上是相等的</li><li>当一个码元携带n比特的信息量时，则波特率转换成比特率时，数值要乘以n</li></ul></li><li>要提高信息传输速率，就必须设法使每一个码元能携带更多个比特的信息量，这需要采用多元制</li><li>实际的信道所能传输的最高码元速率，要明显低于奈式准则给出的这个上限数值</li></ul><h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><blockquote><p>带宽受限且有高斯白噪声高人的信道的极限信息传输速率</p></blockquote><p>c &#x3D; W * log2(1 + S&#x2F;N) </p><ul><li>c：信道的极限信息传输速率</li><li>W：信道带宽</li><li>S：信道内所传信号的平均功率</li><li>S&#x2F;N：信噪比 使用分贝作为度量单位<br>信道带宽或信道中信噪比越大，信息的极限传输速率越高<br>在实际信道上能够达到的信息传输速率要比该公式的极限传输速率低不少，这是因为在实际信道中，信号还要受到其他一些损伤，如各种脉冲、信号在传输中的衰减和失真等</li></ul><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li>复用(Multiplexing)就是在一条传输媒体上同时传输多路用户的信号</li><li>当一条传输媒体的传输容量大于多条信道传输的总容量时，就可以通过复用技术，在这条传输媒体上建立多条通信信道，以便充分利用传输媒体的带宽<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="信道复用技术的基本原理"></li></ul><h3 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h3><blockquote><p>频分复用的所有用户同时占用不同的频带资源并行通信</p></blockquote><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="频分复用"></p><h3 id="时分复用TDM"><a href="#时分复用TDM" class="headerlink" title="时分复用TDM"></a>时分复用TDM</h3><blockquote><p>时分复用的所有用户在不同的事件占用同样的频带</p></blockquote><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="时分复用"></p><h3 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h3><ul><li>根据频分复用的设计思想，可在一根光纤上同时传输多个频率相近的光载波信号，实现基于光纤的频分复用技术</li><li>目前可以在一根管线上复用80路或更多路的光载波信号。因此，这种复用技术也称为密集波分复用DWDM<h3 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h3></li><li>如果有两个或多个站同时发送数据，则信道中的信号就是这些站各自所发送一系列码片序列或码片序列反码的叠加。为了从信道中分离出每个站的信号，给每个站指派码片序列时，必须遵循以下规则：<ul><li>分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列</li><li>分配给每个站的码片序列必须相互正交，即各码片序列相应的码片向量之间的规格化内积为0</li></ul></li></ul><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="数据传输流程"><a href="#数据传输流程" class="headerlink" title="数据传输流程"></a>数据传输流程</h2><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B.png" alt="数据传输流程"></p><h2 id="链路、数据链路和帧"><a href="#链路、数据链路和帧" class="headerlink" title="链路、数据链路和帧"></a>链路、数据链路和帧</h2><ul><li>链路(Link) 是指从一个节点到相邻节点的一段物理线路（有线或无线），而中间没有任何其他的交换节点。</li><li>数据链路（Data Link）是基于链路的。当一条链路上传输数据时，除需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路</li><li>计算机中的网络适配器（俗称网卡）和其相应的软件驱动程序就实现了这些协议。一般的网络适配器都包含了物理层和数据链路层这两层的功能</li><li>帧（Frame）是数据链路层对等实体之间在水平方向进行逻辑通信的协议数据单元PDU。</li></ul><h2 id="封装成帧和透明传输"><a href="#封装成帧和透明传输" class="headerlink" title="封装成帧和透明传输"></a>封装成帧和透明传输</h2><ul><li>数据链路层给上层交付下来的协议数据单元PDU添加帧首部和帧尾部，这称为封装成帧<ul><li>帧头和帧尾中包含有重要的控制信息</li><li>帧头和帧尾的作用之一就是帧定界</li></ul></li><li>如果能够采取措施，使得数据链路层对上层交付的PDU的内容没有任何限制，就好像数据链路层不存在一样，就称其为透明传输。（在不做任何操作的情况下，如果PDU的内容出现与帧首部的内容一样，就会出现帧误判）<ul><li>面向字节的物理链路使用字节填充（字符填充）的方式实现透明传输（在具有特殊意义的字符前添加转义字符）</li><li>面向比特的物理链路使用比特填充的方式实现透明传输（例如：五个1后插入一个0）</li></ul></li><li>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些</li><li>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传输单元MTU（Maximum Transfer Unit）。</li></ul><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><ul><li>帧在传输的过程中可能出现误码（比特在传输的过程中1可能变为0，反之也是）</li><li>在一段事件内，传输错误的比特站所传输比特总数的比率称为<strong>误码率BER</strong>（Bit Error Rate）</li><li>接收方根据发送方添加在帧尾部中的检错码，可以检测出帧是否出现了误码 但无法纠正错误</li><li>要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。</li><li>循环冗余效验CRC有很好的检错能力(漏检率非常低)，虽然计算比较复杂，但非常易于用硬件实现，因此被广泛应用于数据链路层<h3 id="奇偶检验"><a href="#奇偶检验" class="headerlink" title="奇偶检验"></a>奇偶检验</h3></li><li>在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中 ‘1’ 的个数为奇数（奇校验）或偶数（偶校验）</li><li>如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码</li><li>如果有偶数个位发生误码，则奇偶性不发生变化，不可以检查出误码</li></ul><h3 id="循环冗余效验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余效验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余效验CRC(Cyclic Redundancy Check)"></a>循环冗余效验CRC(Cyclic Redundancy Check)</h3><ul><li>收发双方约定好一个生成多项式G(x)</li><li>发送方基于待发送的数据和生成多项式计算出差错检测码(冗余码)，将其添加到待传输数据的后面一起传输</li><li>接收方通过生成多项式来计算收到的数据是否产生了误码<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%95%88%E9%AA%8CCRC%E6%B5%81%E7%A8%8B.png" alt="循环冗余效验流程"></li></ul><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><ul><li>不可靠传输服务：收到有误码的帧，直接丢弃，其他什么也不做，未收到发送方发送的帧，也不进行任何处理</li><li>可靠传输服务：实现发送方发送什么，接收方最终都能够正确收到。</li><li>一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理</li><li>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务</li><li>比特差错只是传输差错中的一种，还包括分组丢失、分组失序以及分组重复</li><li>可靠传输服务并不仅局限于数据链路层，其他层均可选择实现可靠传输</li></ul><h3 id="停止-等待协议SW"><a href="#停止-等待协议SW" class="headerlink" title="停止-等待协议SW"></a>停止-等待协议SW</h3><ul><li>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组</li><li>为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号，由于停止等待协议的停等协议特性，只需要1个比特编号就够了，即1和0</li><li>为了使发送方能够判断所收到的ACK分组是否是重复的，需要给ACK分组编号，所用比特数量与分组编号所用比特数量一样。数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号</li><li>超时计时器设置的重传事件应仔细选择，一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”<ul><li>在数据链路层点对点的往返时间比较确定，重传时间比较好设定</li><li>然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易</li></ul></li><li>当往返时延RTT远大于数据帧发送时延Td时，信道利用率非常低<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png" alt="停止-等待协议"></li></ul><h3 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h3><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种ARQ协议</li><li>在协议的工作过程中发送窗口和接受窗口不断向前滑动，因此这类协议又称为滑动窗口协议</li><li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li></ul><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><ul><li>发送串口尺寸W<code>T</code>的取值范围是1~2<sup>n</sup>-1 其中n是构成分组序号的比特数量<ul><li>W &gt; 2<sup>n</sup> -1 时无法分辨新旧数据分组</li></ul></li><li>发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送除去</li><li>发送方只有收到对已发送数据分组的确认时，发送窗口才能向前相应滑动</li><li>发送方收到多个重复确认时，可在重传计时器超时之前尽早开始重传，由具体实现决定</li><li>发送方发送窗口内某个已发送的数据分组产生超时重发时，其后续在发送窗口内且已发送的数据分组也必须全部重传，这就是回退N帧协议名称的由来</li></ul><h4 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h4><ul><li>接收方的接收窗口大小W<code>R</code> 的取值范围时W<code>R</code> &#x3D; 1  因此接收方只能按序接收数据分组</li><li>接收方只接受序号落在接收窗口内且无误码的数据分组，并且将接收窗口向前滑动一个位置，与此同时给发送方发回相应的确认分组，为了减少开销，接收方不一定没收到一个按序到达且无误码的数据分组就给发送方发回一个确认分组<ul><li>而是可以在连续接收到好几个按序到达且无误码的数据分组后，才针对最后一个数据分组发送确认分组，称为累积确认</li><li>或者可以在自己由数据分组要发送时才对之前按序接收且无误码的数据分组进行捎带确认</li></ul></li><li>接收方收到未按序到达的数据分组，除丢弃外，还要对最近按序接收的数据分组进行确认</li></ul><h3 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h3><h4 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h4><ul><li>窗口尺寸W<code>T</code> 的取值范围 1  &lt; W<code>T</code> &lt;&#x3D; 2<sup>n-1</sup> 其中n时构成分组序号的比特数量<ul><li>大于范围则接收方无法分辨新旧数据分组</li></ul></li><li>发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送除去</li><li>发送方只有按序接收到对已发送数据分组的确认时，发送窗口才能向前相应滑动；若收到未按序到达的确认分组时，对其进行记录，以防止其相应数据分组的超时重发，但发送窗口不能向前滑动</li></ul><h4 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h4><ul><li>接收窗口尺寸W<code>R</code> 的取值范围是1&lt; W<code>R</code> &lt; W<code>T</code><ul><li>大于则无意义</li></ul></li><li>接收方可接收未按序到达但没有误码并且序号落在接收窗口内的数据分组；<ul><li>为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的数据分组进行逐一确认</li></ul></li><li>接收方只有再按序接收数据分组后，接收窗口才能相应滑动</li></ul><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><ul><li>PPP协议为再点对点链路传输各种协议数据报提供了一个标准方法，主要由一下三部分构成<ul><li>对各种协议数据报的封装方法（封装成帧）</li><li>链路控制协议LCP                用于建立、配置以及测试数据链路的连接</li><li>一套网络控制协议NCPs      其中的每一个协议支持不同的网络层协议<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/PPP%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F.png" alt="PPP协议格式"></li></ul></li><li>PPP帧的透明传输<ul><li>面向字节的异步链路使用字节填充法（插入转义字符）</li><li>面向比特的同步链路使用比特填充法（零比特填充）</li></ul></li><li>PPP 协议的工作状态<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81.png" alt="PPP协议的工作状态"></li></ul><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><blockquote><p>以太网(<strong>Ethernet</strong>) 以曾经被假想的电磁波传播介质—-以太(Ether) 来命名<br>最初采用无源电缆（不包含电源线）作为共享总线来传输帧，属于基带总线局域网</p></blockquote><h3 id="网络适配器"><a href="#网络适配器" class="headerlink" title="网络适配器"></a>网络适配器</h3><ul><li>要将计算机连接到以太网，需要使用相应的网络适配器(Adapter)，简称 “网卡”</li><li>再计算机内部，网卡与CPU之间的通信，一般使通过加u三级主板上的I&#x2F;O总线以并行传输方式进行</li><li>网卡与外部以太网(局域网)之间的通信，一般是通过传输媒体（同轴电缆、双绞线电缆、光纤）以串行方式进行的</li><li>网卡除要实现物理层和数据链路层功能，其另外一个重要功能就是要进行并行传输和串行传输的转换。由于网络的传输速率和计算机内部总线上的传输速率并不相同，因此再网卡的核心芯片中都回包含用于缓存数据的存储器</li><li>再确保网卡硬件正确的情况下，为了使网卡正常工作，还必须要在计算机的操作系统中为网卡安装相应的设备驱动程序。驱动程序负责驱动网卡发送和接收帧</li></ul><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><ul><li>MAC地址一般被固化再网卡的电可擦可编程只读存储器EEPROM中，因此MAC地址也被称为硬件地址</li><li>MAC有时也被称为物理地址</li><li>一般情况下，普通用户计算机中往往包含两块网卡<ul><li>一块是用于接入有线局域网的以太网卡</li><li>另一块是用于接入无线局域网的Wi-Fi网卡</li></ul></li><li>每块网卡都有一个全球唯一的MAC地址</li><li>交换机和路由器往往具有更多的网络接口，所以回有用更多的MAC地址</li></ul><p><strong>MAC地址是对网络上个接口的唯一标识，而不是对网络上各设备的唯一标识</strong><br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/MAC%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F.png" alt="MAC地址格式"></p><ul><li>b0 &#x3D; 1 多播地址</li><li>b0 &#x3D; 0 单播地址</li><li>b1 &#x3D; 1 本地管理</li><li>b1 &#x3D; 0 全球管理<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/MAC%E5%B9%BF%E6%92%AD%E6%96%B9%E5%BC%8F.png" alt="MAC广播方式"></li></ul><h3 id="CSMA-x2F-CD协议的基本原理"><a href="#CSMA-x2F-CD协议的基本原理" class="headerlink" title="CSMA&#x2F;CD协议的基本原理"></a>CSMA&#x2F;CD协议的基本原理</h3><ul><li><p>共享总线以太网具有天然的广播特性，即使总线上某个站点给另一个站点发送单播帧，表示帧的信号也会沿着总线传播到总线上的其他各站点</p></li><li><p>当某个站点再总线上发送帧时，总线资源回被该站点独占。此时，如果总线上的其他站点也要在总线上发送帧，就会发生信号碰撞</p></li><li><p>为了解决各站点争用总线的问题，共享总线以太网使用了一种专用协议CSMA&#x2F;CD，它是<strong>载波监听多址接入&#x2F;碰撞检测(Carrier Sense Multiple Access Collision Detection)</strong><br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/CSMA-CD%E5%8D%8F%E8%AE%AE.png" alt="CSMA-CD协议"></p></li><li><p>载波监听检测到总线空闲，但总线不一定空闲</p></li><li><p>使用CSMA&#x2F;CD协议的共享总线以太网上的各站点，只是尽量避免碰撞并在出现碰撞时做出退避后重发的处理，但不能完全避免碰撞</p></li><li><p>在使用CSMA&#x2F;CD协议时，由于正在发送帧的站点必须 “边发送帧边检测碰撞”，因此站点不可能同时进行发送和接收，也就是不可能进行全双工通信，而只能进行半双工通信(双向交替通信)</p></li></ul><h3 id="使用集线器的共享以太网"><a href="#使用集线器的共享以太网" class="headerlink" title="使用集线器的共享以太网"></a>使用集线器的共享以太网</h3><ul><li>在使用细同轴电缆的共享总线以太网之后，以太网发展出来了一种使用大规模集成电路来替代总线、并且可靠性非常高的设备，叫做集线器(Hub)</li><li>站点连接到集线器的传输媒体也转而使用更便宜、更灵活的双绞线电缆</li><li>集线器的一些主要特点<ul><li>使用集线器的以太网虽然物理拓扑是星型的，但在逻辑上仍然是一个总线网。总线上的各站点共享总线资源，使用的还是CSMA&#x2F;CD协议</li><li>集线器只工作在物理层，他的每个接口仅简单的转发比特，并不进行碰撞检测。碰撞检测的任务由各站点的网卡负责</li><li>集线器一般都由少量的容错能力和网络管理功能。例如，若网络中某个站点的网卡出现了故障而不停的发送帧，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，以使整个以太网能正常工作</li></ul></li></ul><h3 id="在物理层拓展以太网"><a href="#在物理层拓展以太网" class="headerlink" title="在物理层拓展以太网"></a>在物理层拓展以太网</h3><ul><li>共享总线以太网中两战点之间的距离不能太远，否则他们之间所传输的信号就会衰减到使CSMA&#x2F;CD协议无法正常工作</li><li>在早期广泛使用粗同轴电缆或细同轴电缆共享总线以太网时，为了提高网络的地理覆盖范围，常使用的是工作在物理层的转发器</li><li>在10BASE-T星型以太网中，可使用光纤和与一对光纤调制解调器来拓展站点与集线器之间的距离<ul><li>这种拓展方法比较简单，所需付出的代价是：为站点和集线器各增加一个用于电信号和光信号转换的光纤调制解调器，以及他们之间的一对通信光纤</li></ul></li><li>信号在光纤中的衰减和失真很小，因此使用这种方法可以很简单的将站点与集线器之间的距离拓展到1000m以上</li></ul><h3 id="在数据链路层拓展以太网"><a href="#在数据链路层拓展以太网" class="headerlink" title="在数据链路层拓展以太网"></a>在数据链路层拓展以太网</h3><h4 id="使用网桥在数据链路层拓展以太网"><a href="#使用网桥在数据链路层拓展以太网" class="headerlink" title="使用网桥在数据链路层拓展以太网"></a>使用网桥在数据链路层拓展以太网</h4><ul><li>网桥(bridge) 工作在数据链路层（包含其下的物理层），因此网桥具备属于数据链路层范畴的相关能力<ul><li>网桥可以识别帧的结构</li><li>网桥可以根据首部中的目的MAC地址和网桥自身的帧转发表来转发或丢弃所收到的帧。<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E7%BD%91%E6%A1%A5%E6%8B%93%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91.png" alt="网桥拓展以太网"></li></ul></li></ul><h4 id="透明网桥的自学习和转发帧的流程"><a href="#透明网桥的自学习和转发帧的流程" class="headerlink" title="透明网桥的自学习和转发帧的流程"></a>透明网桥的自学习和转发帧的流程</h4><ul><li>透明网桥通过自学习算法建立转发表<ul><li>网桥收到帧后进行登记，登记的内容为帧的源MAC地址和进入网桥的接口号</li><li>网桥根据帧的目的MAC地址和网桥的转发表对帧进行转发，包含以下三种情况<ul><li><strong>明确转发</strong>：网桥知道应当从哪个接口转发帧</li><li><strong>盲目转发</strong>：网桥不知道应当从哪个接口转发帧，只能将其通过除进入网桥的接口外的其他所有接口转发</li><li><strong>丢弃</strong>：网桥知道不应该转发该帧，将其丢弃</li></ul></li></ul></li><li>如果网桥收到有误码的帧则直接丢弃</li><li>如果网桥收到一个无误码的广播帧，则不用进行查表，二十直接从除接收该广播帧的接口的其他接口转发该广播帧</li><li>转发表中的每条记录都有其有效时间，到期自动删除！这是因为各站点的MAC地址与网桥接口的对应关系并不是永久性的，例如某个站点更换了网卡，其MAC地址就会改变</li></ul><h4 id="透明网桥的生成树协议STP"><a href="#透明网桥的生成树协议STP" class="headerlink" title="透明网桥的生成树协议STP"></a>透明网桥的生成树协议STP</h4><ul><li>为了提高以太网的可靠性，有时需要在两个以太网之间使用多个透明网桥来提高冗余链路，但这会给网络引入环路</li><li>为了避免广播帧在环路中永久兜圈，透明网桥使用<strong>生成树协议</strong>（Spanning Tree Protocol，STP），可以在冗余链路提高网络可靠性的同时，又避免环路带来的问题<ul><li>不管网桥之间连接成了怎样复杂的带环拓扑，网桥之间通过<strong>交互网桥协议单元</strong>（Bridge Protocol Data Unit，BDPU），找出原网络拓扑的一个连通子集，在这个自己里整个连通的网络中不存在环路</li><li>当首次连接网桥或网络拓扑发生变化时，网桥都会重新构造生成树，以确保网络的连通</li></ul></li></ul><h3 id="交换式以太网"><a href="#交换式以太网" class="headerlink" title="交换式以太网"></a>交换式以太网</h3><ul><li>网桥的接口数量很少，通常只有2~4个，一般只用来连接不同的网段。</li><li>1990年面世的交换式集线器，本质上是具有多个接口的网桥，常称为以太网交换机或二层交换机<ul><li>二层 是指以太网交换机工作在数据链路层</li><li>与网桥相同，交换机内部的转发表也是通过自学习算法，基于网络中各主机间的通信，自动的逐步建立起来的</li><li>交换机也使用生成树协议STP，来产生能够连通全网但不产生环路的通信路径</li></ul></li><li>仅使用交换机（而不使用集线器）的以太网就是交换式以太网</li></ul><h4 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h4><ul><li>以太网交换机本质上就是一个具有多个接口的网桥<ul><li>交换机也使用生成树协议STP，来产生能够连通全网但不产生环路的通信路径</li><li>交换机自学习和转发帧的流程与网桥是相同的</li></ul></li><li>交换机的每个接口可以连接计算机，也可以连接集线器或另一个交换机<ul><li>当交换机的接口与计算机或交换机连接时，可以工作在全双工方式，并能在自身内部同时连通多对接口，使每一对相互通信的计算机都能像独占传输媒体那样，无碰撞的传输数据，这样就不需要使用CSMA&#x2F;CD协议了</li><li>当交换机的接口连接的是集线器时，该接口就只能使用CSMA&#x2F;CD协议并只能工作在半双工方式</li><li>选择的交换机和网卡都能自动识别上述两种情况，并自动切换工作方式</li></ul></li><li>一般的交换机都采用“存储转发”方式，为了减小交换机的转发时延，某些交换机采用了直通交换方式</li><li>采用直通交换方式的交换机，在接收帧的同时就立即按帧的目的MAC地址决定该帧的转发接口，然后通过其内部基于硬件的交叉矩阵进行转发，而不必把整个帧先缓存后再进行处理<ul><li>直通交换的时延非常小</li><li>直通交换不检查差错就直接将帧转发出去，有可能会将一些无效帧转发给其他主机</li></ul></li></ul><h3 id="共享以太网与交换以太网的对比"><a href="#共享以太网与交换以太网的对比" class="headerlink" title="共享以太网与交换以太网的对比"></a>共享以太网与交换以太网的对比</h3><ul><li>单播帧的比较<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%8D%95%E6%92%AD%E5%B8%A7%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="单播帧的比较"></li><li>广播帧的比较<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%B9%BF%E6%92%AD%E5%B8%A7%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="广播帧的比较"></li><li>碰撞帧的比较<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E7%A2%B0%E6%92%9E%E5%B8%A7%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="碰撞帧的比较"></li></ul><h3 id="以太网的MAC帧格式"><a href="#以太网的MAC帧格式" class="headerlink" title="以太网的MAC帧格式"></a>以太网的MAC帧格式</h3><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84MAC%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="以太网的MAC帧格式"></p><h2 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h2><blockquote><p>虚拟局域网VLAN(Virtual Local Area Network) 是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。用于解决广播域过大造成的广播风暴问题</p></blockquote><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><ul><li><p>IEEE 802.1Q帧 对以太网的 MAC帧格式进行了拓展，插入了4字节的VLAN标记<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/IEEE802-1Q%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="IEEE802-1Q帧格式"></p></li><li><p>VLAN标记的最后12比特称为VLAN标识符VID，他唯一的标志了以太网帧属于哪一个VLAN</p><ul><li>VID的取值范围是0~4095(0 ~ 2<sup>12</sup> -1)</li><li>0和4095都不用来表示VLAN</li></ul></li><li><p>802.1Q帧是由交换机来处理的，而不是用户主机处理的</p><ul><li>当交换机收到普通的以太网帧时，会将其插入4字节的VLAN标记转变为802.1Q帧，简称  打标签</li><li>当交换机转发802.1Q帧时，可能会删除其4字节VLAN标记转变为普通以太网帧，简称  去标签</li></ul></li></ul><h4 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h4><h5 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h5><ul><li>连接用户计算机</li><li>只能属于一个VLAN</li><li>PVID与端口所属VLAN的ID相同，默认值为1</li><li>接受处理方法<ul><li>一般只接受未打标签的普通以太网帧，并给其打上标签</li></ul></li><li>发送处理方法<ul><li>若帧中的VID等于端口PVID，则去掉标签并转发；否则丢弃</li></ul></li></ul><h5 id="Trunk"><a href="#Trunk" class="headerlink" title="Trunk"></a>Trunk</h5><ul><li>交换机之间或交换机与路由器之间的连接</li><li>可以属于多个VLAN</li><li>用户可以设置PVID，默认为1</li><li>接收处理方法<ul><li>接收已打标签的帧</li><li>接收未打标签的帧，根据端口的PVID值给帧打标签</li></ul></li><li>发送处理方法<ul><li>帧中VID等于端口PVID，去掉标签再转发</li><li>帧中VID不等于端口PVID，直接转发</li></ul></li></ul><h5 id="Hybrid"><a href="#Hybrid" class="headerlink" title="Hybrid"></a>Hybrid</h5><ul><li>交换机之间，交换机与路由器、交换机与用户计算机之间的连接</li><li>可以属于多个VLAN</li><li>用户可以设置PVID，默认为1</li><li>接收处理方法<ul><li>接收已打标签的帧</li><li>接收未打标签的帧，根据端口的PVID值给帧打标签</li></ul></li><li>发送处理方法<ul><li>查看数据帧中的VID是否再端口的“去标签”列表中<ul><li>如果存在 则去标签再转发</li><li>不存在则直接转发</li></ul></li></ul></li></ul><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><blockquote><p>网络层的主要任务就是将分组从源主机经过多个网络和多段链路传输到目的主机，可以将该任务划分为分组转发和路由选择两种重要功能</p></blockquote><h2 id="网络层向其上层提供的两种服务"><a href="#网络层向其上层提供的两种服务" class="headerlink" title="网络层向其上层提供的两种服务"></a>网络层向其上层提供的两种服务</h2><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E8%99%9A%E7%94%B5%E8%B7%AF%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1.png" alt="虚电路服务和数据报服务"></p><h2 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h2><blockquote><p>网际协议(Internet Protocol, IP) 是TCP&#x2F;IP体系结构网际层中的核心协议</p></blockquote><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/TCP-IP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="TCP-IP体系结构"></p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li>IP地址时因特网上的主机和路由器所使用的地址，用于标识两部分信息<ul><li><strong>网络编号</strong>：标识因特网上数以百万计的网络</li><li><strong>主机编号</strong>：标识同一网络上不同主句（或路由器）</li></ul></li><li>之前介绍的MAC地址不具备区分不同网络的功能<ul><li>如果只是一个单独的网络，不接入因特网，可以只使用MAC地址（这不是一般用户的应用方式）</li><li>如果主机所在的网络要接入因特网，则IP地址和MAC都需要使用</li></ul></li><li>数据包转发过程中IP地址和MAC地址的变化情况：<ul><li>源IP地址和目的IP地址保持不变</li><li>源MAC地址和目的MAC地址逐个链路改变</li></ul></li></ul><h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3><ul><li>源主机在自己的ARP高速缓存表中查找目的主机的IP地址所对应的MAC地址，若找到了，则可以封装MAC帧进行发送；若找不到，则发送ARP请求(封装在广播帧中)</li><li>目的主机收到ARP请求后，将源主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后给源主机发送ARP帧(封装在单播帧MAC帧)中，ARP响应中包含目的主机的IP地址和MAC地址</li><li>源主机收到ARP响应后，将目的主机的IP地址与MAC地址记录到自己的ARP高速缓存表中，然后就可以封装之前想发送的MAC帧并发送给目的主机</li><li>ARP的作用范围：逐段链路或逐个网络使用</li><li>除ARP请求和响应外，ARP还有其他类型的报文(例如用于检查IP地址冲突的”无故ARP、免费ARP“)；</li><li>ARP没有安全验证机制，存在ARP欺骗问题</li></ul><h3 id="IPv4地址及其编址方式"><a href="#IPv4地址及其编址方式" class="headerlink" title="IPv4地址及其编址方式"></a>IPv4地址及其编址方式</h3><h4 id="分类编址的IPv4地址"><a href="#分类编址的IPv4地址" class="headerlink" title="分类编址的IPv4地址"></a>分类编址的IPv4地址</h4><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/IPv4%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB.png" alt="IPv4地址的分类"></p><ul><li>只有A类、B类和C类地址可分配给网络中的主机或路由器的各接口</li><li>主机号为”全0“ 的地址是网络地址，不能分配给主机或路由器的各接口</li><li>主机号为”全1“的地址是广播地址，不能分配给主机或路由器的各接口</li></ul><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%88%86%E7%B1%BB%E7%BC%96%E5%9D%80%E7%9A%84IPv4%E5%9C%B0%E5%9D%80.png" alt="分类编址的IPv4地址"></p><h4 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h4><ul><li>为新增网络申请新的网络号会带来一下弊端<ul><li>需要等待时间和花费更多的费用</li><li>会增加其他路由器中路由表记录的数量</li><li>浪费原有网络号中剩余的大量IP地址</li></ul></li><li>可以从主机号部分借用一部分比特作为子网号</li><li>32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号<ul><li>子网掩码使用连续的比特1来对应网络号和子网号</li><li>子网掩码使用连续的比特0来对应主机号</li><li>将划分子网的IPv4地址与其相应的子网掩码进行逻辑与运算就可得到IPv4地址所在子网的网络地址</li></ul></li><li>给定一个分类的IP地址和其相应的子网掩码，就可知道子网划分的细节：<ul><li>划分出的子网数量</li><li>每个子网可分配的IP地址的数量</li><li>每个子网的网络地址和广播地址</li><li>每个子网可分配的最小和最大地址</li></ul></li><li>默认子网掩码是指在未划分子网的情况下使用的子网掩码<ul><li>A类：255.0.0.0</li><li>B类：255.255.0.0</li><li>C类：255.255.255.0</li></ul></li></ul><h4 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h4><ul><li>划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的C类网因为其地址空间太小并没有得到充分使用，而因特网的IP地址仍在加速消耗</li><li>1993年，IETF发布了无分类域间路由选择CIDR(Classless Inter-Domain Routing)的RFC文档<ul><li>CIDR消除了传统A类、B类和C类地址，以及划分子网的概念</li><li>CIDR可以更加有效的分配IPv4的地址空间，并且可以在新的IPv6使用之前允许因特网的规模继续增长</li></ul></li><li>CIDR使用”斜线记法“，或称CIDR记法。即在IPv4地址后面加上斜线 ”&#x2F;“，在斜线后面写上网络前缀所占的比特数量。</li><li>CIDR实际上是将网络前缀都相同的连续的IP地址组成一个 “CIDR地址块”</li><li>我们只要知道CIDR地址块中的任何一个地址，就可以知道该地址块的全部细节：<ul><li>地址块的最小地址</li><li>地址块的最大地址</li><li>地址块中的地址数量</li><li>地址块聚合某类网络的数量</li><li>地址掩码</li></ul></li><li>路由聚合的方法是找共同前缀</li><li>网络前缀越长，地址块越小，路由越具体</li><li>若路由器查表转发分组时发现有多条路可选，则选着网络前缀最长的那条，这称为最长前缀匹配，因为这样的路由更具体。</li></ul><h3 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h3><h4 id="定长的子网掩码FLSM-Fixed-Length-Subnet-Mask"><a href="#定长的子网掩码FLSM-Fixed-Length-Subnet-Mask" class="headerlink" title="定长的子网掩码FLSM(Fixed Length Subnet Mask)"></a>定长的子网掩码FLSM(Fixed Length Subnet Mask)</h4><ul><li>使用同一各子网掩码来划分子网</li><li>子网划分方式不灵活：只能划分出2<sup>n</sup> 个子网(n是从主机号部分借用的用来作为子网号的比特数量)</li><li>每个子网所分配的IP地址数量相同，容易造成IP地址浪费</li></ul><h4 id="变长的子网掩码VLSM-Variable-Length-Subnet-Mask"><a href="#变长的子网掩码VLSM-Variable-Length-Subnet-Mask" class="headerlink" title="变长的子网掩码VLSM(Variable Length Subnet Mask)"></a>变长的子网掩码VLSM(Variable Length Subnet Mask)</h4><ul><li>使用不同的子网掩码来划分子网</li><li>子网划分方式灵活：可以按需分配</li><li>每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费</li></ul><h3 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h3><ul><li>主机发送IP数据报<ul><li>判断目的主机是否与自己在同一个网络<ul><li>若在同一个网络，则属于直接交付</li><li>若不在同一个网络，则属于简介交付，传输给主机所在网络的默认网关（路由器），由默认网关帮忙转发</li></ul></li></ul></li><li>路由器转发IP数据报<ul><li>检查IP数据报首部是否出错<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目<ul><li>若找到匹配的条目，则转发给条目中指示的下一跳</li><li>若找不到，则丢弃该IP数据报并通告源主机</li></ul></li></ul></li></ul><h3 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h3><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="IPv4数据报首部格式"></p><ul><li><p>版本 占4比特，表示IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4 即IPv4</p></li><li><p>首部长度  占4比特，表示IP数据报首部的长度，该字段的取值以4字节为单位</p><ul><li>最小十进制取值为5，表示IP数据报首部只有20字节固定部分；</li><li>最大十进制取值为15，表示IP数据报首部包含20字节的固定部分和最大40字节可变部分</li></ul></li><li><p>可选字段 长度从1个字节到40个字节不等。用来支持排错、测量及安全等措施。</p><ul><li>可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理IP数据报的开销。实际上可选字段很少被使用。</li></ul></li><li><p>填充字段  确保首部长度为4字节的整数倍。使用全0进行填充。</p></li><li><p>区分服务 占8比特，用来获得更好的服务。只有在使用区分服务时，该字段才起作用，一般情况下都不使用该字段</p></li><li><p>总长度 占16比特，表示IP数据报的总长度（首部+数据载荷）。最大取值为十进制的65535，以字节为单位</p></li><li><p>标识 占16比特，属于同一个数据报的各分片数据报应该具有相同的标识。IP软件维持一个计数器，计数器值加1，并将此值赋给标识字段</p></li><li><p>标志 占3比特， 各比特含义如下：</p><ul><li>DF位：1表示不允许分片；0表示允许分片。</li><li>MF位：1表示后面还有分片；0表示这是最后一个分片。</li><li>保留位：必须为0。</li></ul></li><li><p>片偏移 占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。片偏移以8个字节为单位</p></li><li><p>生存时间TTL 占8比特，表示IP数据报的生存时间</p><ul><li>最初以秒为单位，最大生存周期为255秒；路由器转发IP数据报时，将IP数据报首部中的该字段的值减去IP数据报在本路由器上所消耗的时间，若不为0就转发，反之就丢弃</li><li>现在以跳数为单位，路由器转发IP数据报时，将IP数据报首部中该字段的值减1，若不为0则转发，反之则丢弃</li><li>IP数据报每经过一个路由器，路由器这都要重新计算首部检验和，因为某些字段(生存时间、标志、片偏移)的取值可能会发生变化</li></ul></li><li><p>协议 占8比特，指明IPv4数据报的数据部分是何种协议数据单元。常用的一些协议和相应的协议字段值如下：<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E5%80%BC.png" alt="IP数据报协议字段值"></p></li><li><p>首部检验和 占16比特，用来检测首部在传输过程中是否出现差错。比CRC检验码简单，称为因特网检验和</p><ul><li>由于IP层本身并不提供可靠传输的服务，并且计算首部效验和是一项耗时的操作，因此在IPv6中，路由器不在计算首部校验和，从而更快转发IP数据报</li></ul></li><li><p>源IP地址和目的IP地址 各占32比特，用来填写发送该IP数据报的源主机的IP地址和接收该IP数据报的目的主机的IP地址</p></li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="路由选择协议概述"><a href="#路由选择协议概述" class="headerlink" title="路由选择协议概述"></a>路由选择协议概述</h3><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE.png" alt="常见的路由选择协议"></p><h4 id="静态路由选择"><a href="#静态路由选择" class="headerlink" title="静态路由选择"></a>静态路由选择</h4><ul><li>由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由</li><li>这种人工配置简单、开销小，但不能即使适应网络状态(流量、拓扑等)的变化</li><li>一般只在小规模网络中采用<h4 id="动态路由选择"><a href="#动态路由选择" class="headerlink" title="动态路由选择"></a>动态路由选择</h4></li><li>路由器通过路由选择协议自动获取路由信息</li><li>比较复杂、开销比较大，能较好地适应网络状态的变化</li><li>适用于大规模网络</li></ul><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><blockquote><p><strong>路由信息协议RIP</strong>(Routing Infomation Protocol)是内部网关协议IGP中最先得到广泛使用的协议之一</p></blockquote><ul><li>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组记录，称为 ”距离向量“</li><li>RIP使用跳数作为度量来衡量到达目的网络的距离<ul><li>路由器到直连网络的距离定义为1</li><li>路由器到非直连的网络的距离定义为所经过的路由器数加1。</li><li>允许一条路径最多只包含15个路由器。距离等于16相当于不可达。因此，RIP只适用于小型网络</li></ul></li><li>RIP认为好的路由就是距离短的路由，也就是所通过路由器数量最少的路由</li><li>当到达同一目的网络有多条距离相等的路由时，可以进行等价负载均衡</li><li>RIP包含一下三个要点<ul><li>和谁交换信息    仅和相邻路由器交换信息</li><li>交换什么信息    自己的路由表</li><li>何时交换信息    周期性交换</li></ul></li><li><strong>RIP的基本工作原理</strong><ul><li>路由器刚开始工作时，只知道自己到直连网络的距离为1</li><li>每个路由器仅和相邻路由器周期性的交换并更新路由信息</li><li>若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一挑地址，称为收敛</li></ul></li><li><strong>RIP的路由条目的更新规则</strong><ul><li>发现了新网络，添加</li><li>到达目的网络，相同下一跳，最新消息，更新</li><li>到达目的网络，不同下一跳，新路由优势，更新</li><li>到达目的网络，不同下一跳，新路由劣势，不更新</li><li>到达目的网络，不同下一跳，等价负载均衡</li></ul></li><li>RIP路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。可以采用多种措施减少这种问题的发生或减少该问题带来的危害<ul><li>限制最大路径距离为15</li><li>当路由表发生变化时就立即发送更新报文（即 “<strong>触发更新</strong>”），而不是周期性发送</li><li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即 ”<strong>水平分割</strong>“）</li></ul></li></ul><h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><blockquote><p>开放最短路径优先OSPF(Open Shortest Path First)， 使用了Dijkstra提出的最短路径算法SPF</p></blockquote><ul><li>OSPF时基于链路状态的，而不像RIP那样时基于距离向量的</li><li>OSPF采用SPF算法计算路由，从算法上保证了不会产生路由环路</li><li>OSPF不限制网络规模，更新效率高，收敛速度快</li><li>链路状态时指本路由器都和哪些路由器相邻，以及相应链路的”代价“<ul><li>代价 用来表示费用、距离、时延、带宽等等</li></ul></li><li>使用OSPF的每个路由器都会产生链路状态通告LSA(Link State Advertisement)。包括一下内容：<ul><li>直连网络的链路状态信息</li><li>邻居路由器的链路状态信息</li></ul></li><li>LSA被封装再链路状态更新分组LSU中采用洪泛法发送</li><li>使用OSPF的每个路由器都有一个链路状态数据库LSDB,用于存储LSA</li><li>通过各路由洪泛发送封装有自己LSA的LSU分组，各路由器的LSDB最终将到达一致</li><li>使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出格子到达其他各路由器的最短路径，即构建各自的路由表</li><li>OSPF有一下五种分组类型<ul><li>问候（Hello）分组</li><li>数据库描述(Database Description)分组</li><li>链路状态请求(Link State Request) 分组</li><li>链路状态更新(Link State Update)分组</li></ul></li><li>OSPF再多点接入网络中路由器邻居关系的建立<ul><li>选举指定路由器DR(designated router)和备用的指定路由器BDR(backup designated router)</li><li>所有的非DR&#x2F;BDR只与DR&#x2F;BDR建立邻居关系</li><li>非DR&#x2F;BDR之间通过DR&#x2F;BDR交换信息</li></ul></li><li>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统在划分为若干个更小的范围，叫做区域(Area)<ul><li>划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的通信量</li></ul></li></ul><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><ul><li>外部网关协议EGP(例如边界网关协议BGP)<ul><li>在不同自治系统内，度量路由的”代价“(距离，带宽，费用等)可能不同，因此，对于自治系统之间的路由选择，使用”代价“作为度量来寻找最佳路由是不行的</li><li>自治系统之间的路由选择必须考虑相关策略</li><li>BGP只能是力求寻找一条能够到达目的网络且比较好的路由(不能有环路)，而并非寻找一条最佳路由</li></ul></li><li>在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的 ”BGP发言人“</li><li>不同自治系统的BGP发言人要交换路由信息，必须首先建立TCP连接，端口号为179<ul><li>在此TCP连接上交换BGP报文以建立BGP会话</li><li>利用BGP会话交换路由信息(例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等)</li><li>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站或对等站</li></ul></li><li>BGP发言人除了运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP，如OSPF或RIP</li><li>BGP发言人交换网络可达性的信息(要到达某个网络所要经过的一系列自治系统)</li><li>当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由。也就是构造出树形结构、不存在回路的自治系统连通图</li><li>BGP适用于多级结构的因特网</li><li>BGP-4有一下四种报文<ul><li><strong>OPEN(打开)报文</strong>：用来与相邻的另一个BGP发言人建立关系，使通信初始化</li><li><strong>UPDATE(更新)报文</strong>：用来通告某一路由的信息，以及列出要撤销的多条路由</li><li><strong>KEEPLIVE(保活)报文</strong>：用来周期性的证实邻站的连通性</li><li><strong>NOTIFICATION(通知)报文</strong>：用来发送检测到的差错</li></ul></li></ul><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><ul><li>为了更有效的转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP(Internet Control Message Protocol)</li><li>主机或路由器使用ICMP来发送差错报告报文和询问报文</li><li>ICMP报文被封装在IP数据报中发送</li><li>ICMP差错报告报文共有一下五种：<ul><li>终点不可达</li><li>源点抑制</li><li>时间超过</li><li>参数问题</li><li>改变路由(重定向)</li></ul></li><li>一下情况不应发送ICMP差错报告报文<ul><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li><li>对具有多播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址(如127.0.0.1或0.0.0.0)的数据报不发送ICMP差错报告报文</li></ul></li><li>常用的ICMP询问报文有以下两种：<ul><li>回送请求和回答</li><li>时间戳请求和回答</li></ul></li><li>ICMP应用：<ul><li>分组网间探测PING</li><li>跟踪路由traceroute</li></ul></li></ul><h2 id="虚拟专用网VPN与网络地址转换NAT"><a href="#虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="虚拟专用网VPN与网络地址转换NAT"></a>虚拟专用网VPN与网络地址转换NAT</h2><h3 id="虚拟专用网VPN-Virtual-Private-Network"><a href="#虚拟专用网VPN-Virtual-Private-Network" class="headerlink" title="虚拟专用网VPN(Virtual Private Network)"></a>虚拟专用网VPN(Virtual Private Network)</h3><ul><li>利用公用的因特网作为本机构各专用网之间的通信载体，这也的专用网又称为虚拟专用网</li><li>同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为内联网VPN</li><li>VPN要保证传输数据的安全性，会将原始的内部数据报进行加密，然后再将其封装成为在因特网上发送到的外部数据报</li><li>有时一个机构的VPN需要有某些外部机构参加进来，这样的VPN就称为外联网VPN</li></ul><h3 id="网络地址转换NAT-Network-Address-Translation"><a href="#网络地址转换NAT-Network-Address-Translation" class="headerlink" title="网络地址转换NAT(Network Address Translation)"></a>网络地址转换NAT(Network Address Translation)</h3><ul><li>由于IP地址的紧缺，一个机构能够申请到的IP地址数量往往小于本机构所拥有的主机数量。因此，虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址，而不是需要申请的、在因特网上使用的公有地址</li><li>NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源</li><li>由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。这样，用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和IP地址一起进行转换的技术叫网络地址和端口号转换NAPT(Network Address and Port Translation)</li><li>对于一些P2P网络应用，需要外网主机主动与内网主机进行通信，在通过NAT时会遇到问题，需要网络应用自己使用一些特殊的NAT穿越技术来解决问题</li><li>由于NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护</li></ul><h2 id="IP多播技术"><a href="#IP多播技术" class="headerlink" title="IP多播技术"></a>IP多播技术</h2><h3 id="IP多播技术的相关基本概念"><a href="#IP多播技术的相关基本概念" class="headerlink" title="IP多播技术的相关基本概念"></a>IP多播技术的相关基本概念</h3><ul><li>多播(Multicast，也称为组播) 是一种实现“一对多”通信的技术，与传统单播“一对一”通信相比，多播可以极大地节省网络资源</li><li>在因特网上进行的多播，称为IP多播</li></ul><h3 id="IP多播地址和多播组"><a href="#IP多播地址和多播组" class="headerlink" title="IP多播地址和多播组"></a>IP多播地址和多播组</h3><ul><li>在IPv4中，D类地址被作为多播地址(224.0.0.0~239.255.255.255)</li><li>多播地址只能用作目的地址，而不能用作源地址</li><li>用每一个D类地址来标识一个多播组，使用同一个IP多播地址接收IP多播数据报的所有主机就构成了一个多播组<ul><li>每个多播组的成员是可以随时变动的，一台主机可以随时加入或离开多播组</li><li>多播组的成员的数量和所在的地理位置也不受限制，一台主机可以属于几个多播组</li></ul></li><li>非多播组成员也可以向多播组发送IP多播数据报</li><li>与IP数据报相同，IP多播数据报也是“尽最大努力交付”，不保证一定能够交付给多播组内的所有成员</li><li>IPv4多播地址又可分为预留的多播地址(永久多播地址)、全球范围可用的多播地址以及本地管理的多播地址</li><li>IP多播可以分为以下两种<ul><li>只在本局域网上进行的硬件多播</li><li>在因特网上进行的多播</li></ul></li></ul><h3 id="在局域网上进行硬件多播"><a href="#在局域网上进行硬件多播" class="headerlink" title="在局域网上进行硬件多播"></a>在局域网上进行硬件多播</h3><ul><li>由于MAC地址(也称为硬件地址)有多播MAC地址这种类型，因此只要把IPv4多播地址映射成多播MAC地址，即可将IP多播数据报封装在局域网的MAC帧中，而MAC帧首部中的目的MAC地址字段的值，就设置为由IPv4多播地址映射成的多播MAC地址。这样，可以很方便地利用硬件多播来实现局域网内的IP多播</li><li>当给某个多播组的成员主机配置其所属多播组的IP多播地址时，系统就会根据映射规则从该IP多播地址生成相应的局域网多播MAC地址</li><li>因特网号码指派管理局IAIA，将自己从IEEE注册管理机构申请到的以太网MAC地址块中从01-00-5E-00-00-00到01-00-5E-7F-FF-FF的多播MAC地址，用于映射IPv4多播地址<ul><li>这些多播MAC地址的左起前25个比特都是相同的，剩余23个比特可以任意变化，因此共有2<sup>23</sup> 个</li></ul></li><li>由于IP多播地址可变化的28比特的前5个比特无法映射到MAC多播地址的低23比特，这会造成IP多播地址与多播MAC地址的映射关系并不是唯一的</li><li>由于IP多播地址与多播MAC地址的映射关系不是唯一的，因此收到IP多播数据报的主机还要再网际层利用软件进行过滤，把不是主机要接收的IP多播数据报丢弃</li></ul><h3 id="网际组管理协议IGMP"><a href="#网际组管理协议IGMP" class="headerlink" title="网际组管理协议IGMP"></a>网际组管理协议IGMP</h3><blockquote><p>网际组管理协议(Internet Group Management Protocol，IGMP)是TCP&#x2F;IP体系结构网际层中的协议，其作用是让连接在本地局域网上的多播路由器字段本局域网上是否有主机(实际上是主机的某个进程) 加入或退出了某个多播组</p></blockquote><ul><li>IGMP仅在本网络有效，使用IGMP并不能知道多播组所包含的成员数量，也不能知道多播组的成员都分布再哪些网络中</li><li>仅使用IGMP并不能再因特网上进行IP多播。连接在局域网上的多播路由器还必须和因特网上的其他多播路由器协同工作，以便把IP多播数据报用最小的代价传送给所有的多播组成员，这就需要使用多播路由选择协议<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E7%BD%91%E9%99%85%E5%B1%82%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AEIGMP.png" alt="网际层管理协议IGMP"></li></ul><h3 id="多播路由选择协议"><a href="#多播路由选择协议" class="headerlink" title="多播路由选择协议"></a>多播路由选择协议</h3><ul><li>多播路由选择协议的主要任务是：在多播路由器之间为每个多播组建立一个多播转发树<ul><li>多播转发数连接多播源和所有拥有该多播组成员的路由器</li><li>IP多播数据报只要沿着多播转发树进行洪泛，就能被传送到所有拥有该多播组成员的多播路由器</li><li>之后，在多播路由器所直连的局域网内，多播路由器通过硬件多播，将IP多播数据报发送给该多播组的所有成员</li></ul></li><li>针对不同的多播组需要维护不同的多播转发树，而且必须动态的适应多播组成员的变化，但此时网络拓扑并不一定发生变化，因此多播路由选择协议要比单播路由选择协议(例如RIP、OSPF等)复杂得多</li><li>即使某个主机不是任何多播组得成员，他也可以向任何多播组发送多播数据报</li><li>为了覆盖多播组得所有成员，多播转发树可能要经过一些没有多播组成员得路由器</li><li>目前有以下两种方法来构建多播转发树<ul><li>基于源树(Source-Base Tree) 多播路由选择</li><li>组共享树(Group-Shared Tree) 多播路由选择</li></ul></li></ul><h4 id="基于源树多播路由选择"><a href="#基于源树多播路由选择" class="headerlink" title="基于源树多播路由选择"></a>基于源树多播路由选择</h4><ul><li>基于源树得多播路由选择得最典型算法是反向路径多播(Reverse Path Multicasting，RPM) 算法。</li><li>RPM算法包含以下两个步骤<ul><li>利用反向路径广播(Reverse Path Broadcasting，RPB)算法建立一个广播转发树</li><li>利用剪枝算法，剪除广播转发树中得下游非成员路由器，获得一个多播转发树</li></ul></li><li>要建立广播转发树，可以使用洪泛法</li><li>利用反向路径广播RPB算法生成得广播转发树，不会存在环路，因此可以避免广播分组在环路中兜圈。</li><li>RPB算法得要点是：每一台路由器在收到一个广播分组时，先检查该广播分组是否时从源点经最短路径传送来的<ul><li>若是，本路由器就从自己除刚才接收该广播分组得接口得所有其他接口转发该广播分组。</li><li>否则，丢弃该广播分组</li><li>如果本路由器有好几个邻居路由器都处在到源点得最短路径上，也就是存在好几条同一长度得最短路径，那么只能选取一条最短路径。选取得规则时这几条最短路径中得邻居路由器得IP地址最小得那条最短路径</li></ul></li><li>RPB中“反向路径”得意思是：在计算最短路径时把源点当作终点</li></ul><h4 id="组共享多播路由选择"><a href="#组共享多播路由选择" class="headerlink" title="组共享多播路由选择"></a>组共享多播路由选择</h4><ul><li>组共享树多播路由选择采用基于核心得分布式生成树算法来建立共享树<ul><li>该方法在每个多播组中指定一个核心路由器，以该路由器为根，建立一棵连接多播组得所有成员路由器得生成树，作为多播转发树</li></ul></li><li>每个多播组中除了核心路由器，其他所有成员路由器都会向自己多播组中得核心路由器单播加入报文。<ul><li>加入报文通过单播朝着核心路由器转发，直到它到达已经属于该多播生成树得某个节点或者直接到达该核心路由器</li><li>加入报文所经过得路径，就确认了一条从单播该报文得边缘节点到核心路由器之间得分支，而这个新分支就被嫁接到现有得多播转发树上。</li></ul></li></ul><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h3 id="IPv6数据报基本首部"><a href="#IPv6数据报基本首部" class="headerlink" title="IPv6数据报基本首部"></a>IPv6数据报基本首部</h3><p><strong>所有得扩展首部并不属于IPv6数据报得首部，他们与其后面得数据部分合起来构成有效载荷</strong></p><ul><li>IPv6将IPv4数据报首部中不必要得功能取消了，这使得IPv6数据报基本首部得字段数量减少到只有8个<ul><li>但由于IPv6地址得长度扩展到了128比特，因此使得IPv6数据报基本首部得长度反而增大到了40字节，比IPv4数据报首部固定部分得长度(20字节)增大了20字节<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/IPv6%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IPv6数据报格式"></li></ul></li><li>版本字段：长度为4比特，用来表示IP协议得版本，对于IPv6该字段得值是6</li><li>通信量类字段：长度为8比特，该字段用来区分不同得IPv6数据报的类别或优先级。目前正在进行不同的通信量类性能的实验</li><li>流标号字段：长度为20比特<ul><li>IPv6提出了流的抽象概念</li><li>“流”就是因特网上从特定源点到特定终点(单播或多播)的一系列IPv6数据报(如实时音视频数据的传送)，而在这个“流”所经过的路径上的所有路由器都保证指明的服务质量</li><li>所有属于同一个流的IPv6数据报都具有同样的流标号。换句话说，流标号用于资源分配。</li><li>流标号对于实时音视频数据的传送特别有用，但对于传统的非实时数据，流标号则没有用处，把流标号字段的值置为0即可。</li></ul></li><li>有效载荷长度字段：长度为16比特，它指明IPv6数据报基本首部后面的有效载荷(包括扩展首部和数据部分)的字节数量<ul><li>该字段以字节为单位，最大取值为65535，因此IPv6数据报基本首部后面的有效载荷的最大长度为65535字节</li></ul></li><li>跳数限制字段：长度为8比特。该字段用来放置IPv6数据报在因特网中永久兜圈<ul><li>源点在每个IPv6数据报发出时即设定某个跳数限制(最大255跳)</li><li>每个路由器在转发IPv6数据报时，要先把跳数限制字段中的值减一，当跳数限制的值为0时，就把这个IPv6数据报丢弃</li></ul></li><li>下一个首部字段：长度为8比特。该字段相当于IPv4数据报首部中的协议字段或可选字段。<ul><li>当IPv6数据报没有扩展首部时，该字段的作用与IPv4的协议字段一样，它的值指出了IPv6数据报基本首部后面的数据是何种协议数据单元PDU</li><li>当IPv6数据报基本首部后面带有扩展首部时，该字段的值就标识后面第一个扩展首部的类型</li></ul></li></ul><h3 id="IPv6数据报的扩展首部"><a href="#IPv6数据报的扩展首部" class="headerlink" title="IPv6数据报的扩展首部"></a>IPv6数据报的扩展首部</h3><ul><li>IPv4数据报如果在其首部使用了该字段，则在数据报的整个传送路径中的全部路由器，都要对选项字段进行检查，这就降低了路由器处理数据报的速度。</li><li>实际上，在路径中的 路由器对很多选项时不需要检查的。因此，为了提高路由器对数据包的处理效率，IPv6把原来IPv4首部中的选项字段都放在了扩展首部中，由路径两端的源点和终点的主机来处理，而数据报传送路径中的所有路由器都不处理这些扩展首部(除逐跳选项扩展首部)。</li><li>在[RFC 2460]中定义了以下六种扩展首部<ul><li>逐跳选项</li><li>路由选择</li><li>分片</li><li>鉴别</li><li>封装安全有效载荷</li><li>目的站选项</li></ul></li><li>每一个扩展首部都由若干个字组成，他们的长度也各不相同</li><li>所有的扩展首部中的第一个字段都是8比特的下一个首部字段。该字段的值指出在该扩展首部后面是何种扩展首部</li><li>当使用多个扩展首部时，应按以上的先后顺序出现</li></ul><h3 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h3><ul><li>IPv6数据报的目的地址由三种基本类型：<ul><li>**单播(unicast)**：传统的点对点通信</li><li>**多播(multicast)**：一点对多点的通信，数据报发送到一组计算机中的每一个。IPv6没有采用广播的术语，而将广播看作多播的一个特例</li><li>**任播(anycast)**：这是IPv6新增的一种类型。任播的终点是一组计算机，但数据报只交付其中的一个，通常是按照路由算法得出得距离最近得一个。</li></ul></li></ul><h4 id="IPv6地址的分类"><a href="#IPv6地址的分类" class="headerlink" title="IPv6地址的分类"></a>IPv6地址的分类</h4><ul><li>未指明地址 ：128个比特为“全0”得地址，可缩写为两个冒号“：：”，该地址不能用作目的地址，只能用于还没有配置到一个标准IPv6地址得主机用作源地址。未指明地址仅有一个</li><li>环回地址：最低比特为1，其余127个比特为“全0”，即0:0:0:0:0:0:0:1,可缩写为::1。该地址得作用与IPv4得环回地址相同。IPv6得环回地址只有1个</li><li>多播地址：最高8比特为“全1”得地址，可记为FF00::&#x2F;8。IPv6多播地址得功能与IPv4多播地址相同。这类地址占IPv6地址空间的1&#x2F;256</li><li>本地链路单播地址：最高10比特为1111111010的地址，可记为FE80::&#x2F;10.即使用户网络没有连接到因特网，但仍然可以使用TCP&#x2F;IP协议，连接在这种网络上的主机都可以使用本地链路单播地址进行通信，但不能和因特网上的其他主机通信。这类地址占IPv6地址空间的1&#x2F;1024.</li><li>全球单播地址：全球单播地址是使用的最多的一类地址。IPv6全球单播地址采用三级结构，这是为了使路由器可以更快的查找路由。<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%85%A8%E7%90%83%E5%8D%95%E6%92%AD%E5%9C%B0%E5%9D%80%E4%B8%89%E7%BA%A7%E6%9E%B6%E6%9E%84.png" alt="全球单播地址三级架构"></li></ul><h3 id="网际层控制报文协议ICMPv6"><a href="#网际层控制报文协议ICMPv6" class="headerlink" title="网际层控制报文协议ICMPv6"></a>网际层控制报文协议ICMPv6</h3><ul><li>由于IPv6与IPv4一样，都不确保数据报的可靠交付，因此IPv6也需要使用网际控制报文ICMP来向发送IPv6数据报的源主机反馈一些差错信息，相应的ICMP版本为ICMPv6<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DICMPv6%E6%8A%A5%E6%96%87.png" alt="常用的几种ICMPv6报文"></li></ul><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>在计算机网络中进行通信的真正实体是位于通信两端主机中的进程，如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层又称为端到端协议。</li><li>根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP</li></ul><h3 id="TCP-x2F-IP运输层中的两个重要协议"><a href="#TCP-x2F-IP运输层中的两个重要协议" class="headerlink" title="TCP&#x2F;IP运输层中的两个重要协议"></a>TCP&#x2F;IP运输层中的两个重要协议</h3><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/TCP-UDP%E5%8D%8F%E8%AE%AE.png" alt="TCP-UDP协议"></p><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE.png" alt="典型应用所使用的运输层协议"></p><h3 id="运输层端口号、复用与分用"><a href="#运输层端口号、复用与分用" class="headerlink" title="运输层端口号、复用与分用"></a>运输层端口号、复用与分用</h3><ul><li><p>发送方的复用与接收方的分用<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%88%86%E7%94%A8.png" alt="复用与分用"></p></li><li><p>TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE%E6%89%80%E4%BD%BF%E7%94%A8%E7%86%9F%E7%9F%A5%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt="常用协议所使用熟知端口号"></p></li></ul><h2 id="UDP和TCP的对比"><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h2><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li>无连接</li><li>支持一对一，一对多，多对一和多对多通信</li><li>对应用层交付的报文直接打包</li><li>尽最大努力交付，也就是不可靠；不适用流量控制和拥塞控制</li><li>首部开销小，仅八字节</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li>面向连接</li><li>每一条TCP连接只能有两个端点EP，只能是一对一通信</li><li>面向字节流</li><li>可靠传输，使用流量控制和拥塞控制</li><li>首部最小20字节，最大60字节</li></ul><h2 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><ul><li><p>为了实现可靠传输，TCP采用了面向字节流的方式。</p></li><li><p>但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为TCP报文段后进行发送</p><ul><li>一个TCP报文段由首部和数据载荷两部分构成；</li><li>TCP的全部功能都体现在它的首部中各字段的作用<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="TCP报文段的首部格式"></li></ul></li><li><p><strong>序号</strong>：占32比特，序号增加到最后一个后，下一个序号就又回到0.指出本TCP报文段数据载荷的第一字节的序号</p></li><li><p><strong>确认号</strong>：占32比特，确认号增加到最后一个后，下一个确认号就又回到0.指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。若确认号为n，则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据</p></li><li><p><strong>确认标志位ACK</strong>：取值为1时确认号字段才有效，取值为0时无效。TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1</p></li><li><p><strong>数据偏移</strong>：占4比特，并以4字节为单元</p><ul><li>用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远</li><li>这个字段实际上是指出了TCP报文段的首部长度<ul><li>首部固定长度为20字节，因此数据偏移字段的最小值为 (0101)</li><li>首部最大长度为60字节，因此数据偏移字段的最大值为 (1111)</li></ul></li></ul></li><li><p><strong>保留</strong>：占6比特，保留为今后使用，但目前应置为0</p></li><li><p><strong>窗口</strong>：占16比特，以字节为单位。指出发送本报文段的一方的接收窗口</p><ul><li>窗口值作为接收方让发送方设置其发送窗口的依据</li><li>这是以接收方的接收能力来控制发送方的发送能力，称为流量控制</li></ul></li><li><p><strong>校验和</strong>：占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</p></li><li><p><strong>同步标志位SYN</strong>：在TCP连接建立时用来同步序号。</p></li><li><p><strong>终止标志位FIN</strong>：用来释放TCP连接</p></li><li><p><strong>复位标志位RST</strong>：用来复位TCP连接。</p><ul><li>当RST&#x3D;1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。</li><li>RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接</li></ul></li><li><p><strong>推送标志位PSH</strong>：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付。</p></li><li><p><strong>紧急标志位URG</strong>：取值为1时紧急指针字段有效；取值为0时紧急指针字段无效</p></li><li><p><strong>紧急指针</strong>：占16比特，以字节为单位，用来指明紧急数据的长度</p><blockquote><p>当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后时普通数据</p></blockquote></li><li><p><strong>最大报文段长度MSS选项</strong>：TCP报文段数据载荷部分的最大长度</p></li><li><p><strong>窗口扩大选项</strong>：为了扩大窗口(提高吞吐率)</p></li><li><p><strong>时间戳选项</strong>：</p><ul><li>用来计算往返时间RTT</li><li>用于处理序号超范围的情况，又称为防止序号绕回PAWS</li></ul></li><li><p><strong>选择确认选项</strong></p></li><li><p><strong>填充</strong>：由于选项的长度可变，因此使用填充来确保报文段首部能被4整除(因为数据偏移字段，也就是首部长度字段，是以4字节为单位的)</p></li></ul><h3 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h3><h4 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h4><ul><li>TCP的连接建立要解决以下三个问题<ul><li>使TCP双方能够确保对方的存在</li><li>使TCP双方能够协商一些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项)</li><li>使TCP双方能够对运输实体资源(如缓存大小，连接表中的项目等)进行分配。</li></ul></li><li>TCP使用“三报文握手”建立连接<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt="TCP建立连接"></li></ul><h4 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h4><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/TCP%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png" alt="TCP释放连接"></p><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><blockquote><p>所谓流量控制(flow control) 就是让发送方的发送速率不要太快，要让接收方来得及接收</p></blockquote><ul><li>利用滑动窗口机制可以很方便地再TCP连接上实现对发送方的流量控制<ul><li>TCP接收方利用自己的接收窗口大小来限制发送方发送窗口大小</li><li>TCP发送方收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt="TCP的流量控制"></li></ul></li></ul><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="TCP的拥塞控制"></p><h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><ul><li>TCP基于以字节为单位的滑动窗口来实现可靠传输<ul><li>发送方在未收到接收方的确认时，可将发送窗口内还未发送的数据全部发送出去</li><li>接收方只接收序号落入滑动窗口内的数据</li></ul></li><li>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。<ul><li>网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的</li><li>发送方还可能根据网络当时的拥塞情况适当减少自己的发送窗口尺寸。</li></ul></li><li>对于不按序到达的数据应如何处理。TCP并无明确要求<ul><li>如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据</li><li>TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，在按序交付上层的应用进程。</li></ul></li><li>TCP要求接收方必须有累计确认和捎带确认机制，这样可以减少传输开销，接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。<ul><li>接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源</li><li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据</li></ul></li><li>TCP的通信是全双工通信。通信中的每一方都在发送和接收报文段，因此，每一方都有自己的发送窗口和接收窗口。</li></ul><h3 id="TCP超时重传时间"><a href="#TCP超时重传时间" class="headerlink" title="TCP超时重传时间"></a>TCP超时重传时间</h3><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4.png" alt="TCP超时重传时间"></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><blockquote><p>动态主机配置协议DHCP(Dynamic Host Configuration Protocol)提供了一种机制，称为即插即用连网。这种机制允许一台计算机加入新网络时可自动获取IP地址等网络配置信息而不用手工参与</p></blockquote><ul><li>DHCP主要使用以下报文来实现其功能<ul><li>DHCP DISCOVER：DHCP发现报文</li><li>DHCP OFFER：DHCP提供报文</li><li>DHCP REQUEST：AHCP请求报文</li><li>DHCP ACK：DHCP确认报文</li><li>DHCP NACK：DHCP否认报文</li><li>DHCP RELEASE：DHCP释放报文</li></ul></li><li>DHCP报文在运输层使用UDP协议封装<ul><li>DHCP客户使用的UDP端口号为68</li><li>DHCP服务器使用的UDP端口号为67</li></ul></li><li>DHCP客户在未获取到IP地址时使用地址0.0.0.0</li><li>在每一个网络上都设置一个DHCP服务器会使DHCP服务器的数量太多。因此现在是使每一个网络至少有一个DHCP中继代理(通常是一台路由器)，它配置了DHCP服务器的IP地址信息，作为各网络中计算机与DHCP服务器的桥梁。</li></ul><h2 id="域名系统DNS-Domain-Name-System"><a href="#域名系统DNS-Domain-Name-System" class="headerlink" title="域名系统DNS(Domain Name System)"></a>域名系统DNS(Domain Name System)</h2><ul><li><p>域名系统DNS是因特网使用的命名系统，用来把便于人们记忆的具有特定含义的主机名转换为便于机器处理的IP地址</p></li><li><p>因特网采用层次树状结构的域名结构</p><blockquote><p>三级域名.二级域名.顶级域名</p></blockquote></li><li><p>顶级域名TLD分为以下三类：</p><ul><li>国家顶级域名nTLD</li><li>通用顶级域名gTLD</li><li>反向域arpa</li></ul></li><li><p>域名服务器可以划分为以下四种不同的类型</p><ul><li>根域名fwq</li><li>顶级域名服务器</li><li>权限域名服务器</li><li>本地域名服务器</li></ul></li><li><p>域名解析的过程使用两种域名查询方式</p><ul><li>递归查询</li><li>迭代查询<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%9F%9F%E5%90%8D%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="域名查询方式"></li></ul></li></ul><h2 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h2><ul><li>文件传送协议FTP(File Transfer Protocol) 是因特网上使用的最广泛的文件传送协议<ul><li>FTP提供交互式的访问，允许客户指明文件的类型与格式(如是否使用ACSII码)，并允许文件具有存取权限(如访问文件的用户必须经过授权，并输入有效的口令)</li><li>FTP屏蔽了各计算机系统的细节，因而适合于异构网络中任意计算机之间传送文件。</li></ul></li><li>FTP客户和服务器之间要建立以下两个并行的TCP连接：<ul><li>控制连接，在整个会话期间一直保持打开，用于传送FTP相关控制命令</li><li>数据连接，用于文件传输，在每次文件传输才建立，传输结束就关闭</li><li>默认情况下，FTP使用TCP 21端口进行控制连接，TCP 20端口进行数据连接。但是，是否使用TCP 20端口建立数据连接于传输模式有关，主动方式使用TCP 20端口，被动方式由服务器和客户端自行协商决定。<br><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEFTP.png" alt="文件传输协议FTP"></li></ul></li></ul><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><ul><li>电子邮件系统采用客户&#x2F;服务器方式。三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议<ul><li>用户代理时用户与电子邮件系统的接口，又称为电子邮件客户端软件</li><li>邮件服务器时电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱</li><li>协议包括发送协议(例如SMTP)和邮件读取协议(例如POP3)</li></ul></li><li>常用的邮件发送协议是简单邮件传送协议SMTP<ul><li>基于TCP连接，端口号为25</li><li>只能传送ASCII码文本</li><li>用于用户代理向邮件服务器发送邮件以及邮件服务器之间的邮件发送</li></ul></li><li>为解决SMTP传送非ASCII码文本的问题，提出了<strong>多用途因特网邮件扩展MIME</strong></li><li>常用的邮件读取协议有两个<ul><li>邮局协议POP3：非常简单、功能有限的邮件读取协议。用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机。不允许用户在邮件服务器上管理自己的邮件</li><li>因特网邮件访问协议IMAP：功能比POP3强大的邮件读取协议。用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议</li><li>POP3和IMAP都采用基于TCP连接的客户&#x2F;服务器方式。POP3使用端口110，IMAP使用端口143</li></ul></li><li>基于万维网的电子邮件<ul><li>通过浏览器登陆邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。这种工作模式与IMAP很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通用的万维网浏览器</li><li>这种工作模式在用户浏览器与邮件服务器网站之间使用HTTP协议，而邮件服务器之间使用SMTP协议</li></ul></li></ul><p><img src="/2023/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AESMTP%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="简单邮件传送协议SMTP的基本工作原理"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.两数之和</title>
      <link href="/2023/04/02/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/04/02/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><span id="more"></span><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//使用map存储 值作为key  下标作为value</span></span><br><span class="line">        <span class="comment">//在遍历数组 寻找target - nums[i]是否存在这个map中</span></span><br><span class="line">        <span class="comment">//不存在 这将nums[i]与下标放入哈希表中</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-t))&#123;</span><br><span class="line">                ans[<span class="number">1</span>] = i;</span><br><span class="line">                ans[<span class="number">0</span>] = map.get(target-t);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>202.快乐数</title>
      <link href="/2023/04/01/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>/2023/04/01/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」 定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</li><li>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</li></ul><span id="more"></span><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//如果会无限循环说明会有重复的数</span></span><br><span class="line">        <span class="comment">//使用一个set集合将所出现的数全部存入</span></span><br><span class="line">        <span class="comment">//如果将要存入的数已经在set集合中了 说明已经进入循环了 返回false</span></span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> getSum(n);</span><br><span class="line">        <span class="keyword">while</span>(t != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(t);</span><br><span class="line">            t = getSum(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            sum += t * t;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//如果最后会进入无限循环 可以将其抽象成一个环</span></span><br><span class="line">        <span class="comment">//那么我们就可以使用一个慢指针和一个快指针</span></span><br><span class="line">        <span class="comment">//快指针始终比慢指针快一步  经过循环 最后快指针会等于慢指针  </span></span><br><span class="line">        <span class="comment">//这个时候表示已经在无限循环了</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> getSum(n);</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="number">1</span> &amp;&amp; fast != slow)&#123;</span><br><span class="line">            slow = getSum(slow);</span><br><span class="line">            fast = getSum(getSum(fast));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">return</span> <span class="variable">fast</span> <span class="operator">=</span>= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">            sum += t * t;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>349.两个数组的交集</title>
      <link href="/2023/04/01/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
      <url>/2023/04/01/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p><span id="more"></span><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//将一个数组中值全都加入哈希表</span></span><br><span class="line">        <span class="comment">//遍历另一个数组中的值 判断是否在两边都存在</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            set.add(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums2[i];</span><br><span class="line">            <span class="keyword">if</span>(set.contains(t))&#123;</span><br><span class="line">                set1.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> set1.stream().mapToInt(x-&gt;x).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>242.有效的字母异位词</title>
      <link href="/2023/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
      <url>/2023/04/01/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><span id="more"></span><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//将s中的字符存进哈希表(数组也行)中 并记录其中字符出现的字数</span></span><br><span class="line">        <span class="comment">//将t中的字符与s中的字符进行比较</span></span><br><span class="line">        <span class="comment">//如果t中的字符并没有在s中出现  返回false</span></span><br><span class="line">        <span class="comment">//如果最后哈希表不为空  说明s中有t中没有的字符 返回false</span></span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(ch))&#123;</span><br><span class="line">                map.replace(ch, map.get(ch)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(ch, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            <span class="type">Character</span> <span class="variable">ch</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(ch))&#123;</span><br><span class="line">                map.replace(ch, map.get(ch)-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(ch) == <span class="number">0</span>)&#123;</span><br><span class="line">                    map.remove(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!map.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>142.环形链表</title>
      <link href="/2023/03/13/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/13/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><span id="more"></span><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//保存遍历过的所有结点</span></span><br><span class="line">        <span class="comment">//如果再次遇到已经遍历过的结点 该节点就是环的入口</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pos</span> <span class="operator">=</span> head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(pos)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited.add(pos);</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针-数学公式推导—没细想"><a href="#双指针-数学公式推导—没细想" class="headerlink" title="双指针(数学公式推导—没细想)"></a>双指针(数学公式推导—没细想)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != nullptr) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast-&gt;next == nullptr) &#123;</span><br><span class="line">                <span class="keyword">return</span> nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>160.相交链表</title>
      <link href="/2023/03/13/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/13/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><span id="more"></span><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><ul><li>走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路。</li><li>错的人就算走过了对方的路也还是会错过</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">//a指针走完a链之后从b链开始走</span></span><br><span class="line">        <span class="comment">//反之b指针也是如此 总路程相同可以使其最后同步</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">            a = a== <span class="literal">null</span> ? headB : a.next;</span><br><span class="line">            b = b== <span class="literal">null</span> ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19.删除链表倒数第N个结点</title>
      <link href="/2023/03/13/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2023/03/13/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><span id="more"></span><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//使用栈将链表中的结点入队</span></span><br><span class="line">        <span class="comment">//将倒数第N个结点pop  </span></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dum.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">phead</span> <span class="operator">=</span> dum;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(phead!=<span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(phead);</span><br><span class="line">            phead = phead.next;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//快慢指针  两个指针相隔n个结点 同时移动 </span></span><br><span class="line">        <span class="comment">//快指针到达链表末尾时 慢指针到达倒数第n个结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dum.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dum;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">traverse</span> <span class="operator">=</span> traverse(head, n);</span><br><span class="line">    <span class="keyword">if</span>(traverse == n)</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">traverse</span><span class="params">(ListNode node, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最后一个结点时 num为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> traverse(node.next, n);</span><br><span class="line">        <span class="keyword">if</span>(num == n)</span><br><span class="line">            node.next = node.next.next;</span><br><span class="line">        <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>24.两两交换链表中的节点</title>
      <link href="/2023/03/01/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>/2023/03/01/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><span id="more"></span><h1 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//下一个要进行反转的起始结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rest</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">        <span class="comment">//当前结点的下一个结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//将顺序反转</span></span><br><span class="line">        newHead.next = head;</span><br><span class="line">        <span class="comment">//此时第一个结点为newHead  newHead.next = head</span></span><br><span class="line">        <span class="comment">//于是head.next就会等于下一次交换返回的第一个结点 即newHead</span></span><br><span class="line">        head.next = swapPairs(rest);</span><br><span class="line">        <span class="comment">//返回反转后的第一个节点</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="literal">null</span>&amp;&amp;temp.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//记录下开始交换的第一个节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> temp.next;</span><br><span class="line">            <span class="comment">//记录下交换的第二个节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> temp.next.next;</span><br><span class="line">            <span class="comment">//交换完之后交换的最后一个节点就是temp.next</span></span><br><span class="line">            temp.next = end;</span><br><span class="line">            <span class="comment">//第一个节点的下一个节点指向结束节点的下一个结点</span></span><br><span class="line">            start.next = end.next;</span><br><span class="line">            <span class="comment">//反转</span></span><br><span class="line">            end.next = start;</span><br><span class="line">            temp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>206.反转链表</title>
      <link href="/2023/03/01/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/01/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><span id="more"></span><h1 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//head为空时直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//结点的前一个结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//现在指向的结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//指向当前结点的下一个结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//保存当前结点的下一个结点</span></span><br><span class="line">            next = cur.next;</span><br><span class="line">            <span class="comment">//将当前结点的next指向前一个结点</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            <span class="comment">//将前一个结点指向当前结点</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="comment">//将当前结点向前移动</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>707.设计链表</title>
      <link href="/2023/02/28/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/02/28/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ul><span id="more"></span><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//链表的长度</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//指向第一个结点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size &lt;= index || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">phead</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= index;i++)&#123;</span><br><span class="line">            phead = phead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phead.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        index = Math.max(<span class="number">0</span>,index);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">phead</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            phead = phead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = phead.next;</span><br><span class="line">        phead.next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">phead</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            phead = phead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        phead.next = phead.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移除链表元素</title>
      <link href="/2023/02/28/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2023/02/28/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</p><span id="more"></span><h1 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//当头结点为空时  直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当找到目标节点时  将前一个节点的next指向目标节点的next 完成删除</span></span><br><span class="line">        <span class="comment">//创建一个哨兵节点  next指向head  防止头节点被删除的情况</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">phead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        phead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> phead;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当使用next的时候请确保next不为空  </span></span><br><span class="line">            <span class="keyword">while</span>(node.next!=<span class="literal">null</span> &amp;&amp; node.next.val == val)&#123;</span><br><span class="line">                node.next = node.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> phead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>59.螺旋矩阵II(模拟)</title>
      <link href="/2023/02/27/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
      <url>/2023/02/27/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><span id="more"></span><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//规定上下左右的界限</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bottom</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//循环次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> n /<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//填充的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//所需数组</span></span><br><span class="line">        <span class="type">int</span> ans[][] = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">while</span>(loop &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//对上层进行填充</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;i &lt; right;i++)&#123;</span><br><span class="line">                ans[top][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对右侧进行填充</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top;i &lt; bottom;i++)&#123;</span><br><span class="line">                ans[i][right] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对下侧进行填充</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right;i &gt; left;i--)&#123;</span><br><span class="line">                ans[bottom][i] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对左侧进行填充</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bottom;i &gt; top;i--)&#123;</span><br><span class="line">                ans[i][left] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">            loop--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有当n为奇数时 中间的位置才不会被赋值</span></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            ans[top][left] = num; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>76.最小覆盖子串</title>
      <link href="/2023/02/25/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/02/25/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><span id="more"></span><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//当s的长度小于t时  直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  两个指针 分别指向起始端和包含t中字母的另一下标</span></span><br><span class="line">        <span class="comment">//  当右指针移动到包含t中所有字母时  比较此时两指针之间字串的长度是否是最小的</span></span><br><span class="line">        <span class="comment">//  为此我们需要记录t中字母种类和数量</span></span><br><span class="line">        <span class="type">int</span> need[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用于存储已有字母的数组</span></span><br><span class="line">        <span class="type">int</span> have[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于记录一出现字母的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最后的位置以及最小长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> s.length()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">//不是所需要的字符 直接移动右指针  继续循环</span></span><br><span class="line">            <span class="keyword">if</span>(need[s.charAt(right)] == <span class="number">0</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是所需要的元素    次数加一</span></span><br><span class="line">            <span class="keyword">if</span>(have[s.charAt(right)] &lt; need[s.charAt(right)])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            have[s.charAt(right)]++;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当已有字符串包含了所有目标字符串的字符</span></span><br><span class="line">            <span class="keyword">while</span>(count == t.length())&#123;</span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; min)&#123;</span><br><span class="line">                    min = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当左边要去除的字符不是所需要的字符 左指针向左移动</span></span><br><span class="line">                <span class="keyword">if</span>(need[s.charAt(left)] == <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当左边要去除的字符是所需字符  且除去后不满足覆盖子串的条件 跳出循环</span></span><br><span class="line">                <span class="keyword">if</span>(have[s.charAt(left)] == need[s.charAt(left)])&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                have[s.charAt(left)]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最小值没有变化  则返回空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(min == s.length()+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start+min);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>904.水果成篮</title>
      <link href="/2023/02/24/%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/"/>
      <url>/2023/02/24/%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p><span id="more"></span><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="comment">// 用于存储水果的种类</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        map.getOrDefault(fruits[left], <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 遍历数组 对每个位置进行开始采摘的水果最大数目进行计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fruits.length; i++) &#123;</span><br><span class="line">            map.put(fruits[i], map.getOrDefault(fruits[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 当map中的数据大于2是退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//将左指针指向的元素出现次数减一</span></span><br><span class="line">                map.put(fruits[left], map.get(fruits[left] )- <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//当出现次数为0时去除这个数</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(fruits[left]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i - left + <span class="number">1</span>;</span><br><span class="line">            ans = n &gt; ans ? n : ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="巧用swap-没理解"><a href="#巧用swap-没理解" class="headerlink" title="巧用swap(没理解)"></a>巧用swap(没理解)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;fruits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = fruits.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = fruits[i];</span><br><span class="line">        <span class="type">int</span> st = j;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; (fruits[i] == a || fruits[i] == b))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fruits[i] == b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a, b);</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(i - st, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>209.长度最小的子数组(滑动窗口)</title>
      <link href="/2023/02/24/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2023/02/24/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><span id="more"></span><h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><ul><li><strong>LeetCode 会超时</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 最终的结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子序列的数值之和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123; <span class="comment">// 设置子序列起点为i</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123; <span class="comment">// 设置子序列终止位置为j</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= target) &#123; <span class="comment">// 一旦发现子序列和超过了s，更新result</span></span><br><span class="line">                    subLength = j - i + <span class="number">1</span>; <span class="comment">// 取子序列的长度</span></span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">result</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//创建两个指针 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录 最小的差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//记录累加值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一个指针从零开始 </span></span><br><span class="line">        <span class="comment">//第二个指针从零开始 一直向前移动 将所经过的元素都相加</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            sum += nums[fast];</span><br><span class="line">            <span class="comment">//当所累加值大于等于目标值时  记录下当前两个指针之前的插值 并将第一个指针向前移动</span></span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                <span class="comment">//记录最小差值</span></span><br><span class="line">                <span class="keyword">if</span>(fast - slow &lt; index)&#123;</span><br><span class="line">                    index = fast - slow + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//累加值需要减去第一个指针指向的值 再将该指针前移</span></span><br><span class="line">                sum-=nums[slow];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">index</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="number">0</span> : index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h1><a href="/2023/02/22/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" title="26.删除排序数组中的重复项">26.删除排序数组中的重复项</a> <p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">leetcode地址</a><br></p><a href="/2023/02/24/%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/" title="904.水果成篮">904.水果成篮</a> <p><a href="https://leetcode.cn/problems/fruit-into-baskets/">leetcode地址</a><br></p><a href="/2023/02/25/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/" title="76.最小覆盖子串">76.最小覆盖子串</a> <p><a href="https://leetcode.cn/problems/minimum-window-substring/">leetcode地址</a><br></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>977.有序数组的平方</title>
      <link href="/2023/02/23/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>/2023/02/23/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><span id="more"></span><h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//将数组中的数全部平方在排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//找到第一个大于0的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                right = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建两个指针 分别向左向右遍历 比较两个数的大小</span></span><br><span class="line">        <span class="comment">//将其平方放入数组中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> right-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span>|| right &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; nums.length)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t1</span> <span class="operator">=</span> nums[left] * nums[left];</span><br><span class="line">                <span class="type">int</span> <span class="variable">t2</span> <span class="operator">=</span> nums[right] * nums[right];</span><br><span class="line">                <span class="comment">//左边大于右边  将其存入数组  指针向左移动</span></span><br><span class="line">                <span class="keyword">if</span>(t1 &lt; t2)&#123;</span><br><span class="line">                    res[index++] = t1;</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[index++] = t2;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &gt;= <span class="number">0</span>)&#123;  <span class="comment">//用完右边用左边</span></span><br><span class="line">                res[index++] = nums[left] * nums[left];</span><br><span class="line">                left--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right &lt; nums.length)&#123;<span class="comment">//用完左边用右边</span></span><br><span class="line">                res[index++] = nums[right] * nums[right];</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>844.比较含退格的字符串</title>
      <link href="/2023/02/23/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/02/23/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</p><p>注意：如果对空文本输入退格字符，文本继续为空。</p><span id="more"></span><h1 id="重构字符串"><a href="#重构字符串" class="headerlink" title="重构字符串"></a>重构字符串</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//将字符串重构  将结果相比较</span></span><br><span class="line">        <span class="keyword">return</span> build(s).equals(build(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">build</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sb.length() &gt; <span class="number">0</span>) </span><br><span class="line">                sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//创建两个指针  分别指向两个字符串尾部</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t1</span> <span class="operator">=</span> t.length()-<span class="number">1</span>; </span><br><span class="line">        <span class="comment">//创建两个变量 skip  计算需要跳过的字符个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">skipA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">skipB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若遇到 # 且 skip 不为0时不进行比较</span></span><br><span class="line">        <span class="keyword">while</span>(s1 &gt;= <span class="number">0</span> || t1 &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找到第一个需要比较的s的字母</span></span><br><span class="line">            <span class="keyword">while</span>(s1 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(s1) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    skipA++;</span><br><span class="line">                    s1--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(skipA &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        s1--;</span><br><span class="line">                        skipA--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到第二个需要比较的t的字母</span></span><br><span class="line">            <span class="keyword">while</span>(t1 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(t1) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    t1--;</span><br><span class="line">                    skipB++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(skipB &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        t1--;</span><br><span class="line">                        skipB--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//进行比较</span></span><br><span class="line">            <span class="comment">//经过前面的循环后 指针指向的位置可能已经在-1的位置了</span></span><br><span class="line">            <span class="keyword">if</span>(s1 &gt;= <span class="number">0</span>&amp;&amp;t1 &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(s1) != t.charAt(t1))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果两个指针有一个还在字符串中 还一个index=-1 表示不匹配</span></span><br><span class="line">                <span class="keyword">if</span>(s1 &gt;=<span class="number">0</span> || t1 &gt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s1--;</span><br><span class="line">            t1--;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>283.移动零</title>
      <link href="/2023/02/23/%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/2023/02/23/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作</p><span id="more"></span><h1 id="覆盖法"><a href="#覆盖法" class="headerlink" title="覆盖法"></a>覆盖法</h1><ul><li>这种写法对于[0,0,0,0,1]这类数组会造成多余的循环赋值</li><li>对此交换法的效率会更高<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个指针 指向初始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历数组  将不等于0的元素填充到指针指向的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num != <span class="number">0</span>)</span><br><span class="line">                nums[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将剩下的元素填充为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="交换法"><a href="#交换法" class="headerlink" title="交换法"></a>交换法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//创建两个指针  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当快指针指向不为0的数时  将其与慢指针所指向的元素交换</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, slow, fast);</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> slow,<span class="type">int</span> fast)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[slow];</span><br><span class="line">        nums[slow] = nums[fast];</span><br><span class="line">        nums[fast] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>26.删除排序数组中的重复项</title>
      <link href="/2023/02/22/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2023/02/22/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><span id="more"></span><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//将相同的项跳过 获得结果数组</span></span><br><span class="line">        <span class="comment">//从第二位开始获取与之前不同的元素位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果条件成立 表示出现了新的元素  将其赋值到慢指针所指的位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[index++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>27.移除元素(双指针)</title>
      <link href="/2023/02/22/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>/2023/02/22/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><span id="more"></span><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fastIndex] != val) &#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="头尾指针"><a href="#头尾指针" class="headerlink" title="头尾指针"></a>头尾指针</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//声明一个左指针 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//声明一个右指针  指向右边第一个不需要移出的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//在每次操作之后 left 或者 right 可能已经相遇了  所以每次操作需要条件进行限制</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="comment">//指向第一个需要移出的元素</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right&amp;&amp;nums[left] != val) left++;</span><br><span class="line">            <span class="comment">//指向右边第一个不需要移出的元素</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right&amp;&amp;nums[right] == val) right--;</span><br><span class="line">            <span class="comment">//将需要移除的元素覆盖</span></span><br><span class="line">            <span class="comment">//覆盖之后指针往前移</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h1><a href="/2023/02/22/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" title="26.删除排序数组中的重复项">26.删除排序数组中的重复项</a> <p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">leetcode地址</a><br></p><a href="/2023/02/23/%E7%A7%BB%E5%8A%A8%E9%9B%B6/" title="283.移动零">283.移动零</a> <p><a href="https://leetcode.cn/problems/move-zeroes/">leetcode地址</a><br></p><a href="/2023/02/23/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="844.比较含退格的字符串">844.比较含退格的字符串</a> <p><a href="https://leetcode.cn/problems/backspace-string-compare/">leetcode地址</a><br></p><a href="/2023/02/23/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/" title="977.有序数组的平方">977.有序数组的平方</a> <p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">leetcode地址</a><br></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>367.有效的完全平方根</title>
      <link href="/2023/02/22/%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
      <url>/2023/02/22/%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p><p>完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。</p><p>不能使用任何内置的库函数，如  sqrt 。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt;= num)&#123;</span><br><span class="line">                ans = mid ;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * ans == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>69.x的平方根</title>
      <link href="/2023/02/22/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
      <url>/2023/02/22/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 </p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//如果mid * mid &gt; x 则ans 会在达到平方数时或之前停止更新</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid * mid &lt;= x)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">else</span></span><br><span class="line">                <span class="variable">r</span> <span class="operator">=</span> mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>34.在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="/2023/02/21/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
      <url>/2023/02/21/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> search(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> search(nums, target+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//第一个判断条件用于判断target大于该数组中的所有数时 退出循环时left会等于数组长度</span></span><br><span class="line">        <span class="comment">//第二个条件判断target不存在时且在数组中的情况  这是nums[l]！=target</span></span><br><span class="line">        <span class="keyword">if</span>(l == nums.length || nums[l] != target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l,r-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left +  (right - left) /<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//不加等号时最终查询的结果会等于左边第一个目标值的下标</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>35.搜索插入位置</title>
      <link href="/2023/02/21/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>/2023/02/21/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>  <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> ; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>704.二分查找</title>
      <link href="/2023/02/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/02/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length ;    </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;        </span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="type">else</span> </span><br><span class="line">                <span class="variable">right</span> <span class="operator">=</span> mid;       </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/2022/11/26/SpringSecurity/"/>
      <url>/2022/11/26/SpringSecurity/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>SpringSecurity</strong>  是Spring家族中的一个安全管理框架  相比另一个安全框架Shiro  它提供了更多丰富的功能 社区资源也比Shiro丰富<br><br>一般来说中大型的项目都是使用SpringSecurity来做安全框架  小项目用Shiro的比较多 因为相比于SpringSecurity  Shiro的上手更加的简单<br>一般的Web应用需要进行认证和授权<br> 认证: 验证当前访问系统的是不是本系统的用户  并且确认具体是哪个用户<br> 授权:经过认证后判断当前用户是都有权限进行某个操作</p><span id="more"></span><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>创建一个SpringBoot工程</li><li>引入依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>引入依赖之后我们尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面 默认用户名是user 密码会输出在控制台  必须登录后才能对接口进行访问</li></ul><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><h2 id="登陆校验流程"><a href="#登陆校验流程" class="headerlink" title="登陆校验流程"></a>登陆校验流程</h2><p><a href="%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%B5%81%E7%A8%8B.png">登录校验流程</a></p><h2 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h2><h3 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h3><p>SpringSecurity的原理其实就是一个过滤器链  内部包含了提供各种功能的过滤器<br><a href="SpringSecurity%E6%B5%81%E7%A8%8B.drawio.png">SpringSecurity流程.drawio</a><br>图中只展示了核心过滤器 其他的非核心过滤器并没有在图中展示</p><ul><li><p><strong>UsernamePasswordAuthenticationFilter</strong>  负责处理我们在登录页面填写了用户名密码后的登录请求 </p></li><li><p><strong>ExceptionTranslationFilter</strong>  处理过滤链中抛出的任何AccessDeniedException和AuthenticationException</p></li><li><p><strong>FilterSecurityInterceptor</strong> 负责权限校验的过滤器</p></li><li><p>通过IDEA debug我们可以知道一共有那些过滤器  以及他们的顺序<br><a href="FilterChain.png">FilterChain</a></p></li><li><p>DefaultLoginPageGeneratingFilter：默认登录页就是这个过滤器显示出来的，如果不想要默认登录页，就去掉这个过滤器就可以了。</p></li><li><p>DefaultLogoutPageGeneratingFilter：用来显示默认注销的页面</p></li></ul><h3 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h3><p><a href="SpringSecurity%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png">SpringSecurity认证流程</a><br>当前端提交用户名和密码过来时，进入了UsernamePasswordAuthenticationFilter过滤器。</p><ul><li><p>在UsernamePasswordAuthenticationFilter过滤器里，将传进来的用户名和密码被封装成了<strong>Authentication</strong>对象【这时候最多只有用户名和密码，权限还没有】，<strong>Authentication</strong>对象通过<strong>ProviderManager</strong>的<strong>authenticate</strong>方法进行认证。</p><ul><li><p>在<strong>ProviderManager</strong>里面，通过调用DaoAuthenticationProvider的authenticate方法进行认证。</p><ul><li><p>在DaoAuthenticationProvider里，调用<strong>InMemoryUserDetailsManager</strong>的<strong>loadUserByUsername</strong>方法查询用户。【传入的参数只有用户名字符串】</p><ul><li>在<strong>InMemoryUserDetailsManager</strong>的<strong>loadUserByUsername</strong>方法里执行了以下操作<ul><li>根据用户名查询对于用户以及这个用户的权限信息【在内存里查】</li><li>把对应的用户信息包括权限信息封装成UserDetails对象。</li><li>返回UserDetails对象。</li></ul></li></ul></li><li><p>返回给了DaoAuthenticationProvider，在这个对象里执行了以下操作</p><ul><li>通过<strong>PasswordEncoder</strong>对比<strong>UserDetails</strong>中的密码和<strong>Authentication</strong>密码是否正确。【校验密码（经过加密的）】</li><li>如果正确就把<strong>UserDetails</strong>的权限信息设置到<strong>Authentication</strong>对象中。</li><li>返回<strong>Authentication</strong>对象。</li></ul></li></ul></li></ul></li><li><p>又回到了过滤器里面UsernamePasswordAuthenticationFilter。</p><ul><li>如果上一步返回了Authentication对象<br>就使用**SecurityContextHolder.getContext().setAuthentication()**方法存储对象。<br>其他过滤器会通过SecurityContextHolder来获取当前用户信息。【当前过滤器认证完了，后面的过滤器还需要获取用户信息，比如授权过滤器】</li></ul></li></ul><p><strong>加粗字体的类均是比较重要的接口，在实现认证的过程中均需要自定义一个类来重新实现或者变更为Spring中其他实现类。</strong></p><ul><li>Authentication接口  它的实现类  表示当前访问系统的用户 封装了用户相关信息</li><li>AuthenticationManager接口 定义了认证Authentication的方法</li><li>UserDetailsService接口  加载用户特定数据的核心接口  里面定义了一个根据用户名查询用户信息的方法</li><li>UserDetails接口  提供核心用户信息 通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回 然后将这些信息封装到Authentication对象中<br><a href="SpringSecurity%E6%B5%81%E7%A8%8B2.png">SpringSecurity流程2</a></li></ul><p>在初次登录中 如果认证通过  可以将生成的jwt和用户对象存入redis中  等下次用户再次携带token进行访问时 解析jwt后不用每次去数据库进行查询，造成数据库的负担  而可以在redis中更快的获取所需要的内容</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ul><li>登录<ul><li>自定义登录接口<blockquote><p>调用ProviderManager的方法进行认证 如果认证通过生成jwt 把用户信息存入redis中</p></blockquote></li><li>自定义UserDetailsService<blockquote><p>在这个实现中去查询数据库</p></blockquote></li></ul></li><li>校验<ul><li>定义jwt认证过滤器<ul><li>获取token</li><li>解析token获取其中的userid</li><li>从redis中胡哦去用户信息</li><li>存入SecurityContextHolder</li></ul></li></ul></li></ul><h1 id="核心代码实现"><a href="#核心代码实现" class="headerlink" title="核心代码实现"></a>核心代码实现</h1><h2 id="数据库校验数据"><a href="#数据库校验数据" class="headerlink" title="数据库校验数据"></a>数据库校验数据</h2><ul><li><p>首先你要写好UserMapper接口，来实现用户查询。</p></li><li><p>我们要创建一个类UserDetailsServiceImpl来实现<strong>UserDetailsService</strong>接口，来让它实现在数据库里面查询，因为它原本的实现类是查询内存的。【在Service包中】</p></li><li><p>这个接口要使用@Service注解，注入到Spring容器中。</p></li><li><p>重写<strong>loadUserByUsername</strong>方法，传入了Username参数</p><ul><li><p>首先要根据传入的Username参数，查询数据库</p></li><li><p>如果没有这个用户Objects.isNull(user)，就抛出异常</p></li><li><p>根据用户查询权限信息</p></li><li><p>添加到<strong>UserDetails接口的实现类</strong>中</p><ul><li>在domain包中创建类LoginUser，实现UserDetails接口。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;<span class="keyword">return</span> user.getPassword();&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;<span class="keyword">return</span> user.getUserName();&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UserDetailsServiceImpl 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserService service;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">//根据传入了Passward查询用户</span></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(User::getUserName,username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> service.getOne(queryWrapper);</span><br><span class="line">        <span class="comment">//如果没有查询到用户就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 查询对应的权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。</strong></p><h2 id="密码加密存储"><a href="#密码加密存储" class="headerlink" title="密码加密存储"></a>密码加密存储</h2><ul><li>默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。</li></ul><p>​- 我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。</p><p>​- 我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。</p><p>​- 我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h2><p>自定义登陆接口</p><ul><li>登录接口需要让SpringSecurity对这个接口放行【不通过过滤器链】,让用户访问这个接口的时候不用登录也能访问。</li></ul><p><strong>配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...注入BCryptPasswordEncoder....</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()<span class="comment">//允许匿名用户访问,不允许已登入用户访问</span></span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>接口中的认证</p><ul><li>在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证</li><li>所以需要在SecurityConfig中配置把AuthenticationManager注入容器。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span>&#123;</span><br><span class="line">   <span class="comment">//...注入BCryptPasswordEncoder....</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//配置放行....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>再Service中调用 AuthenticationManager 的 authenticate 方法来进行用户认证 返回Authentication</p><ul><li>使用使用authenticate方法，需要传入Authentication，但Authentication是接口，因此需要去找它的实现类。这里我们使用它的实现类是UsernamePasswordAuthenticationToke<blockquote><p>传入的Authentication只有用户名和密码：<br><br>principal 属性为用户名<br><br>credentials 属性为密码</p></blockquote></li><li>使用authenticate方法 返回Authentication<blockquote><p>如果不为空的话，传出的Authentication：<br><br>Principal属性是Userdetails<br><br>credentials 属性为null</p></blockquote></li></ul></li><li><p>如果Authentication为NULL，说明认证没通过，要么没查询到这个用户，要么密码比对不通过。然后就抛出异常。</p></li><li><p>如果认证通过，获取UserId，JwtUtil要将UserId加密成一个toekn。</p></li><li><p>将用户信息Authentication 存入redis</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LoginService</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ResponseResult&lt;Map&lt;String,String&gt;&gt; <span class="title function_">login</span><span class="params">(String userName, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//调用`AuthenticationManager`的方法进行认证</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(<span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(userName, password));</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(authenticate))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果认证通过生成token</span></span><br><span class="line">            <span class="comment">//获取userid</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getId().toString();</span><br><span class="line">            <span class="comment">//生成token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createJWT(userId);</span><br><span class="line">        <span class="comment">//authenticate存入redis</span></span><br><span class="line">        redisCache.setCacheObject(<span class="string">&quot;login:&quot;</span>+userId,loginUser);</span><br><span class="line">        <span class="comment">//把token响应给前端</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>,token);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>&lt;Map&lt;String,String&gt;&gt;(<span class="number">200</span>,<span class="string">&quot;登陆成功&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="认证过滤器"><a href="#认证过滤器" class="headerlink" title="认证过滤器"></a>认证过滤器</h2><p>SpringSecurity自带的过滤器中是用来认证用户名和密码的 但我们并没有使用它  再配置的时候就去掉了 之前的登录接口我们生成了一个token  当前端访问后端的时候需要携带这个token  二这个过滤器就是认证token的</p><ul><li><p>自定义一个过滤器</p><ul><li><p>获取请求头中的token</p><ul><li>如果获取的token字符串为空，说明前端访问后端就没有携带token。然后放行，return<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么是放行而不是抛异常呢？</span><br><span class="line">因为没有携带<span class="built_in">token</span>，有可能前端是想要登录，因此不能抛异常。</span><br><span class="line">就算是要访问其他资源，我们直接放行，Authentication对象没有用户任何信息，后面的过滤器也会抛出异常。后面也不会进行认证。</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>使用JwtUtil对token进行解析取出其中的userid。</p><p>如果token解析失败，说明前端携带的token不合法，就会抛出异常。</p></li><li><p>使用userid去redis中获取对应的LoginUser对象。</p></li><li><p>然后封装Authentication对象存入SecurityContextHolder。<br>在封装Authentication时，使用的实现类是UsernamePasswordAuthenticationToken，使用的构造方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernamePasswordAuthenticationToken</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationToken</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">530L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object principal;</span><br><span class="line">    <span class="keyword">private</span> Object credentials;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(authorities);</span><br><span class="line">        <span class="built_in">this</span>.principal = principal;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">        <span class="built_in">super</span>.setAuthenticated(<span class="literal">true</span>);<span class="comment">//标志为已认证状态，这样就不用再让`UsernamePasswordAuthenticationFilter`过滤器再进行认证了。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//首先需要获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> httpServletRequest.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">//判断token是否为Null</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasText(token)) &#123;</span><br><span class="line">            filterChain.doFilter(httpServletRequest, httpServletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如何不为空，解析token，获得了UserId</span></span><br><span class="line">        String userId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(token);</span><br><span class="line">            userId = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;toen非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据UserId查redis获取用户数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;login:&quot;</span>+userId;</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">LoginUser</span> <span class="operator">=</span> redisCache.getCacheObject(key);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(LoginUser))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后封装Authentication对象存入SecurityContextHolder</span></span><br><span class="line">        <span class="comment">//TODO 获取权限信息封装到Authentication中</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(LoginUser,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(httpServletRequest,httpServletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>该过滤器实现的接口并不是之前的Filter，而是去继承OncePerRequestFilter。</p><p>OncePerRequestFilter是Spring Boot里面的一个过滤器抽象类，这个过滤器抽象类通常被用于继承实现并在每次请求时只执行一次过滤。他能够确保在一次请求只通过一次filter，而不需要重复执行</p><p>而Servlet的Filter可能会执行多次。</p><p>然后我们将过滤器加到UsernamePasswordAuthenticationFilter的前面，在配置类中进行配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>是不是感觉有点乱，让我们缕一缕。先说一下我们对哪些接口进行了实现，或者是更改</p><ul><li><p>我们自定义了UserDetailsService接口，来实现数据库查询。当中用到了<strong>UserDetails接口的实现类——LoginUser</strong>。</p></li><li><p>在UserDetailsService接口是上一层面，我们需要对密码进行解密解析并对比。因为我们使用了<strong>PasswordEncoder接口的其他实现类BCryptPasswordEncoder</strong>。</p></li><li><p>在实现登录接口的时候</p><ul><li><p>需要AuthenticationManager的authenticate方法进行认证。</p></li><li><p>传入Authentication接口的实现类是UsernamePasswordAuthenticationToken。构造方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span></span><br></pre></td></tr></table></figure></li><li><p>这表示该Authentication是未认证的。之后会通过UsernamePasswordAuthenticationFilter过滤器来认证。</p></li></ul></li><li><p>在实现认证过滤器时，</p><ul><li><p>需要使用SecurityContextHolder.getContext().setAuthentication()方法，将用户信息Authentication存进去。方便其他Filter使用。</p></li><li><p>传入Authentication接口的实现类是UsernamePasswordAuthenticationToken。构造方法是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities)</span></span><br></pre></td></tr></table></figure></li><li><p>这表示该Authentication是认证的。之后就不会通过UsernamePasswordAuthenticationFilter过滤器来认证。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/11/18/RabbitMQ/"/>
      <url>/2022/11/18/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MQ(message queue) 从字面意思上看  本质是个队列  FIFO先入先出  只不过队列中存放的内容是message而已  还是一种跨进程的通信机制 用于上下游传递消息  在互联网架构中 MQ是一种非常常见的上下游”逻辑解耦+物理解耦”的信息通信服务  使用MQ之后 信息发送上游只需要依赖MQ 不用依赖其他服务</p><span id="more"></span><h1 id="MQ-相关概念"><a href="#MQ-相关概念" class="headerlink" title="MQ 相关概念"></a>MQ 相关概念</h1><h2 id="流量消峰"><a href="#流量消峰" class="headerlink" title="流量消峰"></a>流量消峰</h2><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><h2 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h2><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。<br><a href="%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6.png">应用解耦</a></p><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>有些服务间调用是异步的，例如A调用B，B需要花费很长时间执行，但是A需要知道B什么时候可以执行完，以前一般有两种方式，A过一段时间去调用B的查询api查询。或者A提供一个callback api,B执行完之后调用api通知A服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题,A调用B服务后，只需要监听B处理完成的消息，当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务。这样A服务既不用循环调用B的查询api，也不用提供callback api。同样B服务也不用做这些操作。A服务还能及时的得到异步处理成功的消息。<br><a href="%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.png">异步处理</a></p><h1 id="MQ-的分类"><a href="#MQ-的分类" class="headerlink" title="MQ 的分类"></a>MQ 的分类</h1><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><ul><li>优点:单机吞吐量万级 时效级ms级  可用性高 基于主从架构实现高可用性 消息可靠性较低的概率丢失数据</li><li>缺点 官方社区现在对ActiveMQ 5.x 维护越来越少 高吞吐量场景较少使用。</li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>大数据的杀手锏  谈到大数据领域内的消息传输 则绕不开Kafka 这款为大数据而生的消息中间件 以其百万级TPS的吞吐量名声大震  迅速成为大数据领域的宠儿 在数据采集 传输 存储的过程中发挥着举足轻重的作用 </p><ul><li>优点  性能卓越 单机写入TPS约在百万条&#x2F;秒 最大的优点 就是吞吐量高  时效性ms级可用性非常高 kafka是分布式的 一个数据多个副本 少数机器宕机 不会丢失数据  不会导致不可用 消费者采用Pull方式获取信息  信息有序 通过控制能够保证所有信息被消费且仅被消费一次 有优秀的第三方Kafka Web管理界面Kafaka-Manager 在日志领域比较成熟 被多家公司和多个开源项目使用  功能较为简单，主要支持简单的MQ功能  在大数据领域的实时计算以及日志采集被大规模使用</li><li>缺点  Kafaka 单机超过64个队列&#x2F;分区  Load会发生明显的飙高现象 队列越多 load越高 发送信息响应时间变长 使用短轮询方式 实时性取决与轮询间隔时间  消费失败不支持重试  支持消息顺序  但是一代代理宕机后  就会产生消息乱序  社区更新较慢</li></ul><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>RocketMQ出自阿里巴巴的开源产品 用java语言实现  在设计时参考了Kafka 并做出了自己的一些改进  被阿里巴巴广泛应用在订单 交易 充值  流计算  信息推送 日志流式处理  binglog分发等场景</p><ul><li>优点 单机吞吐量十万级 可用性非常高  分布式架构 消息可以做到0丢失 MQ功能较为完善 还是分布式的 拓展性好 支持10亿级别的消息堆积 不会因为堆积导致性能下降 </li><li>缺点  支持的客户端语言不多  目前是java及c++ 其中c++不成熟 社区活跃度一般 没有在MQ核心中去实现JMS等接口  有些系统要迁移需要修改大量代码</li></ul><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>07年发布 是一个在AMQP(高级消息队列协议)基础上完成的 可复用的企业消息系统 时当前最主流的消息中间件之一</p><ul><li>优点 由于erlang语言的高并发特性  性能较好 吞吐量到万级 MQ功能比较完备 健壮 稳定 易用 跨平台 支持多种语言 支持AJAX 文档齐全 开源提供的管理界面非常棒  社区活跃度高 更新频率高</li><li>缺点 商业版需要付费 学习成本较高</li></ul><p><a href="https://www.rabbitmq.com/">官网</a></p><h1 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><ul><li><p>生产者：产生数据发送消息的程序</p></li><li><p>交换机：是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定</p></li><li><p>队列：是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式</p></li><li><p>消费者：消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p></li></ul><h2 id="RabbitMQ特性"><a href="#RabbitMQ特性" class="headerlink" title="RabbitMQ特性"></a>RabbitMQ特性</h2><p><a href="RabbitMQ%E7%89%B9%E6%80%A7.png">RabbitMQ特性</a></p><h2 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h2><p><a href="RabbitMQ%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png">RabbitMQ工作原理</a></p><ul><li><p>Broker：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p></li><li><p>Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p></li><li><p>Connection：publisher／consumer 和 broker 之间的 TCP 连接</p></li><li><p>Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</p></li><li><p>Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point)，topic (publish-subscribe) and fanout (multicast)</p></li><li><p>Queue：消息最终被送到这里等待 consumer 取走</p></li><li><p>Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据</p></li></ul><h2 id="消费生产者"><a href="#消费生产者" class="headerlink" title="消费生产者"></a>消费生产者</h2><p>创建一个类作为生产者，最终生产消息到 RabbitMQ 的队列里</p><ul><li><p>创建 RabbitMQ 连接工厂</p></li><li><p>进行 RabbitMQ 工厂配置信息</p></li><li><p>创建 RabbitMQ 连接</p></li><li><p>创建 RabbitMQ 信道</p></li><li><p>生成一个队列</p></li><li><p>发送一个消息到交换机，交换机发送到队列。”” 代表默认交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建一个连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">//工厂IP 连接RabbitMQ对列</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//用户名</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="comment">//密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//获取信道</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 生产一个对列</span></span><br><span class="line"><span class="comment">         * 1.对列名称</span></span><br><span class="line"><span class="comment">         * 2.对列里面的消息是否持久化，默认情况下，消息存储在内存中</span></span><br><span class="line"><span class="comment">         * 3.该队列是否只供一个消费者进行消费，是否进行消息共享，true可以多个消费者消费 false：只能一个消费者消费</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除，最后一个消费者端开链接以后，该队列是否自动删除，true表示自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//发消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello,world&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 发送一个消息</span></span><br><span class="line"><span class="comment">         * 1.发送到哪个交换机</span></span><br><span class="line"><span class="comment">         * 2.路由的key值是哪个本次是队列的名称</span></span><br><span class="line"><span class="comment">         * 3.其他参数信息</span></span><br><span class="line"><span class="comment">         * 4.发送消息的消息体</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明队列</p><blockquote><p>channel.queueDeclare(队列名&#x2F;String, 持久化&#x2F;boolean, 共享消费&#x2F;boolean, 自动删除&#x2F;boolean, 配置参数&#x2F;Map);</p></blockquote></li><li><p>配置参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">// 设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 声明当前队列绑定的死信交换机</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">// 声明当前队列的死信路由 key</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br></pre></td></tr></table></figure></li><li><p>发布消息</p><blockquote><p>channel.basicPublish(交换机名&#x2F;String, 队列名&#x2F;String, 配置参数&#x2F;Map, 消息&#x2F;String);</p></blockquote></li><li><p>发布的消息标识符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给消息赋予 优先级 ID 属性</span></span><br><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">10</span>).messageId(<span class="string">&quot;1&quot;</span>)build();</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br></pre></td></tr></table></figure></li></ul><h2 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//接受消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.91.200&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明接收消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag,message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//取消消息时的回调</span></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> consumerTag -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消费者消费消息</span></span><br><span class="line"><span class="comment">         * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">         * 2.消费成功之后是否要自动应答true：代表自动应答false:代表手动应答</span></span><br><span class="line"><span class="comment">         * 3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">         * 4.消费者取消消费的回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Woke-Queues"><a href="#Woke-Queues" class="headerlink" title="Woke Queues"></a>Woke Queues</h2><p>Work Queues 是工作队列（又称任务队列）的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p><h2 id="轮询消费"><a href="#轮询消费" class="headerlink" title="轮询消费"></a>轮询消费</h2><p>轮询消费消息指的是轮流消费消息，即每个工作队列都会获取一个消息进行消费，并且获取的次数按照顺序依次往下轮流。</p><p>案例中生产者叫做 Task，一个消费者就是一个工作队列，启动两个工作队列消费消息，这个两个工作队列会以轮询的方式消费消息。</p><h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费者的消息，因为它无法接收到。</p><p>为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></p><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。</p><h3 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h3><ul><li><p>Channer.basicAck(肯定确认应答)<br>第一个参数时消息的标记 第二个参数表示是否应用于多消息，RabbitMQ已知道该消息并且成功的处理消息 可以将其丢弃了</p><blockquote><p>basicAck(long deliveryTag, boolean multiple);</p></blockquote></li><li><p>Channel.basicReject (否定确认应答) 第一个参数表示拒绝 deliveryTag 对应的消息，第二个参数表示是否 requeue：true 则重新入队列，false 则丢弃或者进入死信队列。该方法 reject 后，该消费者还是会消费到该条被 reject 的消息。</p><blockquote><p>basicReject(long deliveryTag, boolean requeue);</p></blockquote></li><li><p>Channel.basicNack (用于否定确认)：示己拒绝处理该消息，可以将其丢弃</p><blockquote><p>basicNack(long deliveryTag, boolean multiple, boolean requeue);</p></blockquote><p>  第一个参数表示拒绝 deliveryTag 对应的消息，第二个参数是表示否应用于多消息，第三个参数表示是否 requeue，与 basicReject 区别就是同时支持多个消息，可以 拒绝签收 该消费者先前接收未 ack 的所有消息。拒绝签收后的消息也会被自己消费到。</p></li><li><p>Channel.basicRecover</p><blockquote><p>basicRecover(boolean requeue);</p></blockquote><p>  是否恢复消息到队列，参数是是否 requeue，true 则重新入队列，并且尽可能的将之前 recover 的消息投递给其他消费者消费，而不是自己再次消费。false 则消息会重新被投递给自己</p></li><li><p>Multiple  手动应答的好处是可以批量应答并且减少网络拥堵</p><ul><li>true 代表批量应答channel上未应答的消息</li><li>false  只有当前消息会进行应答<h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3></li></ul></li></ul><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><h2 id="RabbitMQ持久化"><a href="#RabbitMQ持久化" class="headerlink" title="RabbitMQ持久化"></a>RabbitMQ持久化</h2><p>当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久化。</p><h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p>之前我们创建的队列都是非持久化的，RabbitMQ 如果重启的化，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为true，代表开启持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启持久化</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//声明队列</span></span><br><span class="line">channel.queueDeclare(TASK_QUEUE_NAME,durable,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>需要在消息生产者发布消息的时候，开启消息的持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置生产者发送消息为持久化消息(要求保存到磁盘上)</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p><h2 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮询分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><p>为了避免这种情况，在消费者中消费消息之前，设置参数 channel.basicQos(1);</p><h3 id="不公平分发思想"><a href="#不公平分发思想" class="headerlink" title="不公平分发思想"></a>不公平分发思想</h3><p>不公平分发思想：如果一个工作队列还没有处理完或者没有应答签收一个消息，则不拒绝 RabbitMQ 分配新的消息到该工作队列。此时 RabbitMQ 会优先分配给其他已经处理完消息或者空闲的工作队列。如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker (工作队列)或者改变其他存储任务的策略</p><h3 id="预取值分发"><a href="#预取值分发" class="headerlink" title="预取值分发"></a>预取值分发</h3><p>默认消息的发送是异步发送的，所以在任何时候，channel 上不止只有一个消息来自消费者的手动确认，所以本质上是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。这个时候就可以通过使用 basic.qos 方法设置「预取计数」值来完成的。</p><p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p><p>通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p><p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><p>生产者发布消息到 RabbitMQ 后，需要 RabbitMQ 返回「ACK（已收到）」给生产者，这样生产者才知道自己生产的消息成功发布出去</p><h3 id="发布确认逻辑"><a href="#发布确认逻辑" class="headerlink" title="发布确认逻辑"></a>发布确认逻辑</h3><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>confirm 模式最大的好处在于是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><h3 id="开启发布确认"><a href="#开启发布确认" class="headerlink" title="开启发布确认"></a>开启发布确认</h3><p>发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br></pre></td></tr></table></figure><h3 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h3><p>这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，waitForConfirmsOrDie(long) 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>这种确认方式有一个最大的缺点就是：发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了<br><strong>确认发布是指成功发送到了队列 并不是消费者消费了消息</strong></p><h3 id="批量发布确认"><a href="#批量发布确认" class="headerlink" title="批量发布确认"></a>批量发布确认</h3><p>单个确认发布方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断达到100条消息的时候，批量确认一次</span></span><br><span class="line"><span class="keyword">if</span>((i+<span class="number">1</span>)%batchSize==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//发布确认</span></span><br><span class="line">channel.waitForConfirms();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步发布确认"><a href="#异步发布确认" class="headerlink" title="异步发布确认"></a>异步发布确认</h3><p>异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都很好，利用了回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息确认回调的函数</span></span><br><span class="line"><span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag,multiple) -&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;确认的消息:&quot;</span>+deliveryTag);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1.消息的标记</span></span><br><span class="line"><span class="comment">    * 2.是否为批量确认</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//消息确认失败回调函数</span></span><br><span class="line">ConfirmCallback nackCallback= (deliveryTag,multiple) -&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未确认的消息:&quot;</span>+deliveryTag);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备消息的监听器 监听那些消息成功了，哪些消息失败了</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1.监听哪些消息成功了</span></span><br><span class="line"><span class="comment">    * 2.监听哪些消息失败了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">channel.addConfirmListener(ackCallback,nackCallback);<span class="comment">//异步通知</span></span><br></pre></td></tr></table></figure><p>实际案例里，将发布的消息存入 Map 里，方便获取。headMap 方法用于将已确认的消息存入新的 Map 缓存区里，然后清除该新缓存区的内容。因为 headMap 方法是浅拷贝，所以清除了缓存区，相当于清除了内容的地址，也就清除了队列的确认的消息。</p><h4 id="处理异步未确认消息"><a href="#处理异步未确认消息" class="headerlink" title="处理异步未确认消息"></a>处理异步未确认消息</h4><p>最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 线程安全有序的一个哈希表，适用于高并发的情况下</span></span><br><span class="line"><span class="comment">* 1.轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">* 2.轻松批量删除条目 只要给到序号</span></span><br><span class="line"><span class="comment">* 3.支持高并发(多线程)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ConcurrentSkipListMap&lt;Long,String&gt; outstandingConfirms=</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//消息确认回调的函数</span></span><br><span class="line"><span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag,multiple) -&gt;&#123;</span><br><span class="line"><span class="keyword">if</span>(multiple) &#123;</span><br><span class="line">    <span class="comment">//2.删除掉已经确认的消息 剩下的就是未确认的消息</span></span><br><span class="line">    ConcurrentNavigableMap&lt;Long, String&gt; confirmed =</span><br><span class="line">            outstandingConfirms.headMap(deliveryTag);</span><br><span class="line">    confirmed.clear();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    outstandingConfirms.remove(deliveryTag);</span><br><span class="line">&#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;确认的消息:&quot;</span> + deliveryTag);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ-交换机"><a href="#RabbitMQ-交换机" class="headerlink" title="RabbitMQ 交换机"></a>RabbitMQ 交换机</h2><p>RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>相反，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><h3 id="交换机的类型"><a href="#交换机的类型" class="headerlink" title="交换机的类型"></a>交换机的类型</h3><ul><li><p><strong>直接</strong>(direct)：处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 abc ，则只有被标记为 abc 的消息才被转发，不会转发 abc.def，也不会转发 dog.ghi，只会转发 abc。</p></li><li><p><strong>主题</strong>(topic)：将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号 * 匹配不多不少一个词。因此 abc.# 能够匹配到 abc.def.ghi，但是 abc.* 只会匹配到 abc.def。</p></li><li><p><strong>标题</strong>(headers)：不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到RabbitMQ 时会取到该消息的 headers 与 Exchange 绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 属性是一个键值对，可以是 Hashtable，键值对的值可以是任何类型。而 fanout，direct，topic 的路由键都需要要字符串形式的。</p><p>  匹配规则 x-match 有下列两种类型：</p><p>  x-match &#x3D; all ：表示所有的键值对都匹配才能接受到消息</p><p>  x-match &#x3D; any ：表示只要有键值对匹配就能接受到消息</p></li><li><p><strong>扇出</strong>(fanout)：不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout 交换机转发消息是最快的。</p></li><li><p>默认交换机   空字符串 表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey) 绑定指定的 key</p></li></ul><h3 id="绑定bindings"><a href="#绑定bindings" class="headerlink" title="绑定bindings"></a>绑定bindings</h3><p>什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定</p><h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p><p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p><h3 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h3><ul><li>消息ttl过期</li><li>队列达到最大长度</li><li>消息被拒绝</li></ul><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要在某个事件发生之后或者之前的指定时间点完成某一项任务</p><ul><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ul><h2 id="TTL的两种设置"><a href="#TTL的两种设置" class="headerlink" title="TTL的两种设置"></a>TTL的两种设置</h2><p>TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。</p><p>换句话说，如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为「死信」。如果同时配置了队列的 TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。</p><h3 id="队列设置TTL"><a href="#队列设置TTL" class="headerlink" title="队列设置TTL"></a>队列设置TTL</h3><p>在创建队列的时候设置队列的 x-message-ttl 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">params.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">5000</span>);</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;QA&quot;</span>).withArguments(args).build(); <span class="comment">// QA 队列的最大存活时间位 5000 毫秒</span></span><br></pre></td></tr></table></figure><h3 id="消息设置TTL"><a href="#消息设置TTL" class="headerlink" title="消息设置TTL"></a>消息设置TTL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.converAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XC&quot;</span>,message,correlationData -&gt; &#123;</span><br><span class="line">    correlationData.getMessageProperties().setExpiration(<span class="string">&quot;5000&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间，具体看下方案例。</p><p>另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis6</title>
      <link href="/2022/11/07/Redis6/"/>
      <url>/2022/11/07/Redis6/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。</p><p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。</p><p>Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。</p><span id="more"></span><h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>NoSQL(NoSQL &#x3D; Not Only SQL) 意为 “不仅仅只是SQL” 泛指非关系型的数据库 NoSQL不依赖业务逻辑方式存储 而以简单的key-value模式存储 因此大大增加了数据库的拓展能力</p><ul><li>不遵循SQL标准</li><li>不支持ACID(原子性 一致性 隔离性 持久性)</li><li>远超于SQL的性能</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>对数据高并发的读写</li><li>海量数据的读写</li><li>对数据高可扩展性的</li></ul><h2 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h2><ul><li>需要事务支持</li><li>基于sql的结构化查询存储  处理复杂的关系 需要即时查询</li><li><strong>用不着sql的和用了sql也不行的情况  可以考虑使用NoSql</strong></li></ul><h2 id="常见NoSQL"><a href="#常见NoSQL" class="headerlink" title="常见NoSQL"></a>常见NoSQL</h2><h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><ul><li>很早出现的NoSql数据库</li><li>数据都在内存中  一般不持久化</li><li>支持简单的key-value模式  支持类型单一(字符串)</li><li>一般是作为缓存数据库辅助持久化的数据库</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>几乎覆盖了Memcached的绝大部分功能</li><li>数据都在内存中  支持持久化  主要作备份恢复</li><li>除了支持简单的key-value 模式 还支持多种数据结构的存储  比如 list set hash  zset(有序集合)等</li><li>一般是作为缓存数据库辅助持久化的数据库</li></ul><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><ul><li>高性能 开源 模式自由(schema free)的文档型数据库</li><li>数据都在内存中 如果内存不足 把不常用的数据保存到硬盘</li><li>虽然是key-value 模式 但是对value(尤其是 json)提供了丰富的查询功能</li><li>支持二进制数据及大型对象</li><li>可以根据数据的特点替代 <a href="http://c.biancheng.net/sql/rdbms.html">RDBMS</a> 成为独立的数据库 或者配合<a href="http://c.biancheng.net/sql/rdbms.html">RDBMS</a> 存储特定的数据</li></ul><h1 id="Redis概念与安装"><a href="#Redis概念与安装" class="headerlink" title="Redis概念与安装"></a>Redis概念与安装</h1><ul><li>Redis 是一个开源的key-value存储系统</li><li>和Memcached类似 它支持存储value类型相对更多 包括string list set zset hash</li><li>这些数据类型都支持push&#x2F;pop  add&#x2F;remove 及取交集并集和差集及更丰富的操作  而且这些操作都是原子性的</li><li>在此基础上  Redis支持各种不同方式的排序</li><li>数据都是缓存在内存中</li><li>Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件</li><li>并在此基础上实现了master-slave(主从)同步</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>配合关系型数据库做高速缓存</li><li>高频次 热门访问的数据 降低数据库IO</li><li>分布式架构 做session共享</li></ul><p><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE.png">数据结构存储持久化数据</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p><strong>安装必须在linux环境下安装</strong></p></blockquote><ul><li><p>安装gcc环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc-c++   pcre pcre-devel zlib zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure></li><li><p>下载安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-6.2.1.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf redis-6.2.1.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>进入redis目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.1</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make </span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li></ul><p><strong>安装后的默认目录是&#x2F;usr&#x2F;local&#x2F;bin</strong></p><h3 id="安装目录结构"><a href="#安装目录结构" class="headerlink" title="安装目录结构"></a>安装目录结构</h3><ul><li>redis-benchmark 性能测试工具 可以在自己本地运行  看看自己电脑性能如何</li><li>redis-check-aof  修复有问题的AOF文件 </li><li>redis-check-dump 修复有问题的dump.rdb文件</li><li>redis-sentinel Redis集群使用</li><li>redis-server  Redis服务器启动命令</li><li>redis-cli 客户端  操作入口</li></ul><h2 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h2><ul><li>备份redis.conf<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /redis-x-x-x/redis.conf(文件路径) /etc/redis.conf(目标文件路径)</span><br></pre></td></tr></table></figure></li><li>使用vim将reids.conf 文件中的daemonize no 改为 yes  让服务在后台启动</li><li>启动<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure></li><li>客户端访问<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure></li><li>多个端口可以<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli-p6379</span><br></pre></td></tr></table></figure></li><li>测试验证 ping 显示PONG  表示链接成功</li><li>退出  exit</li></ul><h1 id="Redis-常用五大数据类型"><a href="#Redis-常用五大数据类型" class="headerlink" title="Redis 常用五大数据类型"></a>Redis 常用五大数据类型</h1><h2 id="Redis键-key"><a href="#Redis键-key" class="headerlink" title="Redis键(key)"></a>Redis键(key)</h2><ul><li>keys * 查看当前库所有key (匹配: keys *1)</li><li>exitsts key  判断某个key是否存在</li><li>type key 查看你的key是什么类型</li><li>del key  删除指定的key数据</li><li>unlink key  根据value选择非阻塞删除<blockquote><p>仅将keys从keyspace 元数据中删除 真正的删除会在后续异步操作</p></blockquote></li><li>expire key 10  为给定的key设置过期时间</li><li>ttl key  查看还有多少秒过期  -1 表示永不过期 -2 表示已过期</li></ul><p>select 命令切换数据库<br>dbsize 查看当前数据库的key的数量<br>flushdb 清空当前库<br>flushall 通杀全部库</p><h2 id="Redis-字符串-String"><a href="#Redis-字符串-String" class="headerlink" title="Redis 字符串(String)"></a>Redis 字符串(String)</h2><p>String 是Redis最基本的类型 一个key对应一个value 一个Redis中字符串value最多可以是512M</p><p>String类型是二进制安全的 意味着Redis的string可以包含任何数据 比如图片或者序列化对象等</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>NX: 当数据库中key不存在时  可以将key-value添加数据库</li><li>XX:当数据库中key存在时 可以将key-value添加数据库  与NX参数互斥</li><li>EX: key的超时秒数</li><li>PX：key的超时毫秒数 与EX互斥</li></ul><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>set &lt;key&gt;&lt;value&gt;</td><td>添加键值对</td></tr><tr><td>get &lt;key&gt;</td><td>查询对应键值</td></tr><tr><td>append &lt;key&gt;&lt;value&gt;</td><td>将给定的&lt;value&gt;追加到原值的末尾</td></tr><tr><td>strlen &lt;key&gt;</td><td>获取值的长度</td></tr><tr><td>setnx &lt;key&gt;&lt;value&gt;</td><td>只有在key不存在时 设置key的值</td></tr><tr><td>incr &lt;key&gt;</td><td>将key中储存的数字值增1  **只能对数字值使用 如果为空 新增</td></tr><tr><td>decr &lt;key&gt;</td><td>将key中存储的数字值减1  **只能对数字值操作 如果为空 新增</td></tr><tr><td>incrby&#x2F;decrby  &lt;key&gt;&lt;步长&gt;</td><td>将key中存储的数字值增减 自定义步长</td></tr><tr><td>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; ….</td><td>同时设置一个或多个</td></tr><tr><td>mget &lt;key1&gt;&lt;key2&gt;…</td><td>同时获取一个或多个value</td></tr><tr><td>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;</td><td>同时设置一个或多个</td></tr><tr><td>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</td><td>获得值的范围 类似java中</td></tr><tr><td>setrange &lt;key&gt;&lt;起始位置&gt; <value></value></td><td>覆写&lt;key&gt;所存储的字符串值 从起始位置开始</td></tr><tr><td>setex &lt;key&gt; &lt;过期时间&gt;<value></value></td><td>设置键值的同时 设置过期时间 单位秒</td></tr><tr><td>getset &lt;key&gt;&lt;value&gt;</td><td>设置了新值的同时获得旧值</td></tr></tbody></table><h2 id="Redis-列表"><a href="#Redis-列表" class="headerlink" title="Redis 列表"></a>Redis 列表</h2><p>单键多值<br>Redis 列表时简单的字符串列表 按照插入的顺序排序  你可以添加一个元素到列表的头部 或 尾部</p><p>它的底层实现是双向链表  对两端的操作性能很高  通过索引下标的操作中间的节点性能会较差</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>push&#x2F;rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;….</td><td>从左边&#x2F;右边插入一个或多个值</td></tr><tr><td>pop&#x2F;rpop &lt;key&gt;</td><td>从左边&#x2F;右边移除一个值  <strong>值在键在  值光键亡</strong></td></tr><tr><td>rpoplpush &lt;key1&gt;&lt;key2&gt;</td><td>从&lt;key1&gt;列表右边移出一个值插入到&lt;key2&gt;列表的左边</td></tr><tr><td>lrange &lt;key&gt;&lt;strat&gt;&lt;stop&gt;</td><td>按照索引下标获得元素(从左到右)</td></tr><tr><td>lrange mylist 0 -1</td><td>表示获取链表中的所有值</td></tr><tr><td>lindex &lt;key&gt;&lt;index&gt;</td><td>按照索引下标获得元素(从左到右)</td></tr><tr><td>llen &lt;key&gt;</td><td>获得列表长度</td></tr><tr><td>linsert &lt;key&gt; before &lt;value&gt;&lt;newvalue&gt;</td><td>在&lt;value&gt;的后面插入&lt;newvalue&gt;插入值</td></tr><tr><td>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</td><td>从左边删除n个value(从左到右)</td></tr><tr><td>lset &lt;key&gt;&lt;index&gt;&lt;value&gt;</td><td>将列表key下标为index的值替换成 value</td></tr></tbody></table><h2 id="Redis-集合-Set"><a href="#Redis-集合-Set" class="headerlink" title="Redis 集合(Set)"></a>Redis 集合(Set)</h2><p>Redis set对外提供的功能与list类似是一个列表的功能 特殊之处在于set是可以自动去重的 当你需要存储一个列表数据  又不希望出现重复数据时 set是一个很好的选择  并且set提供了判断某个成员是否在一个set集合内的重要接口  这个也是list没有的 </p><p>Redis 的 set 是 String 类型的无序集合 它底层是一个 value 为 null 的 hash 表 所以添加 删除  查找的复杂度都是O(1)</p><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; …</td><td>将一个或多个member 元素加入到集合key中 已经存在的 member 元素将被忽略</td></tr><tr><td>smembers &lt;key&gt;</td><td>取出该集合的所有值</td></tr><tr><td>sismember &lt;key&gt;&lt;value&gt;</td><td>判断集合 &lt;key&gt; 中是否含有该 &lt;value&gt;值 有 1 没有 0</td></tr><tr><td>scard &lt;key&gt;</td><td>返回该集合的元素个数</td></tr><tr><td>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; …</td><td>删除集合中的某个元素</td></tr><tr><td>spop &lt;key&gt;</td><td>随机从该集合中移出一个值</td></tr><tr><td>srandmemeber &lt;key&gt;&lt;n&gt;</td><td>随机从该集合中取出n个值  不会从集合中删除</td></tr><tr><td>smove &lt;source&gt;&lt;destination&gt; &lt;value&gt;</td><td>把集合中一个值从一个集合移动到另一个集合</td></tr><tr><td>sinter &lt;key1&gt;&lt;key2&gt;</td><td>返回两个集合中的交集元素</td></tr><tr><td>sunion &lt;key1&gt;&lt;key2&gt;</td><td>返回两个集合的并集元素</td></tr><tr><td>sdiff &lt;key1&gt;&lt;keye2&gt;</td><td>返回两个集合的差集元素(key1中的 不包含key2中的)</td></tr></tbody></table><h2 id="Redis-哈希-Hash"><a href="#Redis-哈希-Hash" class="headerlink" title="Redis 哈希(Hash)"></a>Redis 哈希(Hash)</h2><p>Redis hash 是一个键值对集合<br>Redis hash 是一个string类型的field和value的映射表 hash 特别适合用于存储对象 类似java中的Map&lt;String,Object&gt;</p><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>hset &lt;key&gt;&lt;field&gt;<value></value></td><td>给&lt;key&gt;集合中的 &lt;filed&gt; 键赋值&lt;value&gt;</td></tr><tr><td>hget&lt;key1&gt;&lt;field&gt;</td><td>从&lt;key1&gt;集合&lt;field&gt; 取出value</td></tr><tr><td>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;…</td><td>批量设置hash的值</td></tr><tr><td>hexists &lt;key1&gt;&lt;field&gt;</td><td>查看哈希表key 中 给定域field 是否存在</td></tr><tr><td>hkeys &lt;key&gt;</td><td>列出该hash集合的所有field</td></tr><tr><td>hvaks &lt;key&gt;</td><td>列出该hash集合的所有value</td></tr><tr><td>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</td><td>为哈希表key中域field的值加上增量 1 -1</td></tr><tr><td>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</td><td>将哈希表key中的域field的值设置为value 当且仅当域field不存在</td></tr></tbody></table><h2 id="Redis-有序集合Zset-sorted-set"><a href="#Redis-有序集合Zset-sorted-set" class="headerlink" title="Redis 有序集合Zset(sorted set)"></a>Redis 有序集合Zset(sorted set)</h2><p>Redis 有序集合zset 和 普通集合set非常相似 是一个没有重复元素的字符串集合<br>不同之处是有序集合的每个成员都关联了一个评分(score) 这个评分被用来按照从最低分到最高分的方式排序集合中的成员 集合的成员是唯一的 但是评分可以重复</p><p>因为元素是有序的  所以你也可以很快的根据评分 或者次序来获取一个范围的元素</p><p>访问有序集合的中间元素也是非常快的  因此你能够使用有序集合作为一个没有重复成员的智能列表</p><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;</td><td>将一个或多个member元素及其score值加入到有序集合key中</td></tr><tr><td>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]</td><td>返回有序集合key中 下标在start stop 之间的元素 带WITHSCORES 可以让分数一起和值返回到结果集</td></tr><tr><td>zrangebyscore key minmax [withscores][limit offset count]</td><td>返回有序集key中 所有score值介于min 和 max 之间(包括等于min 或 max)的成员 有序集合成员按照score值递增次序排列</td></tr><tr><td>zrevrangebyscore key maxmin [withsscore] [limit offset count]</td><td>同上 改为从大到小</td></tr><tr><td>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</td><td>为元素的score加上增量</td></tr><tr><td>zrem &lt;key&gt;&lt;value&gt;</td><td>删除该集合下 指定值的元素</td></tr><tr><td>zcount &lt;key&gt;&lt;min&gt;&gt;<max></max></td><td>统计该集合 分数区间内的元素个数</td></tr><tr><td>zrank &lt;key&gt;&lt;value&gt;</td><td>返回该值在集合中的排名 从0开始</td></tr></tbody></table><h1 id="Redis-新数据类型"><a href="#Redis-新数据类型" class="headerlink" title="Redis 新数据类型"></a>Redis 新数据类型</h1><h2 id="Redis-Bitmaps"><a href="#Redis-Bitmaps" class="headerlink" title="Redis Bitmaps"></a>Redis Bitmaps</h2><p>Redis 提供了Bitmaps这个”数据类型” 可以实现对位的操作</p><ul><li>Bitmaps 本身不是一种数据类型 实际上它就是字符串 但是它可以对字符串的位进行操作</li><li>Bitmaps 单独提供了一套命令 所以在Redis中使用Bitmaps和使用字符串的方法不太相同 可以把Bitmaps想象成一个以位为单位的数组 数组的每个单元只能存储0 或 1 数组的下标在Bitmaps中叫做偏移量</li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>setbit &lt;key&gt;&lt;offset&gt;&lt;value&gt;</td><td>设置Bitmaps中某个偏移量的值</td></tr><tr><td>getbit &lt;key&gt;&lt;offset&gt;</td><td>获取Bitmaps中某个偏移量的值</td></tr><tr><td>bitcount &lt;key&gt;[start end]</td><td>统计字符串从start字节到end字节比特值为1的数量</td></tr><tr><td>bitop and(or&#x2F;not&#x2F;xor) &lt;destkey&gt; [key…]</td><td>bitop是一个复合操作 它可以做多个Bitmaps的and or xor 操作并将结果保存在destkey中</td></tr></tbody></table><h2 id="Redis-HyperLogLog"><a href="#Redis-HyperLogLog" class="headerlink" title="Redis HyperLogLog"></a>Redis HyperLogLog</h2><p>Redis HyperLogLog 是用来做基数统计的算法 HyperLogLog 键只需要花费12KB内存 就可以计算接近2^64个不同元素的基数 这和计算基数时 元素越多耗费内存就越多的集合形成鲜明对比<br>但是 因为HyperLogLog只会根据输入元素来计算基数 而不会存储输入元素本身 所以HyperLogLog 不能像集合那样  返回输入的各个元素</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>pfadd &lt;key&gt;&lt;element&gt; [element….]</td><td>添加指定元素到HyperLogLog中</td></tr><tr><td>pfcount &lt;key&gt; [key…]</td><td>计算出HLL的近似基数  可以计算多个HLL 比如用HLL存储每天的UV(Unique visitor 指通过互联网访问、浏览这个网页的自然人) 计算一周的UV可以使用七天的UV合并计算即可</td></tr><tr><td>pfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey…]</td><td>将与1个或多个HLL合并后的结果存储在另一个HLL中 比如每月活跃用户可以使用每天的活跃用户来合并计算可得</td></tr></tbody></table><h2 id="Redis-GEO-Geographic"><a href="#Redis-GEO-Geographic" class="headerlink" title="Redis GEO(Geographic)"></a>Redis GEO(Geographic)</h2><p>该类型就是元素的2维坐标 在地图上就是经纬度  redis基于该类型 提供了经纬度设置 查询 范围查询 距离查询 经纬度Hash等常见操作</p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>geoadd &lt;key&gt;&lt;longitude&gt;&lt;latitude&gt;&lt;member&gt; [longitude latitude member…]</td><td>添加地理位置(  经度 维度  名称)</td></tr><tr><td>geopos &lt;key&gt;&lt;member&gt; [member…]</td><td>获得指定地区的坐标值</td></tr><tr><td>geodist &lt;key&gt;&lt;member1&gt;&lt;member2&gt; [m 米</td><td>km 千米</td></tr><tr><td>georadius &lt;key&gt; &lt;longitude&gt;&lt;latitude&gt; radius m</td><td>km</td></tr></tbody></table><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><h2 id="IDEA-链接Redis"><a href="#IDEA-链接Redis" class="headerlink" title="IDEA 链接Redis"></a>IDEA 链接Redis</h2><ul><li>创建工程</li><li>导入Jedis坐标</li><li>对redis配置文件进行修改<ul><li>注释掉第69行的 bind 127.0.0.1</li><li>将 protected-mode 设置为no</li><li>将 daemonize 设置yes</li></ul></li><li>开放端口6379 或者关闭防火墙</li></ul><h2 id="Jedis-字符串操作"><a href="#Jedis-字符串操作" class="headerlink" title="Jedis 字符串操作"></a>Jedis 字符串操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">&quot;===========增加数据===========&quot;</span>);</span><br><span class="line">    System.out.println(jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>));</span><br><span class="line">    System.out.println(jedis.set(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>));</span><br><span class="line">    System.out.println(jedis.set(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除键key2:&quot;</span> + jedis.del(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取键key2:&quot;</span> + jedis.get(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改key1:&quot;</span> + jedis.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取key1的值：&quot;</span> + jedis.get(<span class="string">&quot;key1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;在key3后面加入值：&quot;</span> + jedis.append(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;End&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;key3的值：&quot;</span> + jedis.get(<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;增加多个键值对：&quot;</span> + jedis.mset(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;value01&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;value02&quot;</span>, <span class="string">&quot;key03&quot;</span>, <span class="string">&quot;value03&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;key03&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;key03&quot;</span>, <span class="string">&quot;key04&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除多个键值对：&quot;</span> + jedis.del(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;key02&quot;</span>&#125;));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span> + jedis.mget(<span class="string">&quot;key01&quot;</span>, <span class="string">&quot;key02&quot;</span>, <span class="string">&quot;key03&quot;</span>));</span><br><span class="line"></span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">&quot;===========新增键值对,防止覆盖原先值==============&quot;</span>);</span><br><span class="line">    System.out.println(jedis.setnx(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>));</span><br><span class="line">    System.out.println(jedis.setnx(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>));</span><br><span class="line">    System.out.println(jedis.setnx(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2-new&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;key1&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;===========新增键值对并设置有效时间=============&quot;</span>);</span><br><span class="line">    System.out.println(jedis.setex(<span class="string">&quot;key3&quot;</span>, <span class="number">2</span>, <span class="string">&quot;value3&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;key3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;===========获取原值，更新为新值==========&quot;</span>);<span class="comment">//GETSET is an atomic set this value and return the old value command.</span></span><br><span class="line">    System.out.println(jedis.getSet(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;key2GetSet&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;key2&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;获得key2的值的字串：&quot;</span> + jedis.getrange(<span class="string">&quot;key2&quot;</span>, <span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jedis-Hash操作"><a href="#Jedis-Hash操作" class="headerlink" title="Jedis Hash操作"></a>Jedis Hash操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis操作Hash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key4&quot;</span>, <span class="string">&quot;value4&quot;</span>);</span><br><span class="line">    jedis.hmset(<span class="string">&quot;hash&quot;</span>, map);</span><br><span class="line">    jedis.hset(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key5&quot;</span>, <span class="string">&quot;value5&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return Map&lt;String,String&gt;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键为：&quot;</span> + jedis.hkeys(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return Set&lt;String&gt;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有值为：&quot;</span> + jedis.hvals(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return List&lt;String&gt;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span> + jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">6</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span> + jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除一个或者多个键值对：&quot;</span> + jedis.hdel(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span> + jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;散列hash中键值对的个数：&quot;</span> + jedis.hlen(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;判断hash中是否存在key2：&quot;</span> + jedis.hexists(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;判断hash中是否存在key3：&quot;</span> + jedis.hexists(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取hash中的值：&quot;</span> + jedis.hmget(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取hash中的值：&quot;</span> + jedis.hmget(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key3&quot;</span>, <span class="string">&quot;key4&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jedis-列表操作"><a href="#Jedis-列表操作" class="headerlink" title="Jedis 列表操作"></a>Jedis 列表操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">&quot;===========添加一个list===========&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;lists&quot;</span>, <span class="string">&quot;ArrayList&quot;</span>, <span class="string">&quot;Vector&quot;</span>, <span class="string">&quot;Stack&quot;</span>, <span class="string">&quot;HashMap&quot;</span>, <span class="string">&quot;WeakHashMap&quot;</span>, <span class="string">&quot;LinkedHashMap&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;lists&quot;</span>, <span class="string">&quot;HashSet&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;lists&quot;</span>, <span class="string">&quot;TreeSet&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;lists&quot;</span>, <span class="string">&quot;TreeMap&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));<span class="comment">//-1代表倒数第一个元素，-2代表倒数第二个元素</span></span><br><span class="line">    System.out.println(<span class="string">&quot;lists区间0-3的元素：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    <span class="comment">// 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈</span></span><br><span class="line">    System.out.println(<span class="string">&quot;删除指定元素个数：&quot;</span> + jedis.lrem(<span class="string">&quot;lists&quot;</span>, <span class="number">2</span>, <span class="string">&quot;HashMap&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除下表0-3区间之外的元素：&quot;</span> + jedis.ltrim(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists列表出栈（左端）：&quot;</span> + jedis.lpop(<span class="string">&quot;lists&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists添加元素，从列表右端，与lpush相对应：&quot;</span> + jedis.rpush(<span class="string">&quot;lists&quot;</span>, <span class="string">&quot;EnumMap&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists列表出栈（右端）：&quot;</span> + jedis.rpop(<span class="string">&quot;lists&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改lists指定下标1的内容：&quot;</span> + jedis.lset(<span class="string">&quot;lists&quot;</span>, <span class="number">1</span>, <span class="string">&quot;LinkedArrayList&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的内容：&quot;</span> + jedis.lrange(<span class="string">&quot;lists&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;lists的长度：&quot;</span> + jedis.llen(<span class="string">&quot;lists&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;获取lists下标为2的元素：&quot;</span> + jedis.lindex(<span class="string">&quot;lists&quot;</span>, <span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    jedis.lpush(<span class="string">&quot;sortedList&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;sortedList排序前：&quot;</span> + jedis.lrange(<span class="string">&quot;sortedList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(jedis.sort(<span class="string">&quot;sortedList&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;sortedList排序后：&quot;</span> + jedis.lrange(<span class="string">&quot;sortedList&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jedis-集合操作"><a href="#Jedis-集合操作" class="headerlink" title="Jedis 集合操作"></a>Jedis 集合操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    System.out.println(<span class="string">&quot;============向集合中添加元素============&quot;</span>);</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e4&quot;</span>, <span class="string">&quot;e3&quot;</span>, <span class="string">&quot;e0&quot;</span>, <span class="string">&quot;e8&quot;</span>, <span class="string">&quot;e7&quot;</span>, <span class="string">&quot;e5&quot;</span>));</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e6&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除一个元素e0：&quot;</span> + jedis.srem(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e0&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除两个元素e7和e6：&quot;</span> + jedis.srem(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e7&quot;</span>, <span class="string">&quot;e6&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;随机的移除集合中的一个元素：&quot;</span> + jedis.spop(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet的所有元素为：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet中包含元素的个数：&quot;</span> + jedis.scard(<span class="string">&quot;eleSet&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;e1是否在eleSet中：&quot;</span> + jedis.sismember(<span class="string">&quot;eleSet&quot;</span>, <span class="string">&quot;e1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;=================================&quot;</span>);</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e4&quot;</span>, <span class="string">&quot;e3&quot;</span>, <span class="string">&quot;e0&quot;</span>, <span class="string">&quot;e8&quot;</span>, <span class="string">&quot;e7&quot;</span>, <span class="string">&quot;e5&quot;</span>));</span><br><span class="line">    System.out.println(jedis.sadd(<span class="string">&quot;eleSet2&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e4&quot;</span>, <span class="string">&quot;e3&quot;</span>, <span class="string">&quot;e0&quot;</span>, <span class="string">&quot;e8&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;将eleSet1中删除e1并存入eleSet3中：&quot;</span> + jedis.smove(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet3&quot;</span>, <span class="string">&quot;e1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1中的元素：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet3中的元素：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;============集合运算=================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1中的元素：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet1&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet2中的元素：&quot;</span> + jedis.smembers(<span class="string">&quot;eleSet2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1和eleSet2的交集:&quot;</span> + jedis.sinter(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1和eleSet2的并集:&quot;</span> + jedis.sunion(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;eleSet1和eleSet2的差集:&quot;</span> + jedis.sdiff(<span class="string">&quot;eleSet1&quot;</span>, <span class="string">&quot;eleSet2&quot;</span>));<span class="comment">//eleSet1中有，eleSet2中没有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Jedis-有序集合操作"><a href="#Jedis-有序集合操作" class="headerlink" title="Jedis 有序集合操作"></a>Jedis 有序集合操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSortedSet</span><span class="params">()</span>&#123;</span><br><span class="line">    jedis.flushDB();</span><br><span class="line">    Map&lt;String,Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;key2&quot;</span>,<span class="number">1.5</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key3&quot;</span>,<span class="number">1.6</span>);</span><br><span class="line">    map.put(<span class="string">&quot;key4&quot;</span>,<span class="number">1.9</span>);</span><br><span class="line">    System.out.println(jedis.zadd(<span class="string">&quot;zset&quot;</span>, <span class="number">3</span>,<span class="string">&quot;key1&quot;</span>));</span><br><span class="line">    System.out.println(jedis.zadd(<span class="string">&quot;zset&quot;</span>,map));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中的所有元素：&quot;</span>+jedis.zrangeByScore(<span class="string">&quot;zset&quot;</span>, <span class="number">0</span>,<span class="number">100</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中key2的分值：&quot;</span>+jedis.zscore(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中key2的排名：&quot;</span>+jedis.zrank(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除zset中的元素key3：&quot;</span>+jedis.zrem(<span class="string">&quot;zset&quot;</span>, <span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中的所有元素：&quot;</span>+jedis.zrange(<span class="string">&quot;zset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中元素的个数：&quot;</span>+jedis.zcard(<span class="string">&quot;zset&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中分值在1-4之间的元素的个数：&quot;</span>+jedis.zcount(<span class="string">&quot;zset&quot;</span>, <span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;key2的分值加上5：&quot;</span>+jedis.zincrby(<span class="string">&quot;zset&quot;</span>, <span class="number">5</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;key3的分值加上4：&quot;</span>+jedis.zincrby(<span class="string">&quot;zset&quot;</span>, <span class="number">4</span>, <span class="string">&quot;key3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;zset中的所有元素：&quot;</span>+jedis.zrange(<span class="string">&quot;zset&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redis-事务-锁机制"><a href="#Redis-事务-锁机制" class="headerlink" title="Redis 事务 锁机制"></a>Redis 事务 锁机制</h1><p>Redis  事务时一个单独的隔离操作  事务中的所有命令都会序列化 按顺序的执行  事务在执行的过程中  不会被其他客户端发送来的命令请求所打断<br>Redis事务的主要作用就是串联多个命令防止其他命令插队</p><h2 id="Multi-Exec-discard"><a href="#Multi-Exec-discard" class="headerlink" title="Multi Exec  discard"></a>Multi Exec  discard</h2><p>从输入Multi命令开始  输入的命令都会依次进入命令队列中  但不会执行  知道输入Exec后 Redis会将之前的命令队列中的命令依次执行<br>组队的过程中可以通过discard来放弃组队</p><ul><li>在组队中某个命令出现了错误  执行时整个的所有队列都会被取消</li><li>在执行阶段某个命令出现了错误  则只有报错的命令不会被执行 而其他的命令都会被执行</li></ul><h2 id="WATCH-UNWATCH"><a href="#WATCH-UNWATCH" class="headerlink" title="WATCH  UNWATCH"></a>WATCH  UNWATCH</h2><ul><li><p>在执行multi之前 先执行watch key1 [key2] 可以监视一个或者多个key  如果在事务执行之前这些key被其他命令所改动  那么事务将会被打断</p></li><li><p>unwatch 取消watch命令对所有key的监视</p></li><li><p>如果在执行watch命令之后 exec命令或discard命令先被执行了的话 那么就不需要在执行unwatch了</p></li></ul><h2 id="Redis-事务三特性"><a href="#Redis-事务三特性" class="headerlink" title="Redis 事务三特性"></a>Redis 事务三特性</h2><ul><li>单独隔离操作<ul><li>事务中的所有命令都会被序列化 按顺序的执行  事务在执行的过程中  不会被其他客户端发送来的命令请求所打断</li></ul></li><li>没有隔离级别的概念<ul><li>队列中的命令没有提交之前都不会实际被执行  因为事务提交前任何指令都不会被实际执行</li></ul></li><li>不保证原子性<ul><li>事务中如果有一条命令执行失败 其后的命令仍然会被执行  没有回滚</li></ul></li></ul><h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><h2 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB (Redis DataBase)"></a>RDB (Redis DataBase)</h2><p>在指定的时间间隔内将内存中的数据集快照写入磁盘  恢复时将快照文件直接读到内存里</p><h3 id="备份执行"><a href="#备份执行" class="headerlink" title="备份执行"></a>备份执行</h3><p>Redis 会单独创建(fork)一个子进程来进行持久化  会先将数据写入到一个临时文件中 待持久化过程都结束了  再用这个临时文件替换上次持久化好的文件<br>整个过程中  主进程时不进行任何IO操作的  这就确保了极高的性能  如果需要大规模数据的恢复  且对数据恢复的完整性不是非常敏感  那RDB方式要比AOF方式更加的高效<br>RDB的缺点是最后一次持久化后的数据可能会丢失</p><h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><ul><li>fork的作用是复制一个与当前进程一样的进程  新的进程的所有数据(变量 环境变量  程序计数器等)数值都和原进程一致  但是是一个全新的进程  并作为原进程的子进程</li><li>在Linux程序中 fork会产生一个和父进程完全相同的子进程 但子进程在此后多会exec系统调用 出于效率考虑  Linux中引入了<a href="https://cloud.tencent.com/developer/article/1914919">写时复制技术</a></li><li>一般情况父进程和子进程会共用同一段物理内存  只有进程空间的各段的内容要发生变化时  才会将父进程的内容复制一份给子进程</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>Fork的时候 内存中的数据被克隆了一份 大致2倍的膨胀性要考虑</li><li>虽然Redis在fork时使用了写时拷贝技术  但是如果数据庞大的时候还是比较消耗性能</li><li>在备份周期在一定间隔时间做一次备份 所以如果Redis意外down掉的话 就会丢失最后一次快照后的所有修改</li></ul><h2 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF (Append Only File)"></a>AOF (Append Only File)</h2><p>以日志的形式来记录每个写操作(增量保存) 将Redis执行过的所有写指令记录下来 只许追加文件但不可以改写文件 redis启动之初会读取该文件重新构建数据 换言之 redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><ul><li>AOF 默认不开启  在配置文件中开启</li><li>AOF 和 RDB 同时开启 系统默认读取AOF的数据(数据不会存在丢失)</li></ul><h3 id="AOF-同步频率设置"><a href="#AOF-同步频率设置" class="headerlink" title="AOF 同步频率设置"></a>AOF 同步频率设置</h3><ul><li>appendfsync always  始终同步 每次redis的写入都会立刻记入日志  性能较差但数据完整性比较好</li><li>appendfsync everysec 每秒同步 每秒记入日志一次 如果宕机 本秒的数据可能丢失</li><li>appendfsync no redis不主动进行同步  把同步时机交给操作系统</li></ul><h3 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h3><p>AOF 采用文件追加方式 文件越来越大为避免出现此种情况 新增了重写机制 当AOF文件的大小操作所设置的阈值时 Redis就会启动AOF文件的内容压缩 只保留可以恢复数据的最小指令集 可以使用命令 <strong>bgrewriteaof</strong></p><p>AOF文件持续增长而过大时  会fork出一条新进程来讲文件重写(先写临时文件最后在rename) redis4.0 版本后的重写 是指把rdb的快照 以二进制的形式附在新的aof头部 作为已有的历史数据  替换掉原来的流水账操作</p><h3 id="AOF-持久化流程"><a href="#AOF-持久化流程" class="headerlink" title="AOF 持久化流程"></a>AOF 持久化流程</h3><ul><li>客户端的请求写命令会被append追加到AOF缓冲区内</li><li>AOF缓冲区根据AOF持久化策略将操作sync同步到磁盘的AOF文件中</li><li>AOF文件大小超过重写策略或手动重写时 会对AOF文件rewrite重写 压缩AOF文件容量</li></ul><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ul><li>备份机制更稳健  丢失数据概率更低</li><li>可读的日志文本 通过操作AOF文件 可以处理误操作</li></ul><h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><ul><li>比起RDB占用更多的磁盘空间</li><li>恢复备份速度要慢</li><li>每次读写都同步的花  有一定的性能压力</li><li>存在个别bug  造成恢复不能</li></ul><h1 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h1><p>主机数据更新后根据配置和策略  自动同步到备机的(master&#x2F;slaver)机制 Master以写为主  Slave以读为主</p><ul><li>读写分离</li><li>容灾快速恢复  一台从服务器寄了之后可以从其他从服务器读取数据</li><li>info replication  打印主从服务器的信息</li><li>slave of &lt;ip&gt;&lt;port&gt;  成为某个实例的从服务器</li><li>slave of no one 取消从服务器</li><li>masterauth 密码  在配置文件中设置主服务器中的密码</li><li>从服务器挂了之后重启会从头开始复制主服务器中的数据 命令行只能设置一次性的主从关系  持久的主从关系要从配置文件中设置</li></ul><h2 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h2><ul><li>当从服务器连接上主服务器之后 从服务器向主服务器发送进行数据同步信息</li><li>主服务器收到从服务器发送过来的同步信息  把主服务器数据进行持久化rdb文件 把rdb文件发送给从服务器 从服务器拿到rdb文件之后进行读取</li><li>每次主服务器进行写操作之后 和从服务器进行数据同步</li></ul><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>能够后台监控主机是否故障  如果故障了根据投票数自动将从服务器转换为主服务器  哨兵继续监测新主机  原来主机哪怕重启也只能当新主机的从服务器</p><ul><li><p>新建sentinel.conf文件 写入 </p><blockquote><p>sentinel monitor mymaster ip  1</p></blockquote><ul><li>1 表示至少有多少个哨兵同意迁移的数量</li></ul></li><li><p>启动哨兵  </p><blockquote><p>redis-sentinel 哨兵配置文件的位置</p></blockquote></li><li><p>主机选择原则</p><ul><li>选择优先级靠前的     优先级在redis.conf中设置 默认为100</li><li>选择偏移量最大的      偏移量是指获得原主机数据最全的</li><li>选择runid最小的     每个redis实例启动后都会随机生成一个40位的runid</li></ul></li></ul><h1 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h1><p>Redis 集群实现了对Redis的水平扩容  即启动N个Redis节点  将整个数据库分布存储在这N个节点中  每个节点存储总数据的1&#x2F;N</p><p>Redis集群通过分区(partition)来提供一定程度的可用性(availability):即使集群中有一部分节点失效或这无法进行通讯  集群也可以继续处理命令请求</p><h2 id="redis-cluster配置修改"><a href="#redis-cluster配置修改" class="headerlink" title="redis cluster配置修改"></a>redis cluster配置修改</h2><ul><li>cluster-enabled yes 打开集群模式</li><li>cluster-config-file nodes-6379.conf 设定节点配置文件名</li><li>cluster-node-timeout 15000 设置节点失联时间  超过该时间(毫秒)，集群自动进行主从切换</li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>该部分由虚拟机模拟集群 正常情况在不同的服务器中的redis中设置这几个属性即可</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> /home/bigdata/redis.<span class="keyword">conf</span>  正常的redis配置文件</span><br><span class="line">------需要添加的部分--------------</span><br><span class="line">pidfile <span class="string">&quot;var/run/redis_6379.pid&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump6379.rdb&quot;</span></span><br><span class="line"><span class="keyword">dir</span> <span class="string">&quot;/home/bigdata/redis_cluster&quot;</span></span><br><span class="line">logfile <span class="string">&quot;/home/bigdata/redis_cluster/redis_err_6379.log&quot;</span></span><br><span class="line"><span class="keyword">cluster</span>-enabled yes</span><br><span class="line"><span class="keyword">cluster</span>-config-<span class="keyword">file</span> nodes-6379.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">cluster</span>-node-timeout 15000</span><br></pre></td></tr></table></figure><h2 id="构建集群"><a href="#构建集群" class="headerlink" title="构建集群"></a>构建集群</h2><ul><li>先进入redis的src命令</li><li>使用redis-cli –cluster create –cluster-replicas  1(表示从机数量) &lt;iplist&gt; 将redis的ip加端口加上创建集群</li><li>使用redis -c -p 进行集群策略连接  设置数据会自动切换到相应的写主机</li><li>使用cluster nodes 命令查看集群信息</li></ul><h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a>slots</h2><ul><li>一个Redis集群包含16384个插槽(hash slot),数据库中的每个键都属于这16384个插槽的其中一个</li><li>集群使用公式<a href="https://zhuanlan.zhihu.com/p/61636624">CRC16</a>(key) % 16384 来计算键key属于哪个槽  其中CRC16(key)语句用于计算键key的CRC16校验和</li><li>集群中的每个节点负责处理一部分插槽</li><li>cluster keyslot &lt;key&gt;  计算某个键的插槽值</li><li>cluster countkeysinslot 插槽值  查看某个插槽中值</li><li>cluster getkeysinslot 插槽值  返回某个插槽中的键</li></ul><h1 id="Redis-应用问题解决"><a href="#Redis-应用问题解决" class="headerlink" title="Redis 应用问题解决"></a>Redis 应用问题解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>key对应的数据在数据源并不存在  每次针对此key的请求从缓存获取不到  请求都会压到数据源  从而压垮数据源 比如用一个不存在的用户id获取用户信息 不论缓存还是数据库都没<br>有 若黑客利用此漏洞进行攻击可能压垮数据库</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>对空值进行缓存 <blockquote><p>如果一个查询返回的数据为空(不管数据是否真实存在) 我们仍然把这个空结果进行缓存  设置空结果的过期时间会很短  最长不会超过五分钟</p></blockquote></li><li>设置可访问名单<blockquote><p>使用bitmaps类型定义一个可以访问的名单 名单id作为bitmaps的偏移量 每次访问和bitmap里面的id进行比较  如果访问id不在bitmaps里面 进行拦截 不允许访问</p></blockquote></li><li>采用布隆过滤器 (Bloom Filter) 实际上是一个很长的二进制向量(位图)和一系列随机映射函数(哈希函数)<blockquote><p>布隆过滤器可以用于检索一个元素是否在一个集合中 它的有点是空间效率和查询时间都远远超过一般的算法 缺点是有一定的误识别率和删除困难将所有可能存在的数据哈希到一个足够大的bitmaps中 一个一定不存在的数据会被bitmaps拦截掉 从而避免了对底层存储系统的查询压力</p></blockquote></li><li>进行实时监控<blockquote><p>当发现Redis的命中率开始急速降低  需要排查访问对象和访问的数据  和运维人员配合 可以设置黑名单限制服务</p></blockquote></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>key对应的数据存在  但在redis中过期  此时若有大量并发请求过来  这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存  这个时候大并发的请求可能会瞬间把后端DB压垮</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>预先设置热门数据<blockquote><p>在redis高峰访问前 把一些热门数据提前存入到redis里面  加大这些热门数据key的时长</p></blockquote></li><li>实时调整  现场监控哪些数据热门 实时调整key的过期时长</li><li>使用锁<ul><li>在缓存失效的时候(判断拿出来的值为空) 不是立即去load db</li><li>先使用缓存工具的某些带成功操作返回值的操作(比如Redis的SETNX)</li></ul></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>key对应的数据存在  但在redis中过期  此时若有大量并发请求过来  这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存  这个时候大并发的请求可能会瞬间把后端DB压垮<br><br>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存 前者则是某一个key正常访问</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>构建多级缓存架构 nginx缓存+redis缓存+其他缓存</li><li>使用锁或者队列<blockquote><p>用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写  从而避免失效时大量的并发请求落到底层存储系统上  不适用高并发情况</p></blockquote></li><li>设置过期标志更新缓存<blockquote><p>记录缓存数据是否过期(设置提前量) 如果过期会触发通知另外的线程在后台去更新实际key的缓存</p></blockquote></li><li>将缓存失效时间分散开<blockquote><p>可以在原有的失效时间基础上增加一个随机值  比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低 就很难引发集体失效事件</p></blockquote></li></ul><h1 id="SpringBoot-整合-Redis"><a href="#SpringBoot-整合-Redis" class="headerlink" title="SpringBoot 整合 Redis"></a>SpringBoot 整合 Redis</h1><p>Redis配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span>      <span class="comment">// 开启缓存</span></span><br><span class="line"><span class="meta">@Configuration</span>      <span class="comment">// 配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置redistemplate相关配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 配置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jacksonSeial</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span></span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jacksonSeial.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 值采用json序列化</span></span><br><span class="line">        template.setValueSerializer(jacksonSeial);</span><br><span class="line">        <span class="comment">//使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置hash key 和value序列化模式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(jacksonSeial);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择redis作为默认缓存工具</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对hash类型的数据操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HashOperations&lt;String,String,Object&gt; <span class="title function_">hashOperations</span><span class="params">(RedisTemplate&lt;String,Object&gt; redisTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对redis字符串类型数据库操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ValueOperations&lt;String, Object&gt; <span class="title function_">valueOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对链表类型的数据操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ListOperations&lt;String, Object&gt; <span class="title function_">listOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对无序集合Set操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SetOperations&lt;String, Object&gt; <span class="title function_">setOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对有序集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ZSetOperations&lt;String, Object&gt; <span class="title function_">zSetOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf</title>
      <link href="/2022/11/05/Thymeleaf/"/>
      <url>/2022/11/05/Thymeleaf/</url>
      
        <content type="html"><![CDATA[<h1 id="Thymeleaf-模板引擎"><a href="#Thymeleaf-模板引擎" class="headerlink" title="Thymeleaf 模板引擎"></a>Thymeleaf 模板引擎</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Thymeleaf： 是使用java开发的模板技术， 在服务器端运行。 把处理后的数据发送给浏览器。</p><p>​         模板是作视图层工作的。  显示数据的。  Thymeleaf是基于Html语言。 Thymleaf语法是应用在</p><p>​        html标签中 。 SpringBoot框架集成Thymealeaf,  使用Thymeleaf代替jsp。</p><p>Thymeleaf 的官方网站：<a href="http://www.thymeleaf.org/">http://www.thymeleaf.org</a><br>Thymeleaf 官方手册：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html</a></p><span id="more"></span><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><ol><li><p>标准变量表达式 </p><p>语法：  ${key} </p><p>作用： 获取key对于的文本数据，  key 是request作用域中的key ， 使用request.setAttribute(), model.addAttribute()</p><p>在页面中的 html标签中， 使用 th:text&#x3D;”${key}”</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>标准变量表达式:  $&#123;key&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;site&#125;&quot;</span>&gt;</span>key不存在<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>获取SysUser对象 属性值<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;myuser.id&#125;&quot;</span>&gt;</span>id<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;myuser.name&#125;&quot;</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;myuser.sex&#125;&quot;</span>&gt;</span>姓名：m男<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;myuser.age&#125;&quot;</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;myuser.getName()&#125;&quot;</span>&gt;</span>获取姓名使用getXXX<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>选择变量表达式（ 星号变量表达式）</p><p>语法：  *{key}</p><p>作用： 获取这个key对应的数据，   *{key}需要和th:object 这个属性一起使用。</p><p>目的是简单获取对象的属性值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>使用 *&#123;&#125; 获取SysUser的属性值<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;myuser&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;sex&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;age&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>使用*&#123;&#125;完成的表示 对象的属性值<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;myuser.name&#125;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>链接表达式</p><p>语法： @{url}</p><p>作用： 表示链接， 可以</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"> , <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;...&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;..&quot;</span>&gt;</span> ,<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;...&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Thymeleaf属性"><a href="#Thymeleaf属性" class="headerlink" title="Thymeleaf属性"></a>Thymeleaf属性</h2><p>属性是放在html元素中的，就是html元素的属性，加入了th前缀。  属性的作用不变。    加入上th， 属性的值由模板引擎处理了。  在属性可以使用变量表达式</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/loginServlet&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;/loginServlet&quot;</span> <span class="attr">th:method</span>=<span class="string">&quot;$&#123;methodAttr&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="each"><a href="#each" class="headerlink" title="each"></a>each</h2><p>each循环， 可以循环List，Array</p><p>语法：</p><p>在一个html标签中，使用th:each</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;集合循环成员,循环的状态变量:$&#123;key&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;集合循环成员&#125;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">集合循环成员,循环的状态变量:两个名称都是自定义的。 “循环的状态变量”这个名称可以不定义，默认是&quot;集合循环成员Stat&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>each循环Map</p><p>在一个html标签中，使用th:each</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">&quot;集合循环成员,循环的状态变量:$&#123;key&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;集合循环成员.key&#125;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;集合循环成员.value&#125;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">集合循环成员,循环的状态变量:两个名称都是自定义的。 “循环的状态变量”这个名称可以不定义，默认是&quot;集合循环成员Stat&quot;</span><br><span class="line"></span><br><span class="line">key:map集合中的key</span><br><span class="line">value：map集合key对应的value值</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="th-if"><a href="#th-if" class="headerlink" title="th:if"></a>th:if</h2><p>“th:if”  : 判断语句， 当条件为true， 显示html标签体内， 反之不显示 没有else语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot; 10 &gt; 0 &quot;</span>&gt;</span> 显示文本内容 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有一个 th:unless  和 th:if相反的行为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:unless</span>=<span class="string">&quot; 10 &lt; 0 &quot;</span>&gt;</span> 当条件为false显示标签体内容 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例子：if</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span> if 使用<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;sex==&#x27;m&#x27;&#125;&quot;</span>&gt;</span>性别是男<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;isLogin&#125;&quot;</span>&gt;</span>已经登录系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;age &gt; 20&#125;&quot;</span>&gt;</span>年龄大于20<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&quot;&quot;空字符是true--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span>name是“”<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--null是false--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;isOld&#125;&quot;</span>&gt;</span> isOld是null<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子： unless</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h3</span>&gt;</span>unless: 判断条件为false，显示标签体内容<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;sex==&#x27;f&#x27;&#125;&quot;</span>&gt;</span>性别是男的<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;isLogin&#125;&quot;</span>&gt;</span>登录系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;isOld&#125;&quot;</span>&gt;</span> isOld是null <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="th-switch"><a href="#th-switch" class="headerlink" title="th:switch"></a>th:switch</h2><p>th:switch 和 java中的swith一样的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">&quot;要比对的值&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;值1&quot;</span>&gt;</span></span><br><span class="line">        结果1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;值2&quot;</span>&gt;</span></span><br><span class="line">        结果2</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;*&quot;</span>&gt;</span></span><br><span class="line">        默认结果</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    以上的case只有一个语句执行</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="th-inline"><a href="#th-inline" class="headerlink" title="th:inline"></a>th:inline</h2><ol><li><p>内联text：  在html标签外，获取表达式的值</p><p>语法： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>显示姓名是：[[$&#123;key&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>内联 text, 使用内联表达式显示变量的值<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:inline</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是[[$&#123;name&#125;]]，年龄是[[$&#123;age&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            我是<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>,年龄是<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;age&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用内联text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是[[$&#123;name&#125;]],性别是[[$&#123;sex&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>内联javascript</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:inline</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">var</span> myname = [[$&#123;name&#125;]];</span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">var</span> myage = [[$&#123;age&#125;]];</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">         <span class="comment">//alert(&quot;获取的模板中数据 &quot;+ myname + &quot;,&quot;+myage)</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;单击事件，获取数据 &quot;</span>+ myname + <span class="string">&quot;,&quot;</span>+ [[$&#123;sex&#125;]])</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>文本字面量: 使用单引号括起来的字符串<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;我是&#x27;+$&#123;name&#125;+&#x27;,我所在的城市&#x27;+$&#123;city&#125;&quot;</span>&gt;</span>数据显示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>数字字面量<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;20&gt;5&#125;&quot;</span>&gt;</span> 20大于 5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">h3</span>&gt;</span>boolean字面量<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;isLogin == true&#125;&quot;</span>&gt;</span>用户已经登录系统<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">h3</span>&gt;</span>null字面量<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;myuser != null&#125;&quot;</span>&gt;</span>有myuser数据<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p>连接字符串有两种语法</p><p>1） 语法使用 单引号括起来字符串  ， 使用 + 连接其他的 字符串或者表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;我是&#x27;+$&#123;name&#125;+&#x27;,我所在的城市&#x27;+$&#123;city&#125;&quot;</span>&gt;</span>数据显示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）语法：使用双竖线， |字符串和表达式|</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;|我是$&#123;name&#125;,我所在城市$&#123;city|&quot;</span>&gt;</span></span><br><span class="line">    显示数据</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h3</span>&gt;</span>字符串连接方式1：使用单引号括起来的字符串<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;我是&#x27;+$&#123;name&#125;+&#x27;,我所在的城市&#x27;+$&#123;city&#125;&quot;</span>&gt;</span>数据显示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>字符串连接方式2：|字符串和表达式|<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;|我是$&#123;name&#125;,所在城市$&#123;city&#125;,其他人$&#123;myuser.name&#125;|&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">算术运 算： + , - - , * , / , %</span><br><span class="line">关系比较 : &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</span><br><span class="line">相等判断： == , != ( eq , ne )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 400px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>使用运算符<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;age &gt; 10&#125;&quot;</span>&gt;</span>年龄大于 10 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123; 20 + 30 &#125;&quot;</span>&gt;</span>显示运算结果<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;myuser == null&#125;&quot;</span>&gt;</span>myuser是null<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;myuser eq null&#125;&quot;</span>&gt;</span>myuser是null<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;myuser ne null&#125;&quot;</span>&gt;</span>myuser不是null<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;isLogin == true ? &#x27;用户已经登录&#x27; : &#x27;用户需要登录&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;isLogin == true ? ( age &gt; 10 ? &#x27;用户是大于10的&#x27; : &#x27;用户年龄比较小&#x27;) : &#x27;用户需要登录&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">三元运算符：</span><br><span class="line"> 表达式  ？ true的结果 : false的结果</span><br><span class="line"></span><br><span class="line">三元运算符可以嵌套</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>文档地址：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#web-context-namespaces-for-requestsession-attributes-etc">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#web-context-namespaces-for-requestsession-attributes-etc</a>.</p><p>#request 表示 HttpServletRequest</p><p>#session 表示 HttpSession对象</p><p>session 表示Map对象的， 是#session的简单表示方式， 用来获取session中指定的key的值</p><p>​               #session.getAttribute(“loginname”) &#x3D;&#x3D; session.loginname</p><p>这些是内置对象，可以在模板文件中直接使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 350px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>内置对象#request,#session，session的使用<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>获取作用域中的数据<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getAttribute(&#x27;requestData&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#session.getAttribute(&#x27;sessionData&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.loginname&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>使用内置对象的方法<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        getRequestURL=<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getRequestURL()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        getRequestURI=<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getRequestURI()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        getQueryString=<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getQueryString()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        getContextPath=<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getContextPath()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        getServerName=<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getServerName()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        getServerPort=<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.getServerPort()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="内置工具类"><a href="#内置工具类" class="headerlink" title="内置工具类"></a>内置工具类</h2><p>内置工具类型： Thymeleaf自己的一些类，提供对string， date ，集合的一些处理方法</p><p>#dates: 处理日器的工具类</p><p>#numbers:处理数字的</p><p>#lists: 处理list集合的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 350px&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>日期类对象 #dates<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(mydate )&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(mydate,&#x27;yyyy-MM-dd&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(mydate,&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.year(mydate)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.month(mydate)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.monthName(mydate)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.createNow()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>内置工具类#numbers，操作数字的<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#numbers.formatCurrency(mynum)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#numbers.formatDecimal(mynum,5,2)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>内置工具类#strings,操作字符串<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.toUpperCase(mystr)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.indexOf(mystr,&#x27;power&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.substring(mystr,2,5)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.substring(mystr,2)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.concat(mystr,&#x27;---java开发的黄埔军校---&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.length(mystr)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.length(&#x27;hello&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;#strings.isEmpty(mystr)&#125;&quot;</span>&gt;</span> mystring 不是 空字符串  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>内置工具类#lists,操作list集合<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#lists.size(mylist)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#lists.contains(mylist,&#x27;a&#x27;)&#125;&quot;</span>&gt;</span>有成员a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:if</span>=<span class="string">&quot;!$&#123;#lists.isEmpty(mylist)&#125;&quot;</span>&gt;</span> list 集合有多个成员<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>处理null<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;zoo?.dog?.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h2><p>模板是内容复用， 定义一次，在其他的模板文件中多次使用。</p><p>模板使用：</p><p>1.定义模板</p><p>2.使用模板</p><p>模板定义语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">th:fragment=&quot;模板自定义名称&quot;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">&quot;head&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        动力节点-java开发</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        www.bjpowernode.com</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用模板语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) ~&#123;templatename :: selector&#125;</span><br><span class="line">   templatename:  文件名称</span><br><span class="line">   selector： 自定义模板名称</span><br><span class="line">2）templatename :: selector</span><br><span class="line">   templatename:  文件名称</span><br><span class="line">   selector： 自定义模板名称</span><br><span class="line"></span><br><span class="line">对于使用模板：有包含模板（th:include）， 插入模板(th:insert)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Thymeleaf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2022/11/02/SpringBoot/"/>
      <url>/2022/11/02/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p><span id="more"></span><h1 id="第一章-JavaConfig"><a href="#第一章-JavaConfig" class="headerlink" title="第一章  JavaConfig"></a>第一章  JavaConfig</h1><ol><li><p>为什么要使用 Spring Boot</p><p>因为Spring， SpringMVC 需要使用的大量的配置文件 （xml文件）</p><p>还需要配置各种对象，把使用的对象放入到spring容器中才能使用对象</p><p>需要了解其他框架配置规则。</p></li><li><p>SpringBoot 就相当于 不需要配置文件的Spring+SpringMVC。 常用的框架和第三方库都已经配置好了。</p><p>拿来就可以使用了。</p></li><li><p>SpringBoot开发效率高，使用方便多了</p></li></ol><h2 id="1-1-JavaConfig"><a href="#1-1-JavaConfig" class="headerlink" title="1.1 JavaConfig"></a>1.1 JavaConfig</h2><p>JavaConfig: 使用java类作为xml配置文件的替代， 是配置spring容器的纯java的方式。 在这个java类这可以创建java对象，把对象放入spring容器中（注入到容器）， </p><p>使用两个注解：</p><p>1）@Configuration ： 放在一个类的上面，表示这个类是作为配置文件使用的。</p><p>2）@Bean：声明对象，把对象注入到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"><span class="keyword">package</span> com.bjpowernode.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bjpowernode.vo.Student;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configuration:表示当前类是作为配置文件使用的。 就是用来配置容器的</span></span><br><span class="line"><span class="comment"> *       位置：在类的上面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  SpringConfig这个类就相当于beans.xml</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建方法，方法的返回值是对象。 在方法的上面加入<span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment">     * 方法的返回值对象就注入到容器中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span>: 把对象注入到spring容器中。 作用相当于&lt;bean&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     位置：方法的上面</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     说明：<span class="doctag">@Bean</span>,不指定对象的名称，默认是方法名是 id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">createStudent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        s1.setAge(<span class="number">26</span>);</span><br><span class="line">        s1.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 指定对象在容器中的名称（指定&lt;bean&gt;的id属性）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span>的name属性，指定对象的名称（id）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;lisiStudent&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">makeStudent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        s2.setAge(<span class="number">22</span>);</span><br><span class="line">        s2.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-2-ImporResource"><a href="#1-2-ImporResource" class="headerlink" title="1.2 @ImporResource"></a>1.2 @ImporResource</h2><p>@ImportResource 作用导入其他的xml配置文件， 等于 在xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resources</span>=<span class="string">&quot;其他配置文件&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(value =&#123; &quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-PropertyResource"><a href="#1-3-PropertyResource" class="headerlink" title="1.3 @PropertyResource"></a>1.3 @PropertyResource</h2><p>@PropertyResource: 读取properties属性配置文件。 使用属性配置文件可以实现外部化配置 ，</p><p>在程序代码之外提供数据。</p><p>步骤：</p><ol><li>在resources目录下，创建properties文件， 使用k&#x3D;v的格式提供数据</li><li>在PropertyResource 指定properties文件的位置</li><li>使用@Value（value&#x3D;”${key}”）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(value =&#123; &quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:config.properties&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.bjpowernode.vo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二-章-Spring-Boot"><a href="#第二-章-Spring-Boot" class="headerlink" title="第二 章 Spring Boot"></a>第二 章 Spring Boot</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>SpringBoot是Spring中的一个成员， 可以简化Spring，SpringMVC的使用。 他的核心还是IOC容器。</p><p>特点：</p><ul><li><p>Create stand-alone Spring applications</p><p> 创建spring应用</p></li><li><p>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</p><p>内嵌的tomcat， jetty ， Undertow </p></li><li><p>Provide opinionated ‘starter’ dependencies to simplify your build configuration</p><p>提供了starter起步依赖，简化应用的配置。   </p><p>比如使用MyBatis框架 ， 需要在Spring项目中，配置MyBatis的对象 SqlSessionFactory ， Dao的代理对象</p><p>在SpringBoot项目中，在pom.xml里面, 加入一个 mybatis-spring-boot-starter依赖</p></li><li><p>Automatically configure Spring and 3rd party libraries whenever possible</p><p>尽可能去配置spring和第三方库。叫做自动配置（就是把spring中的，第三方库中的对象都创建好，放到容器中， 开发人员可以直接使用）</p></li><li><p>Provide production-ready features such as metrics, health checks, and externalized configuration</p><p> 提供了健康检查， 统计，外部化配置</p></li><li><p>Absolutely no code generation and no requirement for XML configuration</p><p>不用生成代码， 不用使用xml，做配置</p></li></ul><h2 id="2-2-创建Spring-Boot项目"><a href="#2-2-创建Spring-Boot项目" class="headerlink" title="2.2 创建Spring Boot项目"></a>2.2 创建Spring Boot项目</h2><h3 id="2-2-1-第一种方式，-使用Spring提供的初始化器，-就是向导创建SpringBoot应用"><a href="#2-2-1-第一种方式，-使用Spring提供的初始化器，-就是向导创建SpringBoot应用" class="headerlink" title="2.2.1 第一种方式， 使用Spring提供的初始化器， 就是向导创建SpringBoot应用"></a>2.2.1 第一种方式， 使用Spring提供的初始化器， 就是向导创建SpringBoot应用</h3><p>使用的地址： <a href="https://start.spring.io/">https://start.spring.io</a></p><p>SpringBoot项目的结构：</p><p><img src="/2022/11/02/SpringBoot/course\25-SpringBoot\笔记\images\image-20210115152427829.png" alt="image-20210115152427829">    </p><h3 id="2-2-1-使用国内的地址"><a href="#2-2-1-使用国内的地址" class="headerlink" title="2.2.1  使用国内的地址"></a>2.2.1  使用国内的地址</h3><p><a href="https://start.springboot.io/">https://start.springboot.io</a></p><p><img src="/2022/11/02/SpringBoot/course\25-SpringBoot\笔记\images\image-20210115155556662.png" alt="image-20210115155556662">    </p><h2 id="2-3-注解的使用"><a href="#2-3-注解的使用" class="headerlink" title="2.3  注解的使用"></a>2.3  注解的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">符合注解：由</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">1.</span><span class="meta">@SpringBootConfiguration</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Configuration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：使用了<span class="meta">@SpringBootConfiguration</span>注解标注的类，可以作为配置文件使用的，</span><br><span class="line">    可以使用Bean声明对象，注入到容器</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.@EnableAutoConfiguration</p><p>启用自动配置， 把java对象配置好，注入到spring容器中。例如可以把mybatis的对象创建好，放入到容器中</p><p>3.@ComponentScan</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span> 扫描器，找到注解，根据注解的功能创建对象，给属性赋值等等。</span><br><span class="line">默认扫描的包： <span class="meta">@ComponentScan</span>所在的类所在的包和子包。</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="2-4-SpringBoot的配置文件"><a href="#2-4-SpringBoot的配置文件" class="headerlink" title="2.4 SpringBoot的配置文件"></a>2.4 SpringBoot的配置文件</h2><p>配置文件名称： application</p><p>扩展名有： properties( k&#x3D;v) ;  yml ( k: v)</p><p>使用application.properties,   application.yml</p><p>例1：application.properties设置 端口和上下文</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置端口号</span><br><span class="line">server.port=8082</span><br><span class="line">#设置访问应用上下文路径， contextpath</span><br><span class="line">server.servlet.context-path=/myboot</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例2： application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/myboot2</span></span><br></pre></td></tr></table></figure><h2 id="2-5-多环境配置"><a href="#2-5-多环境配置" class="headerlink" title="2.5 多环境配置"></a>2.5 多环境配置</h2><p>有开发环境， 测试环境， 上线的环境。</p><p>每个环境有不同的配置信息， 例如端口， 上下文件， 数据库url，用户名，密码等等</p><p>使用多环境配置文件，可以方便的切换不同的配置。</p><p>使用方式： 创建多个配置文件， 名称规则： application-环境名称.properties(yml)</p><p>创建开发环境的配置文件： application-dev.properties(  application-dev.yml )</p><p>创建测试者使用的配置： application-test.properties</p><h2 id="2-6-ConfigurationProperties"><a href="#2-6-ConfigurationProperties" class="headerlink" title="2.6 @ConfigurationProperties"></a>2.6 @ConfigurationProperties</h2><p>@ConfigurationProperties: 把配置文件的数据映射为java对象。</p><p>属性：prefix 配置文件中的某些key的开头的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;school&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchoolInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String website;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getWebsite</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> website;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWebsite</span><span class="params">(String website)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.website = website;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SchoolInfo&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, website=&#x27;&quot;</span> + website + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#配置端口号</span><br><span class="line">server.port=8082</span><br><span class="line">#context-path</span><br><span class="line">server.servlet.context-path=/myboot</span><br><span class="line"></span><br><span class="line">#自定义key=value</span><br><span class="line">school.name=动力节点</span><br><span class="line">school.website=www.bjpowernode.com</span><br><span class="line">school.address=北京的大兴区</span><br><span class="line"></span><br><span class="line">site=www.bjpowernode.com</span><br></pre></td></tr></table></figure><h2 id="2-7-使用容器"><a href="#2-7-使用容器" class="headerlink" title="2.7 使用容器"></a>2.7 使用容器</h2><p>你想通过代码，从容器中获取对象。</p><p>通过SpringApplication.run(Application.class, args); 返回值获取容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;primarySource&#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConfigurableApplicationContext : 接口，是ApplicationContext的子接口</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConfigurableApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">ApplicationContext</span></span><br></pre></td></tr></table></figure><h2 id="2-8-ComnandLineRunner-接口-，-ApplcationRunner接口"><a href="#2-8-ComnandLineRunner-接口-，-ApplcationRunner接口" class="headerlink" title="2.8 ComnandLineRunner 接口 ，  ApplcationRunner接口"></a>2.8 ComnandLineRunner 接口 ，  ApplcationRunner接口</h2><p>这两个接口都 有一个run方法。 执行时间在容器对象创建好后， 自动执行run（）方法。</p><p>可以完成自定义的在容器对象创建好的一些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第三章-Web组件"><a href="#第三章-Web组件" class="headerlink" title="第三章 Web组件"></a>第三章 Web组件</h1><p>讲三个内容： 拦截器， Servlet ，Filter</p><h2 id="3-1-拦截器"><a href="#3-1-拦截器" class="headerlink" title="3.1 拦截器"></a>3.1 拦截器</h2><p>拦截器是SpringMVC中一种对象，能拦截器对Controller的请求。</p><p>拦截器框架中有系统的拦截器， 还可以自定义拦截器。  实现对请求预先处理。</p><p>实现自定义拦截器：</p><ol><li><p>创建类实现SpringMVC框架的HandlerInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, <span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2.需在SpringMVC的配置文件中，声明拦截器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    &lt;mvc:path=&quot;url&quot; /&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;拦截器类全限定名称&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot中注册拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加拦截器对象， 注入到容器中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建拦截器对象</span></span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定拦截的请求uri地址</span></span><br><span class="line">        String path []= &#123;<span class="string">&quot;/user/**&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//指定不拦截的地址</span></span><br><span class="line">        String excludePath  [] = &#123;<span class="string">&quot;/user/login&quot;</span>&#125;;</span><br><span class="line">        registry.addInterceptor(interceptor)</span><br><span class="line">                .addPathPatterns(path)</span><br><span class="line">                .excludePathPatterns(excludePath);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-Servlet"><a href="#3-2-Servlet" class="headerlink" title="3.2  Servlet"></a>3.2  Servlet</h2><p>在SpringBoot框架中使用Servlet对象。</p><p>使用步骤：</p><ol><li>创建Servlet类。 创建类继承HttpServlet</li><li>注册Servlet ，让框架能找到Servlet</li></ol><p> 例子：</p><p>1.创建自定义Servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Servlet类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doPost(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       <span class="comment">//使用HttpServletResponse输出数据，应答结果</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span>  <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;===执行的是Servlet==&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>注册Servlet</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebApplictionConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法， 注册Servlet对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">servletRegistrationBean</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public ServletRegistrationBean(T servlet, String... urlMappings)</span></span><br><span class="line">        <span class="comment">//第一个参数是 Servlet对象， 第二个是url地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ServletRegistrationBean bean =</span></span><br><span class="line">                <span class="comment">//new ServletRegistrationBean( new MyServlet(),&quot;/myservlet&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>();</span><br><span class="line">        bean.setServlet( <span class="keyword">new</span> <span class="title class_">MyServlet</span>());</span><br><span class="line">        bean.addUrlMappings(<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/test&quot;</span>); <span class="comment">// &lt;url-pattern&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-过滤器Filter"><a href="#3-3-过滤器Filter" class="headerlink" title="3.3 过滤器Filter"></a>3.3 过滤器Filter</h2><p>Filter是Servlet规范中的过滤器，可以处理请求， 对请求的参数， 属性进行调整。 常常在过滤器中处理字符编码</p><p>在框架中使用过滤器：</p><ol><li>创建自定义过滤器类</li><li>注册Filter过滤器对象</li></ol><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了MyFilter，doFilter &quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebApplicationConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">filterRegistrationBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">FilterRegistrationBean</span> <span class="variable">bean</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line">        bean.setFilter( <span class="keyword">new</span> <span class="title class_">MyFilter</span>());</span><br><span class="line">        bean.addUrlPatterns(<span class="string">&quot;/user/*&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-字符集过滤器"><a href="#3-4-字符集过滤器" class="headerlink" title="3.4 字符集过滤器"></a>3.4 字符集过滤器</h2><p>CharacterEncodingFilter : 解决post请求中乱码的问题</p><p>在SpringMVC框架， 在web.xml 注册过滤器。 配置他的属性。 </p><p>第一种方式：</p><p>使用步骤：</p><ol><li><p>配置字符集过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSystemConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册Servlet</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">servletRegistrationBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyServlet</span> <span class="variable">myServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyServlet</span>();</span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(myServlet,<span class="string">&quot;/myservlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> reg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册Filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean <span class="title function_">filterRegistrationBean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">FilterRegistrationBean</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用框架中的过滤器类</span></span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        <span class="comment">//指定使用的编码方式</span></span><br><span class="line">        filter.setEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//指定request ， response都使用encoding的值</span></span><br><span class="line">        filter.setForceEncoding(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        reg.setFilter(filter);</span><br><span class="line">        <span class="comment">//指定 过滤的url地址</span></span><br><span class="line">        reg.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改application.properties文件， 让自定义的过滤器起作用</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#SpringBoot中默认已经配置了CharacterEncodingFilter。 编码默认ISO-8859-1</span></span><br><span class="line"><span class="comment">#设置enabled=false 作用是关闭系统中配置好的过滤器， 使用自定义的CharacterEncodingFilter</span></span><br><span class="line"><span class="attr">server.servlet.encoding.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>第二种方式</p><p>修改application.properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">9001</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/myboot</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#让系统的CharacterEncdoingFilter生效</span></span><br><span class="line"><span class="attr">server.servlet.encoding.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#指定使用的编码方式</span></span><br><span class="line"><span class="attr">server.servlet.encoding.charset</span>=<span class="string">utf-8</span></span><br><span class="line"><span class="comment">#强制request，response都使用charset属性的值</span></span><br><span class="line"><span class="attr">server.servlet.encoding.force</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h1 id="第四章-ORM-操作-MySQL"><a href="#第四章-ORM-操作-MySQL" class="headerlink" title="第四章 ORM 操作 MySQL"></a>第四章 ORM 操作 MySQL</h1><p>使用MyBatis框架操作数据，  在SpringBoot框架集成MyBatis</p><p>使用步骤：</p><ol><li><p>mybatis起步依赖 ： 完成mybatis对象自动配置， 对象放在容器中</p></li><li><p>pom.xml 指定把src&#x2F;main&#x2F;java目录中的xml文件包含到classpath中</p></li><li><p>创建实体类Student</p></li><li><p>创建Dao接口 StudentDao , 创建一个查询学生的方法 </p></li><li><p>创建Dao接口对应的Mapper文件， xml文件， 写sql语句</p></li><li><p>创建Service层对象， 创建StudentService接口和他的实现类。 去dao对象的方法。完成数据库的操作</p></li><li><p>创建Controller对象，访问Service。</p></li><li><p>写application.properties文件</p><p>配置数据库的连接信息。</p></li></ol><h3 id="第一种方式-：-Mapper"><a href="#第一种方式-：-Mapper" class="headerlink" title="第一种方式 ： @Mapper"></a>第一种方式 ： @Mapper</h3><p>@Mapper：放在dao接口的上面， 每个接口都需要使用这个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Mapper</span>：告诉MyBatis这是dao接口，创建此接口的代理对象。</span></span><br><span class="line"><span class="comment"> *     位置：在类的上面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    Student <span class="title function_">selectById</span><span class="params">(<span class="meta">@Param(&quot;stuId&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种方式-MapperScan"><a href="#第二种方式-MapperScan" class="headerlink" title="第二种方式  @MapperScan"></a>第二种方式  @MapperScan</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@MapperScan</span>: 找到Dao接口和Mapper文件</span></span><br><span class="line"><span class="comment"> *     basePackages：Dao接口所在的包名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.bjpowernode.dao&quot;,&quot;com.bjpowernode.mapper&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三种方式：-Mapper文件和Dao接口分开管理"><a href="#第三种方式：-Mapper文件和Dao接口分开管理" class="headerlink" title="第三种方式： Mapper文件和Dao接口分开管理"></a>第三种方式： Mapper文件和Dao接口分开管理</h3><p> 现在把Mapper文件放在resources目录下</p><p>1）在resources目录中创建子目录 （自定义的） ， 例如mapper</p><p>2）把mapper文件放到 mapper目录中</p><p>3）在application.properties文件中，指定mapper文件的目录</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定mapper文件的位置</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="comment">#指定mybatis的日志</span></span><br><span class="line"><span class="attr">mybatis.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在pom.xml中指定 把resources目录中的文件 ， 编译到目标目录中</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--resources插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="第四个-事务"><a href="#第四个-事务" class="headerlink" title="第四个  事务"></a>第四个  事务</h3><p>Spring框架中的事务：</p><p>1） 管理事务的对象： 事务管理器（接口， 接口有很多的实现类）</p><p>​      例如：使用Jdbc或mybatis访问数据库，使用的事务管理器：DataSourceTransactionManager</p><p>2 ) 声明式事务：  在xml配置文件或者使用注解说明事务控制的内容</p><p>​     控制事务： 隔离级别，传播行为， 超时时间</p><p>3）事务处理方式：</p><p>​      1） Spring框架中的@Transactional</p><p>​      2)    aspectj框架可以在xml配置文件中，声明事务控制的内容</p><p>​    </p><p>SpringBoot中使用事务： 上面的两种方式都可以。</p><p>1）在业务方法的上面加入@Transactional ,  加入注解后，方法有事务功能了。</p><p>2）明确的在 主启动类的上面 ，加入@EnableTransactionManager</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Transactional</span>: 表示方法的有事务支持</span></span><br><span class="line"><span class="comment"> *       默认：使用库的隔离级别， REQUIRED 传播行为； 超时时间  -1</span></span><br><span class="line"><span class="comment"> *       抛出运行时异常，回滚事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;业务方法addStudent&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span>  <span class="operator">=</span>  studentDao.insert(student);</span><br><span class="line">    System.out.println(<span class="string">&quot;执行sql语句&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抛出一个运行时异常， 目的是回滚事务</span></span><br><span class="line">    <span class="comment">//int m   = 10 / 0 ;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2022/10/09/SpringMVC/"/>
      <url>/2022/10/09/SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SpringMVC 是一种基于 Java 的实现 MVC(Model-View-Controller) 设计模型的请求驱动类型的轻量级 Web 框架 </p><span id="more"></span><h1 id="创建SpringMVC对象"><a href="#创建SpringMVC对象" class="headerlink" title="创建SpringMVC对象"></a>创建SpringMVC对象</h1><ul><li><p>声明springmvc核心对象DispatcherServlet</p></li><li><p>需要在tomcat启动后创建DispatcherServlet的实例</p></li><li><p>DispatcherServlet 在创建过程中 会同时创建springmvc对象</p></li><li><p>读取springmvc的配置文件 把这个配置文件中的对象都创建好 当用户发送请求时就可以直接使用对象了</p></li><li><p>处理用户提交的请求  springmvc中使用方法来处理<br>方法是自定义的 可以有多种返回值  多种参数 方法名称自定义</p></li><li><p>servlet的初始化会执行init 方法 </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DispatcherServlet 在init方法中&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建容器对象  读取配置文件</span></span><br><span class="line"><span class="type">WebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;springmvc.xml&quot;</span>);</span><br><span class="line"><span class="comment">//把容器中的对象放入到ServletContext中</span></span><br><span class="line">getServletContext().setAttribute(key,cxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="web-xml的配置"><a href="#web-xml的配置" class="headerlink" title="web.xml的配置"></a>web.xml的配置</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      在tomcat启动后 创建servlet对象</span></span><br><span class="line"><span class="comment">      load-on-startup 表示tomcat 启动后创建对象的顺序  值为整数 数值越小</span></span><br><span class="line"><span class="comment">      创建对象越早   是个大于等于0的整数</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--        自定义springmvc的配置文件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--            springmvc的配置文件的位置属性--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--            指定自定义文件的位置--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      使用框架的时候  url-pattern 可以使用两种值</span></span><br><span class="line"><span class="comment">      - 使用扩展名方式  语法  ***.do</span></span><br><span class="line"><span class="comment">      - 使用斜杠 &quot;/&quot;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      当项目中使用了 / 时  它会替代tomcat中的default</span></span><br><span class="line"><span class="comment">       导致所有的静态资源 都给DispatcherServlet 处理  默认情况下  DispatcherServlet 没有处理静态资源的能力</span></span><br><span class="line"><span class="comment">       所以静态资源将无法访问</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="SpringMVC-注解"><a href="#SpringMVC-注解" class="headerlink" title="SpringMVC 注解"></a>SpringMVC 注解</h1><ul><li>@RequestMapping  请求映射  作用是把一个请求地址和一个方法绑定在一起一个请求指定一个方法处理<ul><li>属性<ul><li>value  是一个string  表示请求的url地址（some.do）<br> value 的值必须是一致的  不能重复</li><li>method  表示请求的方式  它的值RequestMethod类枚举值例如表示get请求方式 RequestMethod.Get or  Post</li></ul></li><li>位置<ul><li>在方法的上面   </li><li>在类的上面  所有请求地址的公共部分  叫做模块名称</li></ul></li><li>使用@RequestMapping 修饰的方法叫做处理器方法 该方法可以处理请求 类似doGet doPost</li></ul></li><li>返回值<ul><li>Model  数据  请求处理完成后  要显示给用户的数据</li><li>View  视图   比如jsp等等</li></ul></li></ul><h1 id="SpringMVC-接收参数"><a href="#SpringMVC-接收参数" class="headerlink" title="SpringMVC 接收参数"></a>SpringMVC 接收参数</h1><ul><li><p>逐个接受用户的请求参数</p><ul><li>要求<ul><li>处理器方法的形参名与请求中参数名一致</li><li>同名的参数赋值给同名的形参</li></ul></li></ul></li><li><p>框架接受请求参数</p><ul><li>使用request 对象接受请求参数<blockquote><p>String strName &#x3D; request.getParameter(“name”)</p></blockquote></li><li>框架通过DisoatcherServlet 调用方法  调用方法时按名称对应将接受的参数赋值给形参并进行相应的类型转换</li></ul></li><li><p>请求中参数名称和处理器方法形参不一样时</p><ul><li>使用@RequestParam 给变量起别名<ul><li>属性   <ul><li>value   请求中参数名称(别名)</li><li>required  是一个Boolean  默认是true  表示请求中必须包含此参数</li></ul></li><li>位置<br>在处理器方法的形参定义的前面</li></ul></li></ul></li><li><p>处理器方法是java对象  </p><ul><li>要求这个对象的属性名与请求中参数名一致<br>框架会创建形参的java对象  并调用set方法对属性赋值</li></ul></li></ul><h1 id="SpringMVC-返回值"><a href="#SpringMVC-返回值" class="headerlink" title="SpringMVC 返回值"></a>SpringMVC 返回值</h1><ul><li>处理器方法返回String    表示逻辑视图名称或数据  需要配置视图解析器<ul><li>区分返回值string是不是数据  看有没有@ResponseBody注解 有则是数据 否则是视图</li><li>当charset默认为ISO-8859-1 时  会出现中文乱码  在@RequestMapping中设置   produces &#x3D; “text&#x2F;plain;charset &#x3D; utf-8”</li></ul></li><li>放回值是void 不能表示数据 也不能表示视图<ul><li>在处理ajax的时候  可以使用void返回值  通过HttpServletResponse输出数据  响应ajax请求</li><li>ajax请求服务器返回的就是数据  和视图无关</li></ul></li><li>返回值是Object   返回的对象是数据  和视图无关<br>可以使用对象表示的数据  响应ajax请求<ul><li>实现步骤<ul><li>加入处理json的的工具库依赖 springmvc默认使用的是jackjson</li><li>在spring配置文件之间加入<a href="mvc:annotation-driven">mvc:annotation-driven</a>注解驱动<br>  json &#x3D; om.writeValueString(Object);<br>  注解驱动完成的功能  完成java对象到json xml  text  二进制等数据的转换</li><li>在处理器方法上加入@ResponseBody注解<br>  response.setContextType(“”application&#x2F;json;charset &#x3D; utf-8)<br>  PrintWriter pw &#x3D; response.getWriter();<br>  pw.println(json);</li></ul></li></ul></li></ul><h1 id="SpringMVC-处理静态资源"><a href="#SpringMVC-处理静态资源" class="headerlink" title="SpringMVC 处理静态资源"></a>SpringMVC 处理静态资源</h1><ul><li>第一种处理静态资源的方式<br><ul><li>需要在springmvc的配置文件中加入<a href="mvc:default-servlet-handler">mvc:default-servlet-handler</a></li><li>加入该标签后  框架会创建一个控制器对象DefaultServletHttpRequestHandler （类似自己创建的myController）</li><li>DefaultServletHttpRequestHandler这个对象可以把接收的请求 转发给 tomcat的default这个servlet  实现静态资源的访问</li></ul></li><li>第二种处理静态资源的方式<ul><li>mvc:resource 加入后框架会创建  ResourceHttpServletHandler 这个处理器对象</li><li>让这个对象处理静态资源的访问  不依赖tomcat服务器<ul><li>mapping 访问静态资源的url地址 可以使用通配符 **</li><li>location 静态资源在项目中的位置  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p><strong>default-servlet-handler 与 @RequestMapping 有冲突  加上注解驱动解决</strong></p><h1 id="SpringMVC-Forward-and-Redirect"><a href="#SpringMVC-Forward-and-Redirect" class="headerlink" title="SpringMVC Forward and Redirect"></a>SpringMVC Forward and Redirect</h1><ul><li>处理器返回ModelAndView 实现转发forward<ul><li>语法 setViewName（“forward：视图文件的完整路径”）</li><li>forward  特点  不和视图解析器一同使用  就当项目中没有视图解析器</li></ul></li><li>处理器返回ModelAndView 实现转发redirect<ul><li>语法 setViewName（“redirect：视图文件的完整路径”）</li><li>redirect  特点  不和视图解析器一同使用  就当项目中没有视图解析器<br>进行重定向时加入模型的数据会拼接到地址的后面  类似get请求 可以通过获取param来获得数据<h1 id="SpringMVC-配置文件"><a href="#SpringMVC-配置文件" class="headerlink" title="SpringMVC 配置文件"></a>SpringMVC 配置文件</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    声明组件扫描器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kris.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    声明 视图解析器 帮助开发人员设置视图文件的路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        前缀  视图文件的路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        后缀   视图文件的拓展名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="SpringMVC-处理异常"><a href="#SpringMVC-处理异常" class="headerlink" title="SpringMVC 处理异常"></a>SpringMVC 处理异常</h1><ul><li>定义一个全局异常类 加上@ControllerAdvice注解<ul><li>@ControllerAdvice : 控制器增强（也就是说给控制器类增加功能–异常处理功能）<ul><li>位置：在类的上面。</li><li>特点：必须让框架知道这个注解所在的包名，需要在springmvc配置文件声明组件扫描器。<br>指定@ControllerAdvice所在的包名</li></ul></li></ul></li><li>处理异常的方法和控制器方法的定义一样， 可以有多个参数，可以有ModelAndView,<br>String, void,对象类型的返回值<ul><li>形参：Exception，表示Controller中抛出的异常对象。<br>通过形参可以获取发生的异常信息。</li><li>@ExceptionHandler(异常的class)：表示异常的类型，当发生此类型异常时，由当前方法处理</li></ul></li></ul><h1 id="SpringMVC-拦截器"><a href="#SpringMVC-拦截器" class="headerlink" title="SpringMVC 拦截器"></a>SpringMVC 拦截器</h1><ul><li><p>拦截器类需要实现HandlerInterceptor接口 接口中有 preHandle postHandle   afterCompletion 三个方法</p><ul><li><p>preHandle 预处理器对象</p><ul><li>参数<ul><li>Object  handle 被拦截的控制器对象</li></ul></li><li>返回值<ul><li>true  通过拦截器 可以执行控制器方法</li><li>false  无法通过拦截器  请求被拦截</li></ul></li></ul></li><li><p>特点</p><ul><li>方法在控制器方法之前先执行  用户的请求首先到达此方法</li><li>在这个方法中可以获取请求的信息  验证该请求是否符合要求</li><li>可以验证用户是否登录以及用户是否用权限访问某个连接地址</li><li>如果验证失败 可以截断请求 请求不能被处理</li><li>如果验证成功  可以放行请求  此时控制器方法才可以执行</li></ul></li><li><p>postHandle 后处理方法</p><ul><li>参数<ul><li>Object  被拦截的处理器对象</li><li>ModelAndView 处理器方法的返回值</li></ul></li><li>特点</li><li>在处理器方法之后执行的</li><li>能够获取到处理器方法的返回值ModelAndView  可以修改返回的视图和数据  可以影响到最后的执行结果</li><li>主要是对原来的执行结果进行二次修正</li></ul></li><li><p>afterCompletion 最后执行的方法</p><ul><li>参数<ul><li>Object handler 被拦截的处理器对象</li><li>Exception ex  程序中发生的异常</li></ul></li><li>特点<ul><li>在请求处理完成后执行  框架中规定是当你的视图处理完成后 对视图执行了forward 就认为请求处理完成</li><li>一般做资源回收工作的  程序请求过程中创建了一些对象  在这里可以删除  把占用的内存回收</li></ul></li></ul></li></ul></li><li><p>声明拦截器  拦截器可以有0个或多个</p></li><li><p>在框架中保存多个拦截器是ArrayList</p></li><li><p>按照声明的先后顺序放入到list中</p><h2 id="拦截器的声明"><a href="#拦截器的声明" class="headerlink" title="拦截器的声明"></a>拦截器的声明</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        声明第一个拦截器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            指定拦截的url地址</span></span><br><span class="line"><span class="comment">            path 就是url地址  可以使用通配符 **</span></span><br><span class="line"><span class="comment">                ** 表示任意字符  文件或者多级目录和目录下的文件</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            声明拦截器对象--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.handler.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        第二个拦截器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.handler.MyInterceptor2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="SpringMVC处理post请求参数乱码问题"><a href="#SpringMVC处理post请求参数乱码问题" class="headerlink" title="SpringMVC处理post请求参数乱码问题"></a>SpringMVC处理post请求参数乱码问题</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    注册声明过滤器  解决post请求参数乱码问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>character<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>foreResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>character<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树</title>
      <link href="/2022/09/17/HuffmanTree/"/>
      <url>/2022/09/17/HuffmanTree/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近</p><span id="more"></span><h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><p><strong>路径</strong>：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。</p><p><strong>路径长度</strong>：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。</p><p><strong>结点的权</strong>：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。</p><p><strong>结点的带权路径长度</strong>：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 &#x3D; 10 。</p><h1 id="构建哈夫曼树的过程"><a href="#构建哈夫曼树的过程" class="headerlink" title="构建哈夫曼树的过程"></a>构建哈夫曼树的过程</h1><ul><li>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；</li><li>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；</li><li>重复 上述步骤 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;             </span><br><span class="line">        <span class="comment">//创建哈夫曼树</span></span><br><span class="line">        <span class="type">HNode</span> <span class="variable">root</span> <span class="operator">=</span> creatHuffmanTree(arr);</span><br><span class="line">        <span class="comment">//遍历哈夫曼树</span></span><br><span class="line">        traversal(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建赫夫曼树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 创建赫夫曼树需要的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回赫夫曼树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HNode <span class="title function_">creatHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//用于存储结点的链表</span></span><br><span class="line">        List&lt;HNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HNode&gt;();</span><br><span class="line">        <span class="comment">//循环数组 将其中的值创建为结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> it : arr) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">HNode</span>(it));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行循环创建哈夫曼树</span></span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//先进行排序</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到最小的结点</span></span><br><span class="line">            <span class="type">HNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//找到次小的结点</span></span><br><span class="line">            <span class="type">HNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建这两个结点的二叉树</span></span><br><span class="line">            <span class="type">HNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HNode</span>(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">//删除已经处理过的结点</span></span><br><span class="line">            list.remove(leftNode);</span><br><span class="line">            list.remove(rightNode);</span><br><span class="line">            <span class="comment">//将其父节点加入链表</span></span><br><span class="line">            list.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回赫夫曼树的根节点</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(HNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        System.out.println(root.value);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)</span><br><span class="line">            traversal(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)</span><br><span class="line">            traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HNode</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;HNode&gt;&#123;</span><br><span class="line">    <span class="comment">//结点的权</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">//结点的左右子节点</span></span><br><span class="line">    HNode left,right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HNode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(HNode o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.value &gt; o.value)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.value == o.value)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Override</span></span><br><span class="line">    <span class="comment">// public boolean equals(Object obj) &#123;</span></span><br><span class="line">    <span class="comment">//     Node node = (Node) obj;</span></span><br><span class="line">    <span class="comment">//     if(this.value == node.value)</span></span><br><span class="line">    <span class="comment">//         return true;</span></span><br><span class="line">    <span class="comment">//     return false;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://c.biancheng.net/view/3398.html">C语言中文网</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2022/09/16/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/09/16/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。</p><span id="more"></span><ul><li><p>堆排序是一种选择排序 它的最坏 最好 平均时间复杂度均为O(nlogn) 是一种不稳定排序</p></li><li><p>堆具有以下性质的完全二叉树 每个结点的值都大于或者等于其左右子节点值<br>称为大顶堆  <strong>没有要求结点的左子节点的值和右子节点的值的大小关系</strong></p></li><li><p>每个结点的值都小于或等于其左右子节点的值 称为小顶堆</p></li></ul><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性 使得每次从无序中选择最大记录(最小记录)变得简单</p><ul><li>将待排序的序列构造成一个最大堆 此时序列的最大值为根节点</li><li>一次将根节点与待排序序列的最后一个元素交换</li><li>再维护从根节点到该元素的前一个结点为最大堆 如此往复 最终得到一个递增序列</li></ul><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素。</li><li>再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys ≤ R[n-1].key</li><li>由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。</li><li>直到无序区只有一个元素为止。</li></ul><p><a href="http://www.rmboot.com/HeapSort.html">快速排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;             </span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr  排序数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//第一个非叶子结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> (len -<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//对非叶子结点逐个判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            adjustHeap(i,len,arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 进行堆处理的非叶子节点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len  数组的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> len,<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//非叶子节点的左子节点下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (index &lt;&lt; <span class="number">1</span>) +<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//非叶子节点的右子节点下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//左右节点较大值的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果下标超出范围 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; len) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//获取较大数的下标</span></span><br><span class="line">        <span class="keyword">if</span>(right &lt;= len &amp;&amp; arr[right] &gt; arr[left])</span><br><span class="line">            maxIndex = right;</span><br><span class="line">        <span class="comment">//如果子节点的值大于根节点的值</span></span><br><span class="line">        <span class="comment">//将其交换  再检测交换后子树的堆</span></span><br><span class="line">        <span class="keyword">if</span>(arr[maxIndex] &gt; arr[index])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(maxIndex,index,arr);</span><br><span class="line">            adjustHeap(maxIndex, len, arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> maxIndex,<span class="type">int</span> index,<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[maxIndex];</span><br><span class="line">        arr[maxIndex] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/124885051">知乎-developer1024</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2022/08/13/HashTable/"/>
      <url>/2022/08/13/HashTable/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>哈希表也叫散列表，哈希表是一种数据结构，它提供了快速的插入操作和查找操作，无论哈希表总中有多少条数据，插入和查找的时间复杂度都是为O(1)，因为哈希表的查找速度非常快，所以在很多程序中都有使用哈希表，例如拼音检查器</p><span id="more"></span><p>哈希表采用的是一种转换思想，其中一个中要的概念是如何将「键」或者「关键字」转换成数组下标？在哈希表中，这个过程有哈希函数来完成，但是并不是每个「键」或者「关键字」都需要通过哈希函数来将其转换成数组下标，有些「键」或者「关键字」可以直接作为数组的下标。</p><h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><blockquote><p>哈希函数的作用是帮我们把非int的「键」或者「关键字」转化成int，可以用来做数组的下标</p></blockquote><p>哈希函数就是一种<strong>映射</strong>，是从关键字到存储地址的映射。 通常，包含哈希函数的算法的算法复杂度都假设为O(1)，这就是为什么在哈希表中搜索数据的时间复杂度会被认为是”平均为O(1)的复杂度”.</p><ul><li>哈希函数的定义域必须包括需要存储的全部关键码，而如果哈希表允许有m个地址时，其值域必须在0 到m-1之间</li><li>哈希函数计算出来的地址能均匀分布在整个空间中</li><li>哈希函数应该比较简单</li></ul><h2 id="除留余数法（最常用）"><a href="#除留余数法（最常用）" class="headerlink" title="除留余数法（最常用）"></a>除留余数法（最常用）</h2><p>函数：Hash（key）&#x3D;key MOD p （p&lt;&#x3D;m m为表长），求出来的hash(key)就为存储该key的下标</p><p>例如有一下数据{2, 4, 6, 8, 9}<br>表长为10，也就是数组容量为10</p><h2 id="直接定制法（常用）"><a href="#直接定制法（常用）" class="headerlink" title="直接定制法（常用）"></a>直接定制法（常用）</h2><p>取关键字的某个线性函数为散列地址(A、B为常数)：Hash（Key）&#x3D; A*Key + B<br>优点：简单、均匀<br>缺点：需要事先知道关键字的分布情况<br>适用场景：适合查找较小数据范围且连续的情况</p><h2 id="平方取中法（少）"><a href="#平方取中法（少）" class="headerlink" title="平方取中法（少）"></a>平方取中法（少）</h2><p>如果关键字的每一位都有某些数字重复出现频率很高的现象，可以先求关键字的平方值，通过平方扩大差异，而后取中间数位作为最终存储地址。<br>使用举例<br>比如key&#x3D;1234 1234^2&#x3D;1522756 取227作hash地址<br>比如key&#x3D;4321 4321^2&#x3D;18671041 取671作hash地址<br>适用场景：事先不知道数据并且数据长度较小的情况</p><h1 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h1><p>即不同的key通过同一哈希函数产生了相同的哈希位置，H（key1）&#x3D;H（key2），例如我们在除留余数法中的例子，如果此时插入一个12，其hash(12)为2，此时下标为2的位置已经有元素，此时就会产生哈希冲突</p><h1 id="处理哈希冲突"><a href="#处理哈希冲突" class="headerlink" title="处理哈希冲突"></a>处理哈希冲突</h1><h2 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h2><blockquote><p>从计算的哈希位置开始，往后找到第一个空闲的位置存放数据</p></blockquote><p><strong>待补充</strong></p><h2 id="开散列"><a href="#开散列" class="headerlink" title="开散列"></a>开散列</h2><blockquote><p>开散列方法又叫链地址法，哈希表中存储的是链表的头结点。具有相同的哈希地址会存放在同一链表中，每个链表中的元素都具有相同的哈希地址。</p></blockquote><p><img src="/2022/08/13/HashTable/%E5%BC%80%E6%95%A3%E5%88%97.png" alt="开散列"></p><p>该哈希表示由指针数组来组成的，每个数组中的元素都是一个链表的头指针。从该表中我们可以看出，产生哈希冲突的元素并不会占用其他元素的位置，每个链表中的元素都是哈希冲突的元素</p><ul><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHashTable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个哈希表</span></span><br><span class="line">        <span class="type">HashTab</span> <span class="variable">hashTab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTab</span>();</span><br><span class="line">        <span class="comment">// 创建几个数据</span></span><br><span class="line">        <span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">1</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">2</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">3</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">4</span>, <span class="string">&quot;l2&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">5</span>, <span class="string">&quot;l3&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">7</span>, <span class="string">&quot;l3&quot;</span>);</span><br><span class="line">        <span class="comment">// 加入数据</span></span><br><span class="line">        hashTab.add(p1);</span><br><span class="line">        hashTab.add(p2);</span><br><span class="line">        hashTab.add(p3);</span><br><span class="line">        hashTab.add(p4);</span><br><span class="line">        hashTab.add(p5);</span><br><span class="line">        hashTab.add(p6);</span><br><span class="line">        <span class="comment">// 遍历哈希表</span></span><br><span class="line">        hashTab.list();</span><br><span class="line">        <span class="comment">//查找数据</span></span><br><span class="line">        System.out.println(hashTab.search(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//删除数据</span></span><br><span class="line">        hashTab.delete(<span class="number">1</span>);</span><br><span class="line">        hashTab.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 编写哈希表 用于管理链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTab</span> &#123;</span><br><span class="line">    <span class="comment">// 初始容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 存储数据的链表数组</span></span><br><span class="line">    PeoLinkedList[] peoLinkedLists;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 无参构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashTab() &#123;</span><br><span class="line">        peoLinkedLists = <span class="keyword">new</span> <span class="title class_">PeoLinkedList</span>[capacity];</span><br><span class="line">        init(peoLinkedLists);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 有参构造方法 提供初始化容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashTab(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        peoLinkedLists = <span class="keyword">new</span> <span class="title class_">PeoLinkedList</span>[capacity];</span><br><span class="line">        init(peoLinkedLists);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始化链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(PeoLinkedList[] peoLinkedLists)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            peoLinkedLists[i] = <span class="keyword">new</span> <span class="title class_">PeoLinkedList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取存储链表的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getListNo</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(People p)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取存储链表的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getListNo(p.id);</span><br><span class="line">        <span class="comment">// 存储数据</span></span><br><span class="line">        peoLinkedLists[index].add(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 查找对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> People <span class="title function_">search</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取存储链表的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getListNo(id);</span><br><span class="line">        <span class="comment">// 查找数据</span></span><br><span class="line">        <span class="keyword">return</span> peoLinkedLists[index].search(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 删除对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取存储链表的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getListNo(id);</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        peoLinkedLists[index].delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 遍历哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; peoLinkedLists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (peoLinkedLists[i].getHead() == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            peoLinkedLists[i].list();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个类</span></span><br><span class="line"><span class="comment"> * 编写一个链表 往其中添加数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeoLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// 头指针 用于指向第一个数据</span></span><br><span class="line">    <span class="keyword">private</span> People head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用于往链表中添加数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(People p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">People</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">while</span> (cur.next != <span class="literal">null</span>)</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            cur.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用于遍历该链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(cur.toString());</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取头指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> People <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 查找对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> People <span class="title function_">search</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">People</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.id == id)</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 删除对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">            <span class="type">People</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">            cur.next = head;</span><br><span class="line">            <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.next.id == id)</span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个自定义类</span></span><br><span class="line"><span class="comment"> * 往哈希表中存储该类信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    People next;</span><br><span class="line">   </span><br><span class="line">    People()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    People(<span class="type">int</span> id, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id + <span class="string">&quot; &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashTable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2022/08/12/BinarySearch/"/>
      <url>/2022/08/12/BinarySearch/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>二分查找是一个对<strong>有序列表</strong>进行查找的一个算法</p><span id="more"></span><p>二分查找的实现原理非常简单，首先要有一个有序的列表。但是如果没有，则该怎么办？可以使用排序算法进行排序。</p><p>以升序数列为例，比较一个元素与数列中的中间位置的元素的大小，如果比中间位置的元素大，则继续在后半部分的数列中进行二分查找；如果比中间位置的元素小，则在数列的前半部分进行比较；如果相等，则找到了元素的位置。每次比较的数列长度都会是之前数列的一半，直到找到相等元素的位置或者最终没有找到要找的元素</p><h1 id="二分法的第一种写法"><a href="#二分法的第一种写法" class="headerlink" title="二分法的第一种写法"></a>二分法的第一种写法</h1><p>第一种写法定义target在左闭右闭的区间内  也就是[left,right]<br>区间的定义决定了二分法的写法   因为target在[left,right]的区间内</p><ul><li>while(left &lt;&#x3D; right) 要使用 &lt;&#x3D;  就要保证left &#x3D;&#x3D; right 是有意义的</li><li>在这种情况下  right要赋值为mid-1   因为这个nums[mid]一定不等于target  那么接下来要查找的左区间结束下标位置就是mid-1<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;       </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">else</span> </span><br><span class="line">            <span class="variable">right</span> <span class="operator">=</span> mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二分法的第二种写法"><a href="#二分法的第二种写法" class="headerlink" title="二分法的第二种写法"></a>二分法的第二种写法</h1><p>第一种写法定义target在左闭右开的区间内  也就是[left,right)<br>区间的定义决定了二分法的写法   因为target在[left,right)的区间内</p><ul><li>while(left &lt; right) 因为在区间[left,right)  left &#x3D;&#x3D; right 是没有意义的</li><li>在这种情况下  right要赋值为mid  即下一个查询区间不会去比较nums[mid]<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length ;    <span class="comment">//区别一   </span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;        <span class="comment">//区别二</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">else</span> </span><br><span class="line">            <span class="variable">right</span> <span class="operator">=</span> mid;        <span class="comment">//区别三</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ul><li>递归<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">22</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">66</span>,<span class="number">88</span>&#125;;</span><br><span class="line">        <span class="comment">//查找函数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> search(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,<span class="number">34</span>);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 二分查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//获得中间下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>; <span class="comment">//防止整数型溢出</span></span><br><span class="line">        <span class="comment">//如果找到直接返回下标</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="comment">//如果中间值大于目标值 则左递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            <span class="keyword">return</span>  search(nums, left, mid-<span class="number">1</span>, target);</span><br><span class="line">        <span class="comment">//如果中间值小于目标值 则右递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            <span class="keyword">return</span> search(nums, mid+<span class="number">1</span>, right, target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="相关题目推荐"><a href="#相关题目推荐" class="headerlink" title="相关题目推荐"></a>相关题目推荐</h1><a href="/2023/02/21/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="704.二分查找">704.二分查找</a> <p><a href="https://leetcode.cn/problems/binary-search/">leetcode地址</a><br></p><a href="/2023/02/21/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/" title="35.搜索插入位置">35.搜索插入位置</a><p><a href="https://leetcode.cn/problems/search-insert-position/">leetcode地址</a><br></p><a href="/2023/02/21/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/" title="34.在排序数组中查找元素的第一个和最后一个位置">34.在排序数组中查找元素的第一个和最后一个位置</a> <p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">leetcode地址</a><br></p><a href="/2023/02/22/x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/" title="69.x的平方根">69.x的平方根</a> <p><a href="https://leetcode.cn/problems/sqrtx/">leetcode地址</a><br></p><a href="/2023/02/22/%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%A0%B9/" title="367.有效的完全平方根">367.有效的完全平方根</a> <p><a href="https://leetcode.cn/problems/valid-perfect-square/">leetcode地址</a><br></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基数排序</title>
      <link href="/2022/08/12/RadixSort/"/>
      <url>/2022/08/12/RadixSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数</p><span id="more"></span><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>找到最大数的位置 决定了循环几轮</li><li>将数组中的数每轮按照个,十,百等位数放入相应的数组(桶)中</li><li>在将其按顺序取出</li><li>循环结束时便排好了序</li></ul><p><a href="http://www.rmboot.com/RadixSort.html">基数排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基数排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//找到最大的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> findMax(nums);</span><br><span class="line">        <span class="comment">//获得最大数的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建二维数组 作为n个桶</span></span><br><span class="line">        <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用一维数组记录桶中元素的个数</span></span><br><span class="line">        <span class="type">int</span>[] numOfBucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//进行基数排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,n = <span class="number">1</span>;i &lt; maxLength;i++, n*=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="comment">//逐个获取数字的个位数 并存入桶中</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> nums[j]/n % <span class="number">10</span>;</span><br><span class="line">                bucket[digit][numOfBucket[digit]] = nums[j];</span><br><span class="line">                numOfBucket[digit]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从桶中挨个取出数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; numOfBucket.length;k++)&#123;</span><br><span class="line">                <span class="comment">//如果桶中数据不为0则取出</span></span><br><span class="line">                <span class="keyword">if</span>(numOfBucket[k] != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;l &lt; numOfBucket[k];l++)&#123;</span><br><span class="line">                        nums[index++] = bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                numOfBucket[k] = <span class="number">0</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 找到最大的数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max)</span><br><span class="line">                max = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2022/08/12/QuickSort/"/>
      <url>/2022/08/12/QuickSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法</p><span id="more"></span><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</p></li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">快速排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">//测试数组</span></span><br><span class="line">         <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">         <span class="comment">//排序函数</span></span><br><span class="line">         sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">         <span class="comment">//打印结果</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">             System.out.println(i);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 快速排序</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//左下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//右下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="comment">//获取基准值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[(left+right) /<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="comment">//在左边找到一个大于基准值的值</span></span><br><span class="line">            <span class="keyword">while</span>(nums[l] &lt; pivot)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="comment">//在右边找到一个小于基准值的值</span></span><br><span class="line">            <span class="keyword">while</span>(nums[r] &gt; pivot)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="comment">//如果l大于r 则表示基准值左边都小于基准则 右边则都大于</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, l, r);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//避免与基准值相同的值一直交换</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l] == pivot)</span><br><span class="line">                r--; </span><br><span class="line">            <span class="keyword">if</span>(nums[r] == pivot)</span><br><span class="line">                l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止栈溢出</span></span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左递归</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; r)</span><br><span class="line">            sort(nums, left, r);</span><br><span class="line">        <span class="comment">//右递归</span></span><br><span class="line">        <span class="keyword">if</span>(right &gt; l)</span><br><span class="line">            sort(nums, l, right);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 交换两个数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        temp = nums[l];</span><br><span class="line">        nums[l] = nums[r];</span><br><span class="line">        nums[r] = temp;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2022/08/11/MergeSort/"/>
      <url>/2022/08/11/MergeSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用</p><span id="more"></span><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）</li><li>自下而上的迭代</li></ul><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p></li><li><p>重复步骤 3 直到某一指针达到序列尾；</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p></li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">归并排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序的辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] aux;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自底向上的归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> [] a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">//分配与数组相等的空间</span></span><br><span class="line">        aux = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">        <span class="comment">// sort(a,0,a.length-1);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> <span class="number">1</span>; sz &lt; N;sz = sz+sz)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>;lo &lt; N - sz;lo += sz+sz)&#123;</span><br><span class="line">                merge(a, lo, lo+sz-<span class="number">1</span>,Math.min(lo+sz+sz-<span class="number">1</span>, N));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 自顶向上的归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// private static void  sort(int[] a,int lo,int hi) &#123;</span></span><br><span class="line">    <span class="comment">//     if(hi &lt;= lo)</span></span><br><span class="line">    <span class="comment">//         return;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int mid = lo + (hi - lo)/2;</span></span><br><span class="line">    <span class="comment">//     //将左边排序</span></span><br><span class="line">    <span class="comment">//     sort(a, lo, mid);</span></span><br><span class="line">    <span class="comment">//     //将右边排序</span></span><br><span class="line">    <span class="comment">//     sort(a, mid+1, hi);</span></span><br><span class="line">    <span class="comment">//     merge(a, lo ,mid,hi);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> lo,<span class="type">int</span> mid,<span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将所有元素复制到辅助数组中 备份数据 在原数组中修改 避免数据丢失</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo;k &lt;= hi;k++)&#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo;k &lt;= hi;k++)&#123;</span><br><span class="line">            <span class="comment">//左边用尽取右边数组</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++];</span><br><span class="line">            <span class="comment">//右边用尽取左边数组</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi)     a[k] = aux[i++];</span><br><span class="line">            <span class="comment">//正常比较 取较小数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aux[j]  &lt; aux[i])   a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2022/08/11/ShellSort/"/>
      <url>/2022/08/11/ShellSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法</p><span id="more"></span><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1</li><li>按增量序列个数 k，对序列进行 k 趟排序</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度</li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">希尔排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellionSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 希尔排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 确定间隔 取3*x+1 分组 </span></span><br><span class="line">        <span class="keyword">while</span>(h &lt; <span class="number">3</span>/N) h = <span class="number">3</span>*h+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当 间隔减为1之前 对每个组进行组内排序</span></span><br><span class="line">        <span class="comment">//在减为1之前 对组内排序的结果是整个数组大致有序</span></span><br><span class="line">        <span class="comment">//最后对整个数组进行插入排序</span></span><br><span class="line">        <span class="comment">//希尔排序的本质是插入排序  插入排序在数组大致有序的情况下拥有最高性能</span></span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h;i &lt; N;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &gt;= h&amp;&amp;nums[j] &lt; nums[j-h];j-=h)&#123;</span><br><span class="line">                    swap(nums, j, j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums , <span class="type">int</span> index_1,<span class="type">int</span> index_2)</span>&#123;</span><br><span class="line">        <span class="comment">//交换值相同时  不交换</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index_1] == nums[index_2])</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index_1];</span><br><span class="line">        nums[index_1] = nums[index_2];</span><br><span class="line">        nums[index_2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2022/08/11/InsertionSort/"/>
      <url>/2022/08/11/InsertionSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p><span id="more"></span><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">插入排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">//测试数组</span></span><br><span class="line">         <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">         <span class="comment">//排序函数</span></span><br><span class="line">         sort(nums);</span><br><span class="line">         <span class="comment">//打印结果</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">             System.out.println(i);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="comment">// 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录要插入的数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从已经排序的序列最右边的开始比较，找到比其小的数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存在比其小的数，插入</span></span><br><span class="line">            <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2022/08/11/SelectionSort/"/>
      <url>/2022/08/11/SelectionSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好</p><span id="more"></span><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li><li>重复第二步，直到所有元素均排序完毕</li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">选择排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试数组</span></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">33</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//排序函数</span></span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//一层循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            <span class="comment">//暂存目前下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>;j &lt; N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[min])</span><br><span class="line">                    <span class="comment">//当前值小于之前的最小值时 更新下标</span></span><br><span class="line">                    min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从头到尾将最小值放置</span></span><br><span class="line">            swap(nums, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums , <span class="type">int</span> index_1,<span class="type">int</span> index_2)</span>&#123;</span><br><span class="line">        <span class="comment">//交换值相同时  不交换</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index_1] == nums[index_2])</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index_1];</span><br><span class="line">        nums[index_1] = nums[index_2];</span><br><span class="line">        nums[index_2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2022/08/11/BubbleSort/"/>
      <url>/2022/08/11/BubbleSort/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法</p><span id="more"></span><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><p>冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来<br>说并没有什么太大作用。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p><a href="http://www.rmboot.com/ComparisonSort.html">冒泡排序可视化</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//用于测试的数组</span></span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        sort(arr);</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2022/08/11/Recursion/"/>
      <url>/2022/08/11/Recursion/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>递归(Recursion)是一种解决问题的有效方法 在递归过程中 函数将自身作为子例程调用</p></blockquote><span id="more"></span><p>递归的思想是把一个大型复杂问题层层转化为一个与原问题规模更小的问题，问题被拆解成子问题后，递归调用继续进行，直到子问题无需进一步递归就可以解决的地步为止。</p><p><img src="/2022/08/11/Recursion/Recursion.png" alt="Recursion"></p><h1 id="什么时候考虑递归"><a href="#什么时候考虑递归" class="headerlink" title="什么时候考虑递归"></a>什么时候考虑递归</h1><ul><li>当问题和子问题具有递推关系 比如杨辉三角 计算阶乘等</li><li>具有递归性质的数据结构 比如链表 树 图</li><li>反向性问题  比如取反</li></ul><h1 id="递归需要遵守的重要规则"><a href="#递归需要遵守的重要规则" class="headerlink" title="递归需要遵守的重要规则"></a>递归需要遵守的重要规则</h1><ul><li>执行一个方法时 就创建一个新的受保护的独立空间</li><li>方法的局部变量是独立的 不会相互影响</li><li>如果方法中使用的引用类型变量(数组等) 就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近 否则就是无限递归</li><li>当一个方法执行完毕 或者遇到return 就会返回 遵守谁调用 就将结果返回给谁 同时当方法执行完毕或者返回时 该方法也就执行完毕</li></ul><h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h1><blockquote><p>尾递归函数是递归函数的一种，其中递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用</p></blockquote><p>尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。可以理解为，在程序执行到递归函数最后一条递归调用指令时回收了当前的栈空间（其实是复用了当前的栈空间）</p><h1 id="采用递归解法的几个经典问题"><a href="#采用递归解法的几个经典问题" class="headerlink" title="采用递归解法的几个经典问题"></a>采用递归解法的几个经典问题</h1><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">factorial</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(fact(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n * fact(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="斐波纳契数"><a href="#斐波纳契数" class="headerlink" title="斐波纳契数"></a>斐波纳契数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(fib(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EightQueen</span> &#123;</span><br><span class="line">    <span class="comment">//定义皇后的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">QUEEN_NUM</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//定义一个数组 保存皇后放置位置的结果</span></span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[QUEEN_NUM];</span><br><span class="line">    <span class="comment">//总解法数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EightQueen</span> <span class="variable">eightQueen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EightQueen</span>();</span><br><span class="line">        <span class="comment">//从第一行开始放置</span></span><br><span class="line">        eightQueen.place(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//打印总解法数</span></span><br><span class="line">        System.out.println(eightQueen.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将皇后的位置输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//只有得到解时才会打印 所以count可以++</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : array)</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 查看我们放置第n个皇后 就去检测该皇后是否与前面已经摆放好了的皇后冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="comment">//判断竖直方向和斜向</span></span><br><span class="line">        <span class="keyword">if</span>(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 放置第n个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">place</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == QUEEN_NUM)&#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次放入皇后 并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; QUEEN_NUM;i++)&#123;</span><br><span class="line">            <span class="comment">//从第一列开始</span></span><br><span class="line">            array[n] = i;</span><br><span class="line">            <span class="comment">//判断是否冲突</span></span><br><span class="line">            <span class="keyword">if</span>(judge(n))&#123;</span><br><span class="line">                <span class="comment">//不冲突 放置下一个</span></span><br><span class="line">                place(n+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//冲突则i++ 将皇后放置到下一列再次判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2022/08/06/Stack/"/>
      <url>/2022/08/06/Stack/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>栈（stack）又名堆栈，是一个先入后出(FIFO-First In Last Out)的有序列表</p><span id="more"></span><ul><li>栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表 允许插入和删除的一端 为变化的一段 称为栈顶(Top) 另一端为固定的一段 称为栈底(Bottom)</li><li>最先放入栈中的元素在栈底 最后放入的元素在栈顶 而删除元素刚好相反 最后放入的元素最先删除 最先放入的元素最后删除</li></ul><p><img src="/2022/08/06/Stack/Stack.png" alt="Stack"></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>子程序的调用 在跳往子程序前 会将下一个指令的地址存到堆栈中 直到子程序执行完后再将地址取出 以回到原来的程序中</li><li>表达式的转换(中缀表达式转后缀表达式)与求值</li><li>双叉树的遍历</li><li>图形的深度优先搜索</li></ul><h1 id="使用数组实现栈"><a href="#使用数组实现栈" class="headerlink" title="使用数组实现栈"></a>使用数组实现栈</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">//指向栈顶</span></span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="comment">//用于存储数据的数组</span></span><br><span class="line">    <span class="type">int</span> arr[];</span><br><span class="line">    <span class="comment">//初始化容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">INIT_CAPACITY</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//记录数量</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 无参构造方法</span></span><br><span class="line"><span class="comment">     * 初始化变量</span></span><br><span class="line"><span class="comment">     * 将数组初始容量设为6 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MyStack()&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        top = -<span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[INIT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当前栈中元素数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> item)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())</span><br><span class="line">            addCapaty();</span><br><span class="line">        arr[++top] = item;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断栈满</span></span><br><span class="line"><span class="comment">     * 将其私有化</span></span><br><span class="line"><span class="comment">     * 仅用于内部判断其是否等于当前最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= INIT_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始容量不够时重新分配空间</span></span><br><span class="line"><span class="comment">     * 将原来的数组复制过来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCapaty</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;EMPTY!!!&quot;</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> arr[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 返回栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 测试方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyStack</span> <span class="variable">myStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStack</span>();</span><br><span class="line">        myStack.push(<span class="number">1</span>);</span><br><span class="line">        myStack.push(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回栈元素数量测试</span></span><br><span class="line">        System.out.println(myStack.capacity());</span><br><span class="line"></span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//返回栈顶元素测试</span></span><br><span class="line">        myStack.push(<span class="number">1</span>);</span><br><span class="line">        System.out.println(myStack.peek());</span><br><span class="line">        System.out.println(myStack.pop());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//栈空出栈测试</span></span><br><span class="line">        System.out.println(myStack.pop()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dijkstra-的双栈算术表达式求值算法"><a href="#Dijkstra-的双栈算术表达式求值算法" class="headerlink" title="Dijkstra 的双栈算术表达式求值算法"></a>Dijkstra 的双栈算术表达式求值算法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Dijkstra 的双栈算术表达式求值算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraDoubleStack</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;(1+((2+3)*(4*5)))&quot;</span>;</span><br><span class="line">        <span class="comment">//存储符号</span></span><br><span class="line">        Stack&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储数字与结果</span></span><br><span class="line">        Stack&lt;Double&gt; vals = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//如果是左括号 跳过</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="comment">//将符号压入栈中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;+&#x27;</span>) </span><br><span class="line">                ops.push(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                ops.push(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                ops.push(s.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                ops.push(s.charAt(i));</span><br><span class="line">            <span class="comment">//遇到右括号时将所需要的两个数弹出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//弹出符号 判断进行哪个运算</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> ops.pop();</span><br><span class="line">                <span class="type">double</span> <span class="variable">v</span> <span class="operator">=</span> vals.pop();</span><br><span class="line">                <span class="keyword">if</span>(ch == <span class="string">&#x27;+&#x27;</span>) v = vals.pop()+v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>) v = vals.pop()-v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;*&#x27;</span>) v = vals.pop()*v;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;/&#x27;</span>) v = vals.pop()/v;</span><br><span class="line">                <span class="comment">//计算好结果后将结果压入vals栈中</span></span><br><span class="line">                vals.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">//不是上述情况则是数字 将其压入vals栈中</span></span><br><span class="line">                vals.push(Double.parseDouble(s.charAt(i)+<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后剩下的就是结果</span></span><br><span class="line">        System.out.println(vals.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无括号的表达式则比较运算符的优先级</li><li>如果当前的操作符的优先级小于等于栈中的操作符</li><li>就pop出两个数和一个符号进行运算 否则直接入栈</li></ul><h1 id="前缀-中缀-后缀表达式"><a href="#前缀-中缀-后缀表达式" class="headerlink" title="前缀 中缀 后缀表达式"></a>前缀 中缀 后缀表达式</h1><h2 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h2><ul><li>前缀表达式又称波兰式 前缀表达式的运算符位于操作数之前</li><li>举例<ul><li>(3+4) x 5 - 6 对应的前缀表达式是- x + 3 4 5 6</li></ul></li><li>计算机求值时从右至左扫描表达式 遇到数字时 将数字压入栈中</li><li>遇到运算符时弹出栈顶的两个数 进行计算 并将结果入栈</li><li>重复以上操作</li></ul><h2 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h2><ul><li>中缀表达式就是常见的运算表达式 </li><li>举例 <ul><li>(3+4)x5-6</li></ul></li><li>中缀表达式的求值是人最熟悉的 但是对计算机来说缺不好操作因此在计算时往往会将其转成其他表达式来操作(一般转成后缀表达式)</li></ul><h2 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h2><ul><li>后缀表达式又称逆波兰表达式 与前缀表达式相似 知识运算符位于操作数之后</li><li>举例<ul><li>(3+4)x5-6 对应的后缀表达式是 34+5 x 6-</li></ul></li><li>计算机求值时 从左至右扫描表达式 遇到数字时 将数字压入堆栈 遇到运算符时 弹出栈顶的两个数 用运算符对他们进行相应的计算 将结果压入栈中 重复以上操作</li></ul><h2 id="中缀表达式转换成后缀表达式"><a href="#中缀表达式转换成后缀表达式" class="headerlink" title="中缀表达式转换成后缀表达式"></a>中缀表达式转换成后缀表达式</h2><ul><li>初始化两个栈 运算符栈s1和存储中间结果的栈s2</li><li>从左至右扫描中缀表达式</li><li>遇到操作数时 将其压入s2</li><li>遇到运算符时 比较其与s1 栈顶运算符的优先级<ul><li>如果s1为空 或栈顶运算符为左括号 则将其直接压入s1</li><li>否则 若优先级比栈顶运算符的高 也将运算符压入s1</li><li>否则 将s1栈顶的运算符弹出并压入s2中</li></ul></li><li>如果遇到括号<ul><li>如果是左括号 直接压入s1</li><li>如果是右括号 则依次弹出s1栈顶的运算符 并压入s2 直到遇到左括号为止 此时将这一对括号丢弃</li></ul></li><li>重复2~5 直到表达式的最右边</li><li>将s1中剩余的运算符依次弹出并压入s2</li><li>依次弹出s2中的元素并输出 结果的逆序即为中缀表达式对应的后缀表达式</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poland</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 给定中缀表达式 即正常的表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;1+((2+3)*4)-5&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转成后缀表达式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">subffixExpression</span> <span class="operator">=</span>  convert(expression);</span><br><span class="line"></span><br><span class="line">        System.out.println(subffixExpression);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 中缀表达书转换成后缀表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">convert</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 数字栈 由于全程没有出栈操作 且最后需要反转 可以用List</span></span><br><span class="line">        ArrayList&lt;String&gt; number = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 符号栈</span></span><br><span class="line">        Stack&lt;String&gt; signal = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 用于拼接数字的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">numberStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 用于遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历该中缀表达式</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            numberStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//如果第一个是数字</span></span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//获得该数字的字符串</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; str.length()&amp;&amp;str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    numberStr += str.charAt(i);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将其加入数组</span></span><br><span class="line">                <span class="keyword">if</span> (numberStr != <span class="string">&quot;&quot;</span>)</span><br><span class="line">                    number.add(numberStr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//是符号时 如果符号栈空 或者是左括号时 直接入符号栈</span></span><br><span class="line">                <span class="keyword">if</span>(signal.isEmpty())</span><br><span class="line">                    signal.push(str.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    signal.push(str.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//如果是右括号时 在遇到左括号之前将符号栈的弹出加入数组</span></span><br><span class="line">                    <span class="keyword">while</span>(!signal.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                        number.add(signal.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将括号去掉</span></span><br><span class="line">                    signal.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//当运算符的优先级更小时将符号栈弹出加入到数组</span></span><br><span class="line">                    <span class="keyword">while</span>(!signal.empty() &amp;&amp; Operation.getValue(signal.peek()) &gt;= Operation.getValue(str.charAt(i)+<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                        number.add(signal.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//再把运算符压入符号栈</span></span><br><span class="line">                    signal.push(str.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; str.length());</span><br><span class="line">        <span class="comment">//遍历完之后如果符号栈还有残留</span></span><br><span class="line">        <span class="comment">//全部弹出加入数组</span></span><br><span class="line">        <span class="keyword">while</span>(!signal.empty())</span><br><span class="line">            number.add(signal.pop());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> number.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 编写一个类 Operation  可以返回一个运算符 对应的优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SUB</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MUL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DIV</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(String operation)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(operation)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LeetCode-相关题目"><a href="#LeetCode-相关题目" class="headerlink" title="LeetCode 相关题目"></a>LeetCode 相关题目</h1><ul><li>Easy<br><a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a><br><br><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列</a><br><br><a href="https://leetcode.cn/problems/next-greater-element-i/">下一个更大元素</a><br><br><a href="https://leetcode.cn/problems/min-stack/">最小栈</a><br></li><li>Medium</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2022/08/03/Queue/"/>
      <url>/2022/08/03/Queue/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>队列(Queue) 是一种采用先进先出(FIFO)策略的抽象数据结构</p><span id="more"></span><ul><li>队列是一个有序列表 可以用数组或是链表来实现</li><li>遵循先入先出的原则 即:先存入队列的数据 要先取出 后存入的要后取出</li><li>通常队列使用链表来进行实现 这样不会有大小的限制</li><li>使用数组实现时可以对下标取余达到对前面出队以后空出的数组空间进行重复利用的效果</li></ul><p><img src="/2022/08/03/Queue/Queue.png" alt="Queue"></p><h1 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a>数组实现队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="comment">//初始化容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="comment">//头指针 用于输出数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">//尾指针 记录末尾数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">//用于实现的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> arr[];</span><br><span class="line">    <span class="comment">//记录存储数据大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> maxSize)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往队列中添加数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">int</span> item)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())</span><br><span class="line">            <span class="comment">//可以抛出异常 直接返回会导致多余的数据忽略</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//添加时的数组下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (++rear) % maxSize;</span><br><span class="line">        arr[index] = item;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队头的数据弹出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        count--; </span><br><span class="line">        <span class="comment">//出队时的数组下标</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (++front) % maxSize;</span><br><span class="line">         <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayQueue</span> <span class="variable">arrayQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//将数据加满</span></span><br><span class="line">        arrayQueue.enqueue(<span class="number">1</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">2</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">3</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">4</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//判断isFull函数是否有用</span></span><br><span class="line">        System.out.println(arrayQueue.isFull());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//全部出队 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(arrayQueue.dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断isEmpty函数是否可用</span></span><br><span class="line">        System.out.println(arrayQueue.isEmpty());</span><br><span class="line">        <span class="comment">//再次入队 判断其循环可用性</span></span><br><span class="line">        arrayQueue.enqueue(<span class="number">6</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">7</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue</span>&lt;Item&gt;&#123;</span><br><span class="line">    <span class="comment">//指向最早添加的结点</span></span><br><span class="line">    <span class="keyword">private</span> Node  first;</span><br><span class="line">    <span class="comment">//指向最近添加的结点</span></span><br><span class="line">    <span class="keyword">private</span> Node  last;</span><br><span class="line">    <span class="comment">//队列中的元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="comment">//定义了结点的嵌套类</span></span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        <span class="comment">//表尾添加元素</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldlast</span> <span class="operator">=</span> last;</span><br><span class="line">        last = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        last.item = item;</span><br><span class="line">        last.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) first = last;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            oldlast.next = last;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//表头删除元素</span></span><br><span class="line">        <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> first.item;</span><br><span class="line">        first = first.next;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) last = <span class="literal">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组</title>
      <link href="/2022/08/02/spraseArray/"/>
      <url>/2022/08/02/spraseArray/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当一个数组中大部分元素为同一个值时 可以使用稀疏数组来保存该数组</p><span id="more"></span><ul><li>稀疏数组的处理方法<ul><li>记录数组一共有几行几列 有多少个不同的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中 从而缩小程序的规模</li></ul></li></ul><p><img src="/2022/08/02/spraseArray/spraseArray.png" alt="spraseArray"></p><ul><li>第一行 保存整个数组的信息 <ul><li>row 有多少行</li><li>col 有多少列</li><li>val 有多少个有效值</li></ul></li><li>其余行分别存储其他有效数的位置<ul><li>row 所在行</li><li>col 所在列</li><li>val 有效值</li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">spraseArray</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个原始数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ROW</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">COL</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[ROW][COL];</span><br><span class="line">        <span class="comment">//设置有效值</span></span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">        arr[<span class="number">6</span>][<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">6</span>] = <span class="number">5</span>;</span><br><span class="line">        arr[<span class="number">5</span>][<span class="number">2</span>] = <span class="number">9</span>;</span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">7</span>;</span><br><span class="line">        arr[<span class="number">6</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//输出原始的二维数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] row : arr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> item : row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,item);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历数组 获取数组中的有效值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//有效值个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ROW;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; COL;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建稀疏数组</span></span><br><span class="line">        <span class="type">int</span> spraseArray[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">        spraseArray[<span class="number">0</span>][<span class="number">0</span>] = ROW;</span><br><span class="line">        spraseArray[<span class="number">0</span>][<span class="number">1</span>] = COL;</span><br><span class="line">        spraseArray[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存取有效值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 用于递增存值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ROW;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; COL;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    spraseArray[count][<span class="number">0</span>] = i;</span><br><span class="line">                    spraseArray[count][<span class="number">1</span>] = j;</span><br><span class="line">                    spraseArray[count][<span class="number">2</span>] = arr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印稀疏数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] row : spraseArray)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> item : row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,item);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将稀疏数组恢复成二维数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取行和列</span></span><br><span class="line">        ROW = spraseArray[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        COL = spraseArray[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//new 一个新的数组</span></span><br><span class="line">        <span class="type">int</span> arr2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[ROW][COL];</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; spraseArray.length;i++)&#123;</span><br><span class="line">            arr2[spraseArray[i][<span class="number">0</span>]][spraseArray[i][<span class="number">1</span>]] = spraseArray[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] row : arr)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> item : row)&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,item);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2022/07/27/Spring-1/"/>
      <url>/2022/07/27/Spring-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring使Java编程对每个人来说都更快，更轻松，更安全。Spring对速度，简单性和生产力的关注使其成为全球最受欢迎的Java框架<br><a href="https://spring.io/">官网</a></p><span id="more"></span><h1 id="Spring-Framework-系统架构"><a href="#Spring-Framework-系统架构" class="headerlink" title="Spring Framework 系统架构"></a>Spring Framework 系统架构</h1><blockquote><p>Spring Framework 是Spring生态圈中最基础的项目 是其他项目的根基</p></blockquote><p><img src="/2022/07/27/Spring-1/SpringFramework%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Spring Framework系统架构图"></p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><blockquote><p>Inversion of Control  控制反转</p></blockquote><ul><li><p>使用对象时，由主动new产生对象转换为由外部提供对象，对象的创建控制权由程序转移到外部 这种思想称为控制反转</p></li><li><p>Spring 技术对Ioc思想进行了实现</p><ul><li>Spring提供了一个容器 称为IoC容器 用来充当IoC思想中的外部</li><li>IoC容器负责对象的创建 初始化等一系列工作 被创建或被管理的对象在IoC中统称Bean<!-- IoC是如何返回用户所需要的对象的呢？ --></li></ul></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>导入spring的坐标spring-context </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Spring配置文件 </p><ul><li>在resources下new一个applicationContext.xml文件</li></ul></li><li><p>配置bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    告诉spring创建对象</span></span><br><span class="line"><span class="comment">    声明bean</span></span><br><span class="line"><span class="comment">    id  对象的自定义名称 唯一值  spring通过这个名称找到对象</span></span><br><span class="line"><span class="comment">    class 类的全限定名称 不能是接口 因为要通过反射机制创建对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    spring 把创建好的对象放入map中 spring框架中有一个map存放对象</span></span><br><span class="line"><span class="comment">    key值是id</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    一个bean标签声明一个对象 </span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    对于非自定义的类 spring也能创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置service与 dao的关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">    name属性表示配置哪一个具体的属性</span></span><br><span class="line"><span class="comment">    ref属性表示参照哪一个bean--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>获取IoC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>获取bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Obejct</span> <span class="variable">o</span> <span class="operator">=</span> (Object)ctx.getBean(id)</span><br></pre></td></tr></table></figure></li></ul><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><blockquote><p>Dependency Injection  依赖注入</p></blockquote><ul><li>在容器中建立bean与bean之间的依赖关系的整个过程 称为依赖注入</li></ul><h3 id="set注入"><a href="#set注入" class="headerlink" title="set注入"></a>set注入</h3><h4 id="简单类型的set注入"><a href="#简单类型的set注入" class="headerlink" title="简单类型的set注入"></a>简单类型的set注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;xx&quot;</span> <span class="attr">class</span> = <span class="string">&quot;yy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">&quot;属性名字&quot;</span>  <span class="attr">value</span> = <span class="string">&quot;此属性的值&quot;</span>/&gt;</span></span><br><span class="line">        一个property只能给一个属性赋值</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义类型的set注入"><a href="#自定义类型的set注入" class="headerlink" title="自定义类型的set注入"></a>自定义类型的set注入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">class</span>=<span class="string">&quot;yyy&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;属性名称&quot;</span> <span class="attr">ref</span> = <span class="string">“bean的id”/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><ul><li><p>构造注入 spring调用有参数构造方法  在创建对象的同时  在构造方法中给属性赋值</p></li><li><p>构造注入使用  <constructor-arg> 标签</constructor-arg></p></li><li><p>标签属性</p><ul><li>name 表示构造方法的形参名</li><li>index 表示构造方法的参数的位置 参数从左往右位置是0.1.2的顺序</li><li>value 构造方法的形参类型是简单类型 使用value</li><li>ref  构造方法的形参类型是引用类型 使用ref<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.pa_03.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;myName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;myAge&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;mySchool&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--   使用index标志--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myStudent2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.pa_03.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mySchool&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    声明school对象--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mySchool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.pa_03.School&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;beijingdaxue&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h3></li></ul></li><li><p>引用类型的自动注入  spring框架根据某些规则可以给引用类型给引用类型赋值</p></li><li><p>使用的规则常用是 byName  byType</p></li><li><p>byName  </p><ul><li>java类中引用类型的属性名和spring容器中<bean> 的id名称一样<br>且数据类型是一致的 这样的容器中的bean spring能够赋值给引用类型</bean></li></ul></li><li><p>语法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span> id = &quot;xx&quot; class = &quot;yyy&quot; autowire = &quot;byName&quot;&gt;</span><br><span class="line">  简单类型属性赋值</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>byType  </p><ul><li>java类中引用类型的数据类型和spring容器中 <bean>的class属性<br>是同源关系的 这样的bean能够赋值给引用类型<br>在byType中 声明bean只能右一个符合条件的</bean></li></ul></li><li><p>同源就是一类的意思</p><ul><li>java中引用类型的数据类型和bean的class的值是一样的</li><li>java类中引用类型的数据类型和bean的class的值是父子类型的</li><li>java类中引用类型的数据类型和bean的class的值是接口和实现类的关系的</li></ul></li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><blockquote><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方<br>式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个<br>热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑<br>的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高<br>了开发的效率。</p></blockquote><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</li><li>Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。</li><li>Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。</li><li>Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。</li><li>Target（目标对象）：织入 Advice 的目标对象.。</li><li>Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</li></ul><h3 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/<span class="strong">**</span></span><br><span class="line"><span class="strong">  <span class="emphasis">* 定义方法  方法是实现切面功能的</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">  *</span> 方法的定义要求</span></span><br><span class="line"><span class="strong">  <span class="emphasis">*      公共方法  public</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">  *</span>      方法没有返回值</span></span><br><span class="line"><span class="strong">  <span class="emphasis">*      方法名称自定义</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">  *</span>      方法可以有参数 也可以没有</span></span><br><span class="line"><span class="strong">  <span class="emphasis">*          如果有 参数不是自定义的  有几个参数可以使用</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">  *</span>/</span></span><br><span class="line"><span class="strong">/**</span></span><br><span class="line"><span class="bullet">  *</span> execution(&lt;修饰符模式&gt;?&lt;返回类型模式&gt;&lt;方法名模式&gt;(&lt;参数模式&gt;)&lt;异常模式&gt;?)</span><br><span class="line"><span class="bullet">  *</span> https://blog.csdn.net/zhuanglicheng/article/details/109110176</span><br><span class="line">  <span class="emphasis">*/</span></span><br><span class="line"><span class="emphasis">/<span class="strong">**</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">  <span class="emphasis">* 指定通知方法中的参数 JoinPoint</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  *</span> JoinPoint  业务方法 要加入切面功能的业务方法</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">  <span class="emphasis">*      作用   可以在通知方法中获取方法执行时的信息  例如方法名称  方法的实参</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  *</span>      如果你的切面功能中需要用到方法的信息 就加入JointPoint</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">  <span class="emphasis">*      这个JoinPoint参数的值是由框架赋予  必须是第一个位置的参数</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  *</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis">  <span class="emphasis">*/</span></span></span></span><br></pre></td></tr></table></figure><ul><li><p>@Aspect  是aspectj框架中的注解</p><ul><li>作用  表示当前类是切面类</li><li>切面类  是用来给业务方法增加功能的类  在这个类中有切面的功能代码</li><li>位置  在类定义的上面</li></ul></li><li><p>@Before 前置通知注解</p><ul><li>属性 value 是切入点表达式 表示切面的功能执行的位置</li><li>位置 在方法上面</li><li>特点<ul><li>在目标方法之前先执行的</li><li>不会改变目标方法的执行结果</li><li>不会影响目标方法的执行</li></ul></li></ul></li><li><p>@AfterReturning 后置通知 方法有参数  推荐Object  参数名自定义</p><ul><li>属性 <ul><li>value 切入点表达式</li><li>returning 自定义的变量  表示目标方法的返回值的 自定义变量名必须和通知方法的形参名一样</li></ul></li><li>位置   方法的上面</li><li>特点<ul><li>在目标方法之后执行的</li><li>能够获取到目标方法的返回值 可以根据这个返回值做不同的处理功能</li><li>可以修改这个返回值  只有当传递的是引用的参数是才会改变  值传递不会改变原有的参数</li></ul></li></ul></li><li><p>@Around 环绕通知 方法必须有一个返回值  推荐使用Object 方法有参数  固定的参数 ProceedingJoinPoint</p><ul><li>属性 value  切入点表达式</li><li>位置 在方法的定义上面</li><li>特点<ul><li>是功能最强的通知</li><li>在目标方法的前和后都能增强功能</li><li>控制目标方法是否被调用执行</li><li>修改原来的目标方法的执行结果 影响最后的调用结果</li></ul></li><li>参数<ul><li>ProceedingJoinPoint  等同于jdk动态代理参数中的Method</li><li>作用  执行目标方法的</li></ul></li><li>返回值  就是目标方法的执行结果 可以被修改<br>环绕通知经常做事务  在目标方法之前开启事务  执行目标方法后提交事务</li></ul></li></ul><h1 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h1><h2 id="bean-配置"><a href="#bean-配置" class="headerlink" title="bean 配置"></a>bean 配置</h2><h3 id="bean-基础配置"><a href="#bean-基础配置" class="headerlink" title="bean 基础配置"></a>bean 基础配置</h3><p><img src="/2022/07/27/Spring-1/bean%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.png" alt="bean基础配置"></p><h3 id="bean-别名配置"><a href="#bean-别名配置" class="headerlink" title="bean 别名配置"></a>bean 别名配置</h3><p><img src="/2022/07/27/Spring-1/bean%E7%9A%84%E5%88%AB%E5%90%8D%E9%85%8D%E7%BD%AE.png" alt="bean的别名配置"></p><h3 id="bean-作用范围配置"><a href="#bean-作用范围配置" class="headerlink" title="bean 作用范围配置"></a>bean 作用范围配置</h3><p><img src="/2022/07/27/Spring-1/bean%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.png" alt="bean基础配置"></p><ul><li>适合交给容器进行管理的bean<ul><li>表现层对象</li><li>业务层对象</li><li>数据层对象</li><li>工具对象</li></ul></li><li>不适合交给容器进行管理的bean<ul><li>封装实体的域对象</li></ul></li></ul><h2 id="bean-实例化"><a href="#bean-实例化" class="headerlink" title="bean 实例化"></a>bean 实例化</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>提供可访问的构造方法</li><li>spring通过反射获得该方法的无参构造方法用以创建对象</li><li>如果无无参构造方法将会报错</li></ul><h3 id="使用静态工厂"><a href="#使用静态工厂" class="headerlink" title="使用静态工厂"></a>使用静态工厂</h3><ul><li>静态工厂  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态工厂创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">id</span> = <span class="string">&quot;orderDao&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;com.kris.factory.OrderDaoFactory&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">factory-method</span>=<span class="string">&quot;getOrderDao&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用实例化工厂"><a href="#使用实例化工厂" class="headerlink" title="使用实例化工厂"></a>使用实例化工厂</h3><ul><li><p>实例工厂</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.factory.UserDaoFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实例化工厂运行的顺序是:</p><ul><li><p>创建实例化工厂对象,对应的是第一行配置</p></li><li><p>调用对象中的方法来创建bean，对应的是第二行配置</p><ul><li><p>factory-bean:工厂的实例对象</p></li><li><p>factory-method:工厂对象中的具体创建对象的方法名</p></li></ul></li></ul></li></ul><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><ul><li>FactoryBean  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回所创建类的Class对象</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>配置  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.factory.UserDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="bean-生命周期"><a href="#bean-生命周期" class="headerlink" title="bean 生命周期"></a>bean 生命周期</h2><ul><li><p>提供生命周期控制方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean初始化对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean销毁前对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置生命周期控制方法</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实现 InitializingBean DisposableBean 接口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bean-的执行流程"><a href="#bean-的执行流程" class="headerlink" title="bean 的执行流程"></a>bean 的执行流程</h3></li><li><p>初始化容器</p><ul><li>创建对象</li><li>执行构造方法</li><li>执行属性注入(set操作)</li><li>执行bean初始化方法</li></ul></li><li><p>使用bean</p><ul><li>执行业务操作</li></ul></li><li><p>关闭&#x2F;销毁容器</p><ul><li>执行bean销毁方法</li></ul></li></ul><h3 id="bean-销毁时机"><a href="#bean-销毁时机" class="headerlink" title="bean 销毁时机"></a>bean 销毁时机</h3><ul><li>容器关闭前触发bean的小销毁</li><li>关闭容器方式<ul><li>手工关闭容器<br>ConfigurableApplicationContext接口close()操作</li><li>注册关闭钩子 在虚拟机退出前先关闭容器再退出虚拟机<br>ConfigurableApplicationContext接口registerShutdownHook()操作</li></ul></li></ul><h2 id="使用注解创建bean"><a href="#使用注解创建bean" class="headerlink" title="使用注解创建bean"></a>使用注解创建bean</h2><ul><li><p>@Component  创建对象的  等同于<bean> 标签的功能</bean></p><ul><li>属性 value 就是对象的名称   也就是bean的id值</li><li>value的值是唯一的 创建的对象在整个spring容器中就一个</li></ul></li><li><p>@Respository  放在dao的实现类上面表示创建dao对象  dao对象是能访问数据库的</p></li><li><p>@Service       放在service的实现类上 创建service对象  </p><ul><li>service对象是做业务处理的 可以有事务等功能的</li></ul></li><li><p>@Controller     放在控制器类上面  创建控制器对象</p><ul><li>控制器对象  能够接受用户参数 显示请求的处理结果</li></ul></li><li><p>@Value  简单类型的属性赋值</p><ul><li>属性  <ul><li>value 是String类型的  表示简单类型的属性值</li></ul></li><li>位置  <ul><li>在属性定义的上面  无需set方法  推荐使用</li><li>在set方法上面</li></ul></li></ul></li><li><p>@AutoWire  spring框架提供的注解  实现引用类型的赋值</p><ul><li>spring 通过注解给引用类型赋值  使用的是自动注入原理  支持byName  </li><li>byType<ul><li>属性requird bool 默认为  true</li><li>requird &#x3D; true 表示引用类型赋值失败 程序报错 并终止执行</li><li>requird &#x3D; false  引用类型如果赋值失败 程序正常执行 引用类型null </li><li>默认为byType自动注入</li><li>使用byName  需要在属性上面加入@Qualifier(value &#x3D; “bean的id”) 表示使用指定名称的bean完成精准赋值</li></ul></li></ul></li><li><p>@Resource  来自jdk中的注解 spring框架提供了对这个注解的功能支持 可以使用它给引用类型赋值</p><ul><li>使用的也是自动注入原理  支持byName  byType  默认是byName</li><li>位置  <ul><li>在属性定义上面  无需set方法  推荐使用</li><li>在set方法上面</li></ul></li></ul></li></ul><h1 id="关于配置文件"><a href="#关于配置文件" class="headerlink" title="关于配置文件"></a>关于配置文件</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    当项目中有许多类时  可以将配置文件按模块进行分类</span></span><br><span class="line"><span class="comment">    创建一个主配置文件  包含其他的配置文件 主配置文件一般不定义对象</span></span><br><span class="line"><span class="comment">    语法</span></span><br><span class="line"><span class="comment">        &lt;import resource = &quot;其他配置文件的路径&quot;/&gt;</span></span><br><span class="line"><span class="comment">        关键字 classpath  表示类路径（class文件所在的目录）</span></span><br><span class="line"><span class="comment">        在配置文件中要指定其他文件的位置 需要使用classpath 告诉spring到哪去加载读取配置文件</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    在包含关系的配置文件中 可以通配符(* ；表示任意字符)</span></span><br><span class="line"><span class="comment">    注意  主的配置文件名称不能包含在通配符的范围内 不然会造成死循环</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:pa_04/applicationContext.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    声明组件扫描器</span></span><br><span class="line"><span class="comment">    base-package 指定注解在你的项目中的包名</span></span><br><span class="line"><span class="comment">    component-scan工作方式  spring 会扫描遍历base-package指定的包</span></span><br><span class="line"><span class="comment">        把包中和子包中的所有类 找到类中的注解 按照注解的功能创建对象  或给属性赋值</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    指定多个包</span></span><br><span class="line"><span class="comment">        - 使用多次组件扫描器</span></span><br><span class="line"><span class="comment">        - 使用分割符(;或,) 分割多个包名</span></span><br><span class="line"><span class="comment">            base-package = &quot;com.kris.pa_01; com.kris.pa_02&quot;</span></span><br><span class="line"><span class="comment">        - 指定父包</span></span><br><span class="line"><span class="comment">            base-package = &quot;com.kris&quot;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">&quot;com.kris.pa_04&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用配置文件 在注解的value中即可使用  &#123;键名&#125;  来表示对应的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:test.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        声明自动代理生成器 使用aspectj框架内部的功能 创建目标的代理对象</span></span><br><span class="line"><span class="comment">        创建代理对象是在内存中实现的  修改目标对象的内存中的结构 创建为代理对象</span></span><br><span class="line"><span class="comment">        所以目标对象就是被修改后的代理对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        aspectj-autoproxy  会把spring容器中的所有目标对象一次性都生成代理对象</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       把数据库的配置信息，写在一个独立的文件，编译修改数据库的配置内容</span></span><br><span class="line"><span class="comment">       spring知道jdbc.properties文件的位置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明数据源DataSource, 作用是连接数据库的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入给DruidDataSource提供连接数据库信息 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    使用属性配置文件中的数据，语法 $&#123;key&#125; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/kris?serverTimezone=UTC<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="symbol">&amp;amp;</span>useSSL=false&quot;</span> /&gt;</span><span class="comment">&lt;!--setUrl()--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a14796542031&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明的是mybatis中提供的SqlSessionFactoryBean类，这个类内部创建SqlSessionFactory的</span></span><br><span class="line"><span class="comment">        SqlSessionFactory  sqlSessionFactory = new ..</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set注入，把数据库连接池付给了dataSource属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myDataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis主配置文件的位置</span></span><br><span class="line"><span class="comment">           configLocation属性是Resource类型，读取配置文件</span></span><br><span class="line"><span class="comment">           它的赋值，使用value，指定文件的路径，使用classpath:表示文件的位置</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatisConfig.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建dao对象，使用SqlSession的getMapper（StudentDao.class）</span></span><br><span class="line"><span class="comment">        MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定SqlSessionFactory对象的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定包名， 包名是dao接口所在的包名。</span></span><br><span class="line"><span class="comment">            MapperScannerConfigurer会扫描这个包中的所有接口，把每个接口都执行</span></span><br><span class="line"><span class="comment">            一次getMapper()方法，得到每个接口的dao对象。</span></span><br><span class="line"><span class="comment">            创建好的dao对象放入到spring的容器中的。 dao对象的默认名称是 接口名首字母小写</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.kris.dao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kris.service.Impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/07/26/Git-1/"/>
      <url>/2022/07/26/Git-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到非常大的项目的所有内容。</p><span id="more"></span><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li><p>实现跨区域多人协同开发</p></li><li><p>追踪和记载一个或者多个文件的历史记录</p></li><li><p>组织和保护你的源代码和文档</p></li><li><p>统计工作量</p></li><li><p>并行开发、提高开发效率</p></li><li><p>跟踪记录整个软件的开发过程</p></li><li><p>减轻开发人员的负担，节省时间，同时降低人为错误</p></li></ul><h2 id="常见版本控制"><a href="#常见版本控制" class="headerlink" title="常见版本控制"></a>常见版本控制</h2><ul><li><p>Git</p></li><li><p>SVN（Subversion）</p></li><li><p>CVS（Concurrent Versions System）</p></li><li><p>VSS（Micorosoft Visual SourceSafe）</p></li><li><p>TFS（Team Foundation Server）</p></li><li><p>Visual Studio Online</p></li></ul><p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p><h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><h3 id="本地版本控制"><a href="#本地版本控制" class="headerlink" title="本地版本控制"></a>本地版本控制</h3><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><h3 id="集中版本控制"><a href="#集中版本控制" class="headerlink" title="集中版本控制"></a>集中版本控制</h3><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改<br>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p>每个人都拥有全部的代码！安全隐患！</p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><h3 id="Git-和-SVN的主要区别"><a href="#Git-和-SVN的主要区别" class="headerlink" title="Git 和 SVN的主要区别"></a>Git 和 SVN的主要区别</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><h1 id="Git-环境配置"><a href="#Git-环境配置" class="headerlink" title="Git 环境配置"></a>Git 环境配置</h1><h2 id="常用Linux命令"><a href="#常用Linux命令" class="headerlink" title="常用Linux命令"></a>常用Linux命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>cd</td><td>改变目录</td></tr><tr><td>cd..</td><td>回退到上个目录，直接cd进入默认目录</td></tr><tr><td>pwd</td><td>显示当前所在的目录路径</td></tr><tr><td>ls(ll)</td><td>都是列出当前目录中的所有文件 只不过ll列出的内容更为详细</td></tr><tr><td>touch</td><td>新建一个文件</td></tr><tr><td>rm</td><td>删除一个文件</td></tr><tr><td>mkdir</td><td>新建一个文件夹</td></tr><tr><td>rm-r</td><td>删除一个文件夹</td></tr><tr><td>rm-rf</td><td>强制删除</td></tr><tr><td>mv</td><td>移动文件  mv 移动文件 目标文件夹</td></tr><tr><td>reset</td><td>重新初始化终端</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>history</td><td>查看命令历史</td></tr><tr><td>help</td><td>帮助</td></tr><tr><td>exit</td><td>退出</td></tr><tr><td>#</td><td>注释</td></tr></tbody></table><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看配置</span></span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统config</span></span><br><span class="line">git config <span class="params">--system</span> <span class="params">--list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前用户(global)配置</span></span><br><span class="line">git config <span class="params">--global</span> <span class="params">--list</span></span><br></pre></td></tr></table></figure><h2 id="Git配置相关文件"><a href="#Git配置相关文件" class="headerlink" title="Git配置相关文件"></a>Git配置相关文件</h2><ul><li><p>Git\etc\gitconfig  ：Git 安装目录下的 gitconfig     –system 系统级</p></li><li><p>C:\Users\Administrator\ .gitconfig    只适用于当前登录用户的配置  –global 全局</p></li></ul><h2 id="设置用户名和邮箱"><a href="#设置用户名和邮箱" class="headerlink" title="设置用户名和邮箱"></a>设置用户名和邮箱</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git config --global <span class="literal">user</span>.<span class="keyword">name</span> <span class="string">&quot;username&quot;</span>  <span class="comment">#名称</span></span><br><span class="line">git config --global <span class="literal">user</span>.email email   <span class="comment">#邮箱</span></span><br></pre></td></tr></table></figure><p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p><h1 id="Git-基本理论"><a href="#Git-基本理论" class="headerlink" title="Git 基本理论"></a>Git 基本理论</h1><h2 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage&#x2F;Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。</p><ul><li><p>Workspace：工作区，就是你平时存放项目代码的地方</p></li><li><p>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</p></li><li><p>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</p></li><li><p>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p></li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ul><li><p>在工作目录中添加、修改文件；</p></li><li><p>将需要进行版本管理的文件放入暂存区域；</p></li><li><p>将暂存区域的文件提交到git仓库。</p></li></ul><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="/2022/07/26/Git-1/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Git工作流程"></p><h1 id="Git-项目搭建"><a href="#Git-项目搭建" class="headerlink" title="Git 项目搭建"></a>Git 项目搭建</h1><h2 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h2><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><ul><li><p>创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="variable">$ </span>git init</span><br></pre></td></tr></table></figure></li><li><p>执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p></li></ul><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><ul><li>另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line">$ git <span class="keyword">clone</span> <span class="title">[url</span>]  <span class="comment"># https://gitee.com/kuangstudy/openclass.git</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Git-文件操作"><a href="#Git-文件操作" class="headerlink" title="Git 文件操作"></a>Git 文件操作</h1><h2 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h2><blockquote><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p></blockquote><ul><li><p>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p></li><li><p>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</p></li><li><p>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</p></li><li><p>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</p></li></ul><h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看指定文件状态</span></span><br><span class="line"><span class="attribute">git</span> status<span class="meta"> [filename]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看所有文件状态</span></span><br><span class="line"><span class="attribute">git</span> status</span><br><span class="line"></span><br><span class="line"><span class="comment"># git add .                  添加所有文件到暂存区</span></span><br><span class="line"><span class="comment"># git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息</span></span><br></pre></td></tr></table></figure><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><blockquote><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等<br>在主目录下建立”.gitignore”文件，此文件有如下规则：</p></blockquote><ul><li><p>忽略文件中的空行或以井号（#）开始的行将会被忽略。</p></li><li><p>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</p></li><li><p>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</p></li><li><p>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</p></li><li><p>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为注释</span></span><br><span class="line">*.txt        <span class="comment">#忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span></span><br><span class="line">!lib.txt     <span class="comment">#但lib.txt除外</span></span><br><span class="line">/temp        <span class="comment">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span></span><br><span class="line">build<span class="regexp">/       #忽略build/</span>目录下的所有文件</span><br><span class="line">doc<span class="regexp">/*.txt    #会忽略 doc/</span>notes.txt 但不包括 doc<span class="regexp">/server/</span>arch.txt</span><br></pre></td></tr></table></figure><h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><p>git分支常用指令</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-<span class="keyword">name</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-<span class="keyword">name</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git <span class="keyword">push</span> origin --<span class="keyword">delete</span> [branch-<span class="keyword">name</span>]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p><p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Element</title>
      <link href="/2022/07/19/Element/"/>
      <url>/2022/07/19/Element/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一套基于Vue 的网站组件库 用于快速构建网页</p><p><a href="https://element.eleme.cn/#/zh-CNListener">官网</a></p><span id="more"></span><h1 id="Element-快速入门"><a href="#Element-快速入门" class="headerlink" title="Element 快速入门"></a>Element 快速入门</h1><ul><li>引入Element的css js 文件 和Vue.js<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;element-ui/lib/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>创建Vue核心对象<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>官网复制Element组件代码<h1 id="Element-布局"><a href="#Element-布局" class="headerlink" title="Element 布局"></a>Element 布局</h1></li><li>Element 中有两种布局方式<ul><li><p>Layout布局 通过基础的24分栏 迅速简便的创建布局<br><img src="/2022/07/19/Element/Layout%E5%B8%83%E5%B1%80.png" alt="Layout布局"></p></li><li><p>Container 布局容器 用于布局的容器组件 方便快速的搭建页面的基本结构</p><p><img src="/2022/07/19/Element/Container%E5%B8%83%E5%B1%80.png" alt="Container布局"></p></li></ul></li></ul><h1 id="Element-组件"><a href="#Element-组件" class="headerlink" title="Element 组件"></a>Element 组件</h1>]]></content>
      
      
      <categories>
          
          <category> Element </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2022/07/18/Vue/"/>
      <url>/2022/07/18/Vue/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Vue 是一套前端框架 免除原生JS中的DOM操作 简化书写<br>基于MVVM(Model-View-ViewModel) 思想 实现数据的双向绑定 将编程的关注点放在数据上<br><a href="https://cn.vuejs.org/">官网</a></p></blockquote><span id="more"></span><h1 id="Vue-快速入门"><a href="#Vue-快速入门" class="headerlink" title="Vue 快速入门"></a>Vue 快速入门</h1><ul><li><p>新建HTML页面 引入Vue.js文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在JS代码区域 创建Vue核心对象 进行数据绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>&#123;</span><br><span class="line">          <span class="attr">username</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>编写视图</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span> = <span class="string">&quot;username&quot;</span> <span class="attr">v-model</span> = <span class="string">&quot;username&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  </span><span class="template-variable">&#123;&#123;<span class="name">username</span>&#125;&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="Vue-常用指令"><a href="#Vue-常用指令" class="headerlink" title="Vue 常用指令"></a>Vue 常用指令</h1></li><li><p>指令 HTML标签上带有v-前缀的特殊属性 不同指令具有不同含义</p></li><li><p>常用指令</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>v-bind</td><td>为HTML标签绑定属性值 如设置href css样式等</td></tr><tr><td>v-model</td><td>在表单元素上创建双向数据绑定</td></tr><tr><td>v-on</td><td>为HTML标签绑定事件</td></tr><tr><td>v-show</td><td>根据条件展示某元素 区别在于切换的是display属性的值</td></tr><tr><td>v-for</td><td>列表渲染 遍历容器的元素或者对象的属性</td></tr><tr><td>v-if v-else v-else-if</td><td>条件性的渲染某元素，判定为true时渲染 否则不渲染</td></tr></tbody></table><h1 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h1></li><li><p>生命周期有八个阶段 每触发一个生命周期事件 会自动执行一个生命周期方法</p><table><thead><tr><th>状态</th><th>阶段周期</th></tr></thead><tbody><tr><td>beforeCreate</td><td>创建前</td></tr><tr><td>created</td><td>创建后</td></tr><tr><td>beforeMount</td><td>载入前</td></tr><tr><td>mounted</td><td>挂载完成</td></tr><tr><td>beforeUpdate</td><td>更新前</td></tr><tr><td>updated</td><td>更新后</td></tr><tr><td>beforeDestroy</td><td>销毁前</td></tr><tr><td>destroyed</td><td>销毁后</td></tr></tbody></table></li><li><p>mounted 挂载完成 Vue初始化成功 HTML页面渲染成功</p><ul><li>发送异步请求 加载数据<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;vue 挂载完毕 发送异步请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="/2022/07/18/Vue/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Vue生命周期"></p><p><a href="https://www.bilibili.com/video/BV1Qf4y1T7Hx?p=147&vd_source=12da55ab9dd7741612032a6f327c8c9d">图片来源</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AJAX</title>
      <link href="/2022/07/17/AJAX/"/>
      <url>/2022/07/17/AJAX/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AJAX(Asynchronous JavaScript And XML) : 异步的JavaScript和XML</p><span id="more"></span><ul><li>AJAX 作用<ul><li>与服务器进行数据交换 通过AJAX 可以给服务器发送请求 并获取服务器响应的数据 </li><li>异步交互 可以在不重新加载整个页面的情况下 与服务器交换数据并更新部分网页的技术</li></ul></li></ul><h1 id="AJAX-快速入门"><a href="#AJAX-快速入门" class="headerlink" title="AJAX 快速入门"></a>AJAX 快速入门</h1><ul><li>编写AjaxServlet 并使用response输出字符串</li><li>创建XMLHttpRequest 对象 用于和服务器交换数据<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span>(window.XMLHttpRequest)&#123;</span><br><span class="line">  xmlhttp = <span class="keyword">new</span> <span class="type">XMLHttpRequest</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  xml = <span class="keyword">new</span> <span class="type">ActiveObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>向服务器发送请求<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;<span class="keyword">GET</span>&quot;</span>,<span class="string">&quot;url&quot;</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure></li><li>获取服务器响应数据<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xmlhttp.readyState == <span class="number">4</span> &amp;&amp; xmlhttp.<span class="keyword">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">      elert(xmlhttp.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Axios-异步框架"><a href="#Axios-异步框架" class="headerlink" title="Axios 异步框架"></a>Axios 异步框架</h1><blockquote><p>Axios 对原生的AJAX进行封装 简化书写</p></blockquote></li><li><a href="https://www.axios-http.cn/">官网</a></li></ul><h2 id="Axios-快速入门"><a href="#Axios-快速入门" class="headerlink" title="Axios 快速入门"></a>Axios 快速入门</h2><ul><li>引入 axios 的  js文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用axios发送请求 并获取响应结果<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">axios</span>(&#123;</span><br><span class="line">  method:&quot;get&quot;,</span><br><span class="line">  url:&quot;...&quot;</span><br><span class="line">&#125;)<span class="selector-class">.then</span>(function(resp)&#123;</span><br><span class="line">  <span class="built_in">alert</span>(resp.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> axios(<span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">  method:</span><span class="string">&quot;post&quot;</span>,</span><br><span class="line"><span class="symbol">  url:</span><span class="string">&quot;...&quot;</span>,</span><br><span class="line"><span class="symbol">  data:</span><span class="string">&quot;username = zhangsan&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span>).then(function(resp)<span class="punctuation">&#123;</span></span><br><span class="line">  alert(resp.data)<span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;</span>)<span class="punctuation">;</span></span><br></pre></td></tr></table></figure><h2 id="Axios-请求方式别名"><a href="#Axios-请求方式别名" class="headerlink" title="Axios 请求方式别名"></a>Axios 请求方式别名</h2><img src="/2022/07/17/AJAX/Axios%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%88%AB%E5%90%8D.png" alt="Axios请求方式别名"></li><li>发送get请求<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">axios.get</span>(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">  .then(<span class="function"><span class="title">function</span>(<span class="variable">resp</span>)&#123;</span></span><br><span class="line"><span class="function">      <span class="title">alert</span>(<span class="variable">resp.data</span>);</span></span><br><span class="line"><span class="function">  &#125;)</span></span><br></pre></td></tr></table></figure></li><li>发送post请求<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">axios</span>.<span class="property">post</span>(<span class="string">&quot;url&quot;</span>,<span class="string">&quot;参数&quot;</span>)</span><br><span class="line">  .<span class="property">then</span>(<span class="title function_">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="variable">resp</span>.<span class="property">data</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><blockquote><p>JavaScript Object Notation JavaScript 对象表示法 其语法简单 层次鲜明 多用于作为数据载体 在网络中进行数据传输</p></blockquote></li></ul><h2 id="JSON-基础语法"><a href="#JSON-基础语法" class="headerlink" title="JSON 基础语法"></a>JSON 基础语法</h2><ul><li><p>定义</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 = &#123;</span><br><span class="line">  <span class="string">&quot;key1&quot;</span> : <span class="type">value1</span>,</span><br><span class="line">  <span class="string">&quot;key2&quot;</span> : <span class="type">value2</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>value的数据类型<ul><li>数字(整数或者浮点数)</li><li>字符串(在双引号中)</li><li>逻辑值(true or false)</li><li>数组(在方括号中)</li><li>对象(在花括号中) </li><li>null</li></ul></li><li>实例  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> json = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">23</span>,</span><br><span class="line">    <span class="string">&quot;addr&quot;</span>:<span class="selector-attr">[<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;上海&quot;</span>]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取数据</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名.<span class="built_in">key</span></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line">json.<span class="built_in">key</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="JSON-数据和Java对象转换"><a href="#JSON-数据和Java对象转换" class="headerlink" title="JSON 数据和Java对象转换"></a>JSON 数据和Java对象转换</h2><ul><li>Fastjson是阿里巴巴提供的一个Java语言编写的高性能功能完善的JSON库 是目前Java 语言中最快的JSON库 可以实现Java对象和JSON字符串的相互转换</li><li>使用<ul><li>导入坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependency&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Java对象转JSON<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String jsonStr = <span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span><span class="keyword">to</span><span class="constructor">JSONString(<span class="params">obj</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>JSON 字符串转Java对象<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">User</span> <span class="keyword">user</span> = <span class="type">JSON</span>.parseObject(jsonStr,<span class="keyword">User</span>,<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> AJAX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter&amp;Listener</title>
      <link href="/2022/07/16/Filter/"/>
      <url>/2022/07/16/Filter/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Filter表示过滤器 可以把对资源的请求拦截下来 实现一些特殊的功能 如 权限控制 统一编码处理 敏感字符处理等<br>Listener 表示监听器可以监听就是在appliction session request 三个对象创建 销毁 或往其中添加修改删除属性时自动执行代码的功能组件</p><span id="more"></span><h1 id="Filter-快速入门"><a href="#Filter-快速入门" class="headerlink" title="Filter 快速入门"></a>Filter 快速入门</h1><ul><li>定义类 实现Filter 接口 并重写其所有方法<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">FileterDemo</span> <span class="selector-tag">implements</span> <span class="selector-tag">Filter</span> &#123;</span><br><span class="line">  <span class="variable">@Override</span></span><br><span class="line">  public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">@Override</span></span><br><span class="line">  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">@Override</span></span><br><span class="line">  public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>配置Filter拦截资源路径 在类上定义@WebFilter 注解<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(<span class="string">&quot;/*&quot;</span>)</span></span><br></pre></td></tr></table></figure></li><li>在doFilter方法中编写代码 并放行<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">public void <span class="keyword">do</span><span class="constructor">Filter(ServletRequest <span class="params">servletRequest</span>, ServletResponse <span class="params">servletResponse</span>, FilterChain <span class="params">filterChain</span>)</span> throws IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">// 放行</span></span><br><span class="line">    filterChain.<span class="keyword">do</span><span class="constructor">Filter(<span class="params">servletRequest</span>,<span class="params">servletResponse</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Filter-执行流程"><a href="#Filter-执行流程" class="headerlink" title="Filter 执行流程"></a>Filter 执行流程</h1></li><li>执行放行前逻辑</li><li>放行</li><li>访问资源</li><li>执行放行后逻辑<h1 id="Filter-使用细节"><a href="#Filter-使用细节" class="headerlink" title="Filter 使用细节"></a>Filter 使用细节</h1><h2 id="Filter-拦截路径配置"><a href="#Filter-拦截路径配置" class="headerlink" title="Filter 拦截路径配置"></a>Filter 拦截路径配置</h2></li><li>Filter 可以根据需求 配置不同的拦截资源路径<ul><li>拦截具体的资源 &#x2F;index.jsp 只有访问index.jsp时才会被拦截</li><li>目录拦截 &#x2F;user&#x2F;* 访问&#x2F;user 下的所有资源都会被拦截</li><li>后缀名拦截 *.jsp 访问后缀名为jsp的资源 都会被拦截</li><li>拦截所有 &#x2F;* 访问所有资源 都会被拦截</li></ul></li></ul><h2 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h2><blockquote><p>一个Web应用 可以配置多个过滤器 这多个过滤器称为过滤器链</p></blockquote><ul><li>过滤器的执行顺序由字符串的排序决定</li></ul><h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><ul><li><p>Listener分类<br> <img src="/2022/07/16/Filter/Listener%E5%88%86%E7%B1%BB.png" alt="Listener分类"></p></li><li><p>使用</p><ul><li>定义类 实现对应的接口</li><li>在类上添加@WebListener是注解</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookies&amp;Session</title>
      <link href="/2022/07/15/Cookies-Session/"/>
      <url>/2022/07/15/Cookies-Session/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>会话跟踪是一种维护浏览器状态的方法 服务器需要识别多次请求是否来自于同一浏览器 以便在同一次会话的多次请求间共享数据</p></blockquote><span id="more"></span><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><blockquote><p>客户端会话跟踪技术</p></blockquote><h2 id="Cookie-基本使用"><a href="#Cookie-基本使用" class="headerlink" title="Cookie 基本使用"></a>Cookie 基本使用</h2><ul><li>Cookie：客户端会话技术 将数据保存到客户端 以后每次请求都携带Cookie数据进行访问</li><li>Cookie基本使用<ul><li>创建Cookie对象 设置数据<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cookie cookie</span> = new Cookie(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>发送Cookie到客户端 使用response对象<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.add<span class="constructor">Cookie(<span class="params">cookie</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获取客户端携带的所有Cookie 使用request对象<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies <span class="operator">=</span> request.getCookies()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>遍历数组 获取每一个Cookie对象</li><li>使用Cookie对象方法获取数据<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie.getName()<span class="comment">;</span></span><br><span class="line">cookie.getValue()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="Cookie-原理"><a href="#Cookie-原理" class="headerlink" title="Cookie 原理"></a>Cookie 原理</h2></li></ul></li><li>Cookie 的实现是基于HTTP协议的<ul><li>响应头 set-cookie</li><li>请求头 cookie<h2 id="Cookie-使用细节"><a href="#Cookie-使用细节" class="headerlink" title="Cookie 使用细节"></a>Cookie 使用细节</h2></li></ul></li><li>Cookie 存活时间<ul><li>默认情况下，Cookie 存储在浏览器内存中 当浏览器关闭 内存释放 则Cookie被销毁</li><li>setMaxAge(int seconds) 设置Cookie存活时间<ul><li>正数 将Cookie写入浏览器所在电脑的硬盘 持久化存储 到时间自动删除</li><li>负数 默认值 Cookie在当前浏览器内存中 当浏览器关闭 则Cookie被销毁</li><li>零 删除对应Cookie</li></ul></li></ul></li><li>Cookie 存储中文<ul><li>Cookie 不能直接存储中文</li><li>如需要存储 则需要进行转码 URL编码<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><blockquote><p>服务端会话跟踪技术</p></blockquote><h2 id="Session-基本使用"><a href="#Session-基本使用" class="headerlink" title="Session 基本使用"></a>Session 基本使用</h2></li></ul></li><li>服务端会话跟踪技术 将数据保存到服务端</li><li>JavaEE提供HttpSession接口 来实现一次会话的多次请求间数据共享功能</li><li>使用<ul><li>获取Session对象<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session <span class="operator">=</span> request.getSession()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>Session 对象功能<ul><li>void setAttribute(String name,Object o) 存储数据到session域中</li><li>Object getAttribute(String name) 根据key 获取值</li><li>void removeAttribute(String name) 根据key 删除该键值对<h2 id="Session-原理"><a href="#Session-原理" class="headerlink" title="Session 原理"></a>Session 原理</h2></li></ul></li></ul></li><li>用户第一次请求服务器时，服务器端会生成一个sessionid</li><li>服务器端将生成的sessionid返回给客户端，通过set-cookie</li><li>客户端收到sessionid会将它保存在cookie中，当客户端再次访问服务端时会带上这个sessionid</li><li>当服务端再次接收到来自客户端的请求时，会先去检查是否存在sessionid，不存在就新建一个sessionid重复1,2的流程，如果存在就去遍历服务端的session文件，找到与这个sessionid相对应的文件，文件中的键值便是sessionid，值为当前用户的一些信息</li><li>此后的请求都会交换这个 Session ID，进行有状态的会话。<h2 id="Session-使用细节"><a href="#Session-使用细节" class="headerlink" title="Session 使用细节"></a>Session 使用细节</h2></li><li>Session 钝化 活化<ul><li>钝化 在服务器正常关闭后 Tomcat会自动将Session数据写入硬盘的文件中</li><li>活化 再次启动服务器后 从文件中加载数据到Session中</li></ul></li><li>Session 销毁<ul><li>默认情况下 无操作 30分组后自动销毁<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>调用Session对象的invalidate()方法</li></ul></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>Cookie 和 Session 都是来完成一次会话内多次请求间数据共享的</li><li>区别<ul><li>存储位置 Cookie 是将数据存储在客户端 Session将数据存储在服务器端</li><li>安全性 Cookie 不安全 Seesion 安全</li><li>数据大小 Cookie 最大3KB Session 无大小限制</li><li>存储时间 Cookie可以长时间存储 Session默认30分钟</li><li>服务器性能 Cookie不占服务器资源 Session 占用服务器资源</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Request&amp;Response</title>
      <link href="/2022/07/13/Request-Response/"/>
      <url>/2022/07/13/Request-Response/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Request 获取请求数据<br>Response 设置响应数据</p></blockquote><span id="more"></span><h1 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h1><h2 id="Request-继承体系"><a href="#Request-继承体系" class="headerlink" title="Request 继承体系"></a>Request 继承体系</h2><p><img src="/2022/07/13/Request-Response/Request%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.png" alt="Request 继承体系"></p><ul><li>TomCat 需要解析请求数据 封装为request对象 并且创建request对象传递到service方法中<h2 id="Request-获取请求数据"><a href="#Request-获取请求数据" class="headerlink" title="Request 获取请求数据"></a>Request 获取请求数据</h2><h3 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h3></li><li>请求数据分为3部分<ul><li>请求行 GET&#x2F;request-demo&#x2F;reql?username &#x3D; zhangsan HTTP&#x2F;1.1<ul><li>String getMethod() 获取请求方式  ： GET</li><li>String getContextPath() 获取虚拟目录(目录访问路径) :&#x2F;request-demo</li><li>StringBuffer getRequestURL() 获取URL ： <a href="http://localhost:8080/request-demo/req1">http://localhost:8080/request-demo/req1</a></li><li>String getRequestURL() 获取URI ： &#x2F;request-demo&#x2F;req1</li><li>String getQueryString() 获取请求参数(GET方式) username&#x3D; zhangsan&amp;password &#x3D; 123</li></ul></li><li>请求头 User-Agent:Mozilla&#x2F;5.0 Chrome&#x2F;91.0.4472.106<ul><li>String getHeader(String name) 根据请求头名称 获取值</li></ul></li><li>请求体 username &#x3D; kris&amp;password &#x3D; 111<ul><li>ServletInputStream getInputSatream() 获取字节输入流</li><li>BufferedReader getReader() 获取字符输入流</li></ul></li></ul></li></ul><h3 id="通用方式获取请求参数"><a href="#通用方式获取请求参数" class="headerlink" title="通用方式获取请求参数"></a>通用方式获取请求参数</h3><ul><li>请求参数获取方式<ul><li>GET 方式<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">String</span> <span class="function"><span class="title">getQueryString</span>()</span></span><br></pre></td></tr></table></figure></li><li>POST 方式<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">BufferedReader</span> <span class="function"><span class="title">getReader</span>()</span></span><br></pre></td></tr></table></figure></li></ul></li><li>Request 通用方式获取请求参数<ul><li>Map&lt;String,String[]&gt; getParameterMap(); 获取所有参数Map集合</li><li>String[] getParameterValues(String name) 根据名称获取参数值(数组)</li><li>String getParameter(String name) 根据名称获取参数值(单个值)</li></ul></li></ul><h3 id="请求参数中文乱码处理"><a href="#请求参数中文乱码处理" class="headerlink" title="请求参数中文乱码处理"></a>请求参数中文乱码处理</h3><ul><li><p>请求参数如果存在中文数据，则会乱码</p><ul><li>POST： 设置输入流的编码<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>GET  先编码 再解码<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="constructor">String(<span class="params">username</span>.<span class="params">getBytes</span>(<span class="string">&quot;ISO-8859-1&quot;</span>)</span>,<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>URL 编码<ul><li>将字符串按照编码方式转为二进制</li><li>每个字节转为2个16进制数并在前边加上%<h2 id="Request-请求转发"><a href="#Request-请求转发" class="headerlink" title="Request 请求转发"></a>Request 请求转发</h2><blockquote><p>一种在服务器内部的资源跳转方式</p></blockquote></li></ul></li></ul></li><li><p>实现方式</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.getRequestDispatcher(<span class="string">&quot;资源B路径&quot;</span>).forward(req.resp)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>请求转发资源间共享数据 使用Requset 对象</p><ul><li>void setAttribute(String name,Object o) 存储数据到request域中</li><li>Object getAttribute(String name) 根据key 获取值</li><li>void removeAttribute(String name)根据key 删除该键值对</li></ul></li><li><p>请求转发特点</p><ul><li>浏览器地址栏路径不发生变化</li><li>只能转发到当前服务器的内部资源</li><li>一次请求 可以在转发的资源间使用request共享数据</li></ul></li></ul><h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><h2 id="Response-设置响应数据功能介绍"><a href="#Response-设置响应数据功能介绍" class="headerlink" title="Response 设置响应数据功能介绍"></a>Response 设置响应数据功能介绍</h2><ul><li><p>响应行 </p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure><ul><li>void setStatus(int sc) 设置响应状态码</li></ul></li><li><p>响应头</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>:<span class="type">text</span>/html</span><br></pre></td></tr></table></figure><ul><li>void setHeader(String name,String value) 设置响应头键值对</li></ul></li><li><p>响应体</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;html&gt;</span><span class="section">&lt;head&gt;</span><span class="section">&lt;/head&gt;</span><span class="section">&lt;body&gt;</span><span class="section">&lt;/body&gt;</span><span class="section">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><ul><li>PrintWrite getWriter() 获取字符输出流</li><li>ServletOutputStream getOutputStream() 获取字节输出流<h2 id="Response-完成重定向"><a href="#Response-完成重定向" class="headerlink" title="Response 完成重定向"></a>Response 完成重定向</h2><blockquote><p>重定向(Redirect) 一种资源跳转方式</p></blockquote></li></ul></li><li><p>实现方式</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp.set<span class="constructor">Status(302)</span>;</span><br><span class="line">resp.set<span class="constructor">Header(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;另一资源的路径&quot;</span>)</span>;</span><br><span class="line"><span class="comment">//简化版</span></span><br><span class="line">resp.send<span class="constructor">Redirect(<span class="string">&quot;另一资源的路径&quot;</span>)</span></span><br></pre></td></tr></table></figure></li><li><p>重定向特点</p><ul><li>浏览器地址栏发生变化</li><li>可以重定向到任意位置的资源(服务器内部，外部均可)</li><li>两次请求，不能在多个资源使用request共享数据<h2 id="Response-响应字符数据"><a href="#Response-响应字符数据" class="headerlink" title="Response 响应字符数据"></a>Response 响应字符数据</h2></li></ul></li><li><p>使用</p><ul><li>通过Response对象获取字符输出流<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter writer <span class="operator">=</span> resp.getWriter()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>写数据<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.write(<span class="string">&quot;kris&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>设置编码<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset = utf-8&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>该流不需要关闭 随着响应结束 response 对象销毁 由服务器关闭<h2 id="Response-响应字节数据"><a href="#Response-响应字节数据" class="headerlink" title="Response 响应字节数据"></a>Response 响应字节数据</h2></li></ul></li><li><p>使用</p><ul><li>通过Response对象获取字符输出流<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletOutputStream outputStream <span class="operator">=</span> resp.getOutputStream()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>写数据<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputStream.write(字节数据)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>IOUtils工具类的使用</p><ul><li>导入坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOUtils.<span class="keyword">copy</span>(输入流,输出流);</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet</title>
      <link href="/2022/07/12/Servlet/"/>
      <url>/2022/07/12/Servlet/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Servlet 是JavaEE规范之一，就是一个接口 我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</p></blockquote><span id="more"></span><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><ul><li>创建web项目 导入Servlet依赖坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>创建 定义一个类 实现Servlet接口 并重写接口中的所有方法 并在service方法中输入一句话<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ServletDemo</span> <span class="symbol">implements</span> <span class="symbol">Servlet</span></span><br></pre></td></tr></table></figure></li><li>配置 在类上使用@WebServlet 注解 配置Servlet的访问路径<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(<span class="string">&quot;/demo1&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ServletDemo</span> <span class="symbol">implements</span> <span class="symbol">Servlet</span></span><br></pre></td></tr></table></figure><ul><li>注解中的loadOnStartip参数<ul><li>若为负整数(默认-1) 第一次被访问时创建Servlet对象</li><li>0或正整数 服务器启动时创建Servlet对象，数字越小优先级越高</li></ul></li></ul></li><li>访问 启动TomCat 浏览器输入URL访问该Servlet<h1 id="Servlet-执行流程"><a href="#Servlet-执行流程" class="headerlink" title="Servlet 执行流程"></a>Servlet 执行流程</h1></li><li>当Servlet第一次被调用的时候会触发init函数，该函数会把servlet实例加载到内存。该函数只会被调用一次</li><li>web服务器把接收到的http请求封装成一个Request对象，作为service函数的参数传递进去。</li><li>service函数会被调用多次，每访问一次Servlet，它的service函数就会被调用一次</li><li>返回的结果封装在response对象，web服务器先将response的信息拆解出来<br>形成http响应格式。然后将这个结果返回给浏览器。</li><li>浏览器得到结果之后会自己能识别的格式进行解析<h1 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h1></li><li>对象的生命周期指一个对象从被创建到销毁的整个过程</li><li>Servlet 运行在Servlet容器(web服务器)中，其生命周期由容器来管理 分为4个阶段<ul><li>加载和实例化 默认情况下 当Servlet第一次被访问时，由容器创建Servlet对象</li><li>初始化 在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象 完成一些如加载配置文件 创建连接等初始化的工作 该方法只调用一次</li><li>请求处理 每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理</li><li>服务终止 当需要释放内存或者容器关闭时 容器就会调用Servlet实例的destroy()方法完成资源的释放，在destroy()方法调用之后 容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</li></ul></li></ul><h1 id="Servlet-体系结构"><a href="#Servlet-体系结构" class="headerlink" title="Servlet 体系结构"></a>Servlet 体系结构</h1><blockquote><p>开发B&#x2F;S架构的web项目，都是针对HTTP协议 所以自定义的Servlet 会继承HttpServlet</p></blockquote><p><img src="/2022/07/12/Servlet/Servlet%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="Servlet体系结构"></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@WebServlet</span>(<span class="string">&quot;/demo2&quot;</span>)</span><br><span class="line">    public <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doGet(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doPost(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Servlet-urlPattern配置"><a href="#Servlet-urlPattern配置" class="headerlink" title="Servlet urlPattern配置"></a>Servlet urlPattern配置</h1><ul><li>Servlet 要想被访问 必须配置其访问路径(urlPattern)<ul><li>一个Servlet 可以配置多个urlPattern<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPattern = &#123;<span class="string">&quot;/demo1&quot;</span>,<span class="string">&quot;/demo2&quot;</span>&#125;)</span></span><br></pre></td></tr></table></figure></li><li>urlPattern 配置规则<ul><li>精确匹配  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">配置路径  <span class="variable">@WebServlet</span>(&quot;/user/select&quot;)</span><br><span class="line">访问路径 localhost:<span class="number">8080</span><span class="operator">/</span>web<span class="operator">-</span>demo<span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span><span class="keyword">select</span></span><br></pre></td></tr></table></figure></li><li>目录匹配  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置路径  @WebServlet(<span class="string">&quot;/user/*&quot;</span>)</span><br><span class="line">访问路径 localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/aaa</span><br><span class="line">         localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/bbb</span><br></pre></td></tr></table></figure></li><li>扩展名匹配  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置路径  @WebServlet(<span class="string">&quot;*.do&quot;</span>)</span><br><span class="line">访问路径 localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/aaa.<span class="keyword">do</span></span><br><span class="line">         localhost:<span class="number">8080</span><span class="regexp">/web-demo/u</span>ser/bbb.<span class="keyword">do</span></span><br></pre></td></tr></table></figure></li><li>任意匹配  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置路径  <span class="variable">@WebServlet</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">          <span class="variable">@WebServlet</span>(<span class="string">&quot;/*&quot;</span>)</span><br><span class="line">访问路径 <span class="attribute">localhost</span>:<span class="number">8080</span>/web-demo/haha</span><br></pre></td></tr></table></figure></li><li>优先级<br>  精确&gt;目录&gt;扩展名&gt;&#x2F;*&gt;&#x2F;<h1 id="XML-配置方式编写-Servlet"><a href="#XML-配置方式编写-Servlet" class="headerlink" title="XML 配置方式编写 Servlet"></a>XML 配置方式编写 Servlet</h1></li></ul></li></ul></li><li>Servlet 从3.0版本后开始支持使用注解配置 3.0之前只支持XML配置文件的配置方式</li><li>步骤<ul><li>编写Servlet类</li><li>在web.xml中配置Servelt<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;demo&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.kris.servletDemo&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;demo&lt;/servlet&gt;</span><br><span class="line">    &lt;url-pattern&gt;/demo&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TomCat</title>
      <link href="/2022/07/12/TomCat/"/>
      <url>/2022/07/12/TomCat/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Web 服务器是一个应用程序 对HTTP协议的操作进行封装，使的程序员不必直接对协议进行操作，让Web开发更加便捷 </p></blockquote><span id="more"></span><h1 id="TomCat-目录结构"><a href="#TomCat-目录结构" class="headerlink" title="TomCat 目录结构"></a>TomCat 目录结构</h1><ul><li>bin 可执行文件存放目录</li><li>conf 配置文件存放目录</li><li>lib tomcat依赖的jar包</li><li>logs 日志文件</li><li>temp 临时文件</li><li>webapps 应用发布目录</li><li>work 工作目录<h1 id="TomCat-基本使用"><a href="#TomCat-基本使用" class="headerlink" title="TomCat 基本使用"></a>TomCat 基本使用</h1></li><li>配置<ul><li>修改启动端口号: conf&#x2F;server.xml<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port<span class="operator">=</span><span class="string">&quot;8080&quot;</span> protocol<span class="operator">=</span><span class="string">&quot;HTTP/1.1&quot;</span></span><br><span class="line">  connectionTimeout<span class="operator">=</span><span class="string">&quot;20000&quot;</span></span><br><span class="line">  redirectPort<span class="operator">=</span><span class="string">&quot;8443&quot;</span> /&gt;</span><br><span class="line">  //默认为 <span class="number">8080</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>HTTP协议默认端口号为80，如果将TomCat端口号改为80，则将来访问时将不用输入端口号</strong></p><ul><li>启动时可能出现的问题<ul><li>端口号冲突 找到对应程序 将其关闭</li><li>闪退 检查JAVA_HOME 环境变量是否正确配置</li></ul></li><li>TonCat 部署项目<ul><li>将项目放置到webapps 目录下，即部署完成</li></ul></li><li>一般JavaWeb项目会被打成war包 然后将war包放到webapps目录下,TomCat会自动解压缩war文件</li></ul><h1 id="IDEA中创建Maven-Web-项目"><a href="#IDEA中创建Maven-Web-项目" class="headerlink" title="IDEA中创建Maven Web 项目"></a>IDEA中创建Maven Web 项目</h1><ul><li>使用骨架(项目模板)<ul><li>选择web项目骨架，创建项目</li><li>删除pom.xml中多余的坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">以下到<span class="tag">&lt;/<span class="name">project</span>&gt;</span>以上的部分都可删除</span><br></pre></td></tr></table></figure></li><li>补齐缺失的目录结构<ul><li>java</li><li>resources</li></ul></li></ul></li><li>不使用<ul><li>新建maven模板  </li><li>将打包方式改为war</li><li>补齐缺失的目录结构<ul><li>webapp 以及其子目录</li></ul></li></ul></li></ul><h1 id="IDEA中使用TomCat"><a href="#IDEA中使用TomCat" class="headerlink" title="IDEA中使用TomCat"></a>IDEA中使用TomCat</h1><ul><li>pom.xml 添加TomCat插件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用Maven Helper 插件启动项目 选中项目 右键-&gt; Run Maven –&gt; tomcat7:run</li></ul>]]></content>
      
      
      <categories>
          
          <category> WebService </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2022/07/11/JS-1/"/>
      <url>/2022/07/11/JS-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>JavaScript 是一门跨平台，面向对象的脚本语言，来控制网页行为的，它能使网页可交互</p></blockquote><span id="more"></span><h1 id="JS-引入方式"><a href="#JS-引入方式" class="headerlink" title="JS 引入方式"></a>JS 引入方式</h1><ul><li>内部脚本 将JS代码定义在HTML页面中<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  JS代码</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在HTML文档中可以在任意地方，放置任意数量的&lt;script&gt;</li><li>一般把脚本置于&lt;body&gt;元素的底部，可以改善显示速度，因为脚本执行会拖慢显示</li></ul></li><li>外部脚本 将JS代码定义在外部JS文件中，然后引入到HTML页面中<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">script</span> src = <span class="string">&quot;xxx.js&quot;</span>&gt;&lt;\<span class="keyword">script</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>外部脚本不能包含&lt;script&gt;标签</li><li>&lt;script&gt; 标签不能自闭合<h1 id="JS-基础语法"><a href="#JS-基础语法" class="headerlink" title="JS 基础语法"></a>JS 基础语法</h1><h2 id="书写语法"><a href="#书写语法" class="headerlink" title="书写语法"></a>书写语法</h2></li></ul></li><li>区分大小写 与Java一样 变量名 函数名 以及其他一切东西都是区分大小写的</li><li>每行结尾的分号可有可无</li><li>注释<ul><li>单行  &#x2F;&#x2F;</li><li>多行  &#x2F;**&#x2F;</li></ul></li><li>大括号表示代码块<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">  代码</span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h2></li><li>使用 window.alert()写入警告框</li><li>使用document.write()写入HTML输出</li><li>使用console.log()写入浏览器控制台<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li><li>JS 中用var关键字来声明变量 相当于全局变量 并且可以重复定义</li><li>JS是一门弱类型语言，变量可以存放不同类型的值<ul><li>组成字符可以是任何字母 数字 下划线 或者美元符号($)</li><li>数字不能开头</li><li>建议使用驼峰命名</li></ul></li><li>ECMAScript 6 新增let关键字来定义变量，用法类似var 但是所声明的变量只在let关键字所在的代码块内有效，且不允许重复声明</li><li>ECMAScript 6 新增了const 关键字 用来声明一个只读的常量，一旦声明，常量的值就不能改变<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2></li><li>原始类型<ul><li>number 数字(整数 小数 NaN(Not a Number))</li><li>string 字符 字符串 单双引皆可</li><li>boolean 布尔 </li><li>null 对象为空</li><li>undefined 当声明的变量未初始化时 该变量的默认值时undefined</li></ul></li></ul><p><strong>使用typeof运算符可以获取数据类型</strong></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>&#x3D;&#x3D; 会先判断数据类型 然后进行转换，在比较值，如 整数20会&#x3D;&#x3D; 字符串20</li><li>&#x3D;&#x3D;&#x3D; 不会进行类型转换，类型不一样返回false</li><li>类型转换<ul><li>字符串的字面值转成整数，如果字符串字母值时字符，会转换成NaN，布尔类型 true 1 false 0</li><li>0或者NaN会转成false 其他则为 true</li><li>空字符串转成false 其他为true</li><li>null 和 undefined都转为false<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2></li></ul></li><li>JS 函数通过function关键词进行定义 语法为<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">定义方式一</span><br><span class="line"><span class="keyword">function</span> 函数名(<span class="params">参数<span class="number">1</span>，参数<span class="number">2</span>，...</span>)&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br><span class="line">定义方式二</span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="keyword">function</span>(<span class="params">参数列表</span>)&#123;</span><br><span class="line">  函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>形参不需要类型 因为JS时弱类型语言</li><li>返回值也不需要定义类型 可以在函数内部直接使用return返回即可</li><li>JS 中，函数调用可以传递任意个数参数<h1 id="JS-常用对象"><a href="#JS-常用对象" class="headerlink" title="JS 常用对象"></a>JS 常用对象</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2></li><li>定义<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="built_in">Array</span>（元素列表）;<span class="comment">//方式 一</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = [元素列表];<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure></li><li>访问<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[索引] <span class="operator">=</span> 值</span><br></pre></td></tr></table></figure></li></ul><p><strong>JS类似于Java集合 长度和类型都可变</strong></p><ul><li>push()  添加元素</li><li>splice() 删除<ul><li>参数一 从哪开始山</li><li>参数二 删几个</li></ul></li></ul><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_array.asp">JS Array</a></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>定义<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="built_in">String</span>(s);<span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = s；<span class="comment">//方式二</span></span><br></pre></td></tr></table></figure></li><li>属性<ul><li>length  字符串长度</li><li>…</li></ul></li><li>方法<ul><li>charAt()  返回指定位置的字符</li><li>indexOf()   检索字符串</li><li>trim() 去除首位的空格</li><li>…</li></ul></li></ul><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_string.asp">JS String</a></p><h2 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h2><ul><li>格式<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名称 <span class="operator">=</span> &#123;</span><br><span class="line">  属性名称<span class="number">1</span>:属性值<span class="number">1</span>，</span><br><span class="line">  属性名称<span class="number">2</span>:属性值<span class="number">2</span>，</span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">  函数名称:<span class="title function_">function</span>(形参列表)&#123;&#125;</span><br><span class="line">  <span class="operator">...</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1></li><li>Brower Object Model 浏览器对象模型</li><li>JavaScript 将浏览器的各个组成部分封装为对象</li></ul><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><ul><li><p>Window 浏览器窗口对象</p></li><li><p>获取 直接使用window 其中window. 可以省略</p></li><li><p>属性 获取其他BOM对象</p><ul><li>history  对History 对象的只读引用</li><li>Navigator  对<a href="https://www.w3school.com.cn/jsref/obj_navigator.asp">Navigator</a>对象的只读引用</li><li>Screen  对<a href="https://www.w3school.com.cn/jsref/obj_screen.asp">Screen</a>对象的只读引用</li><li>location 用于窗口或框架的Location对象</li></ul></li><li><p>方法</p><ul><li>alert() 显示带有一段信息和一个确认按钮的警告框</li><li>confirm() 显示带有一段信息以及确认按钮和取消按钮的对话框 <ul><li>返回flag 确认为true 取消 false</li></ul></li><li>setInterval() 按照指定的周期(以毫秒计)来调用函数或计算表达式 <ul><li>参数一 function</li><li>参数二 毫秒值</li></ul></li><li>setTimeout() 在指定的毫秒数后调用函数或者计算表达式<ul><li>参数一 function</li><li>参数二 毫秒值<h2 id="History-历史记录对象"><a href="#History-历史记录对象" class="headerlink" title="History 历史记录对象"></a>History 历史记录对象</h2></li></ul></li></ul></li><li><p>History 历史记录</p></li><li><p>获取 使用window.history获取 </p></li><li><p>方法</p><ul><li>back()  加载history列表中的前一个URL</li><li>forward()  加载history列表中的下一个URL <h2 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h2></li></ul></li><li><p>Location 地址栏对象</p></li><li><p>获取 使用window.location获取</p></li><li><p>属性</p><ul><li>href  设置或返回完整的URL<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1></li></ul></li><li><p>Document Object Model 文档对象模型</p></li><li><p>将标记语言的各个组成部分封装为对象</p><ul><li>Document 整个文档对象</li><li>Element  元素对象</li><li>Attribute   属性对象</li><li>Text   文本对象</li><li>Comment   注释对象</li></ul></li><li><p>JS 通过 DOM 能对HTML进行操作</p><ul><li>改变HTML元素的内容</li><li>改变HTML元素的样式</li><li>对HTML DOM 事件做出反应</li><li>添加和删除HTML元素<h2 id="获取Element对象"><a href="#获取Element对象" class="headerlink" title="获取Element对象"></a>获取Element对象</h2></li></ul></li><li><p>获取 使用Document 对象的方法来获取</p><ul><li>getElementById 根据id值获取 返回一个Element对象</li><li>getElementByName  根据name属性值获取 返回Element对象数组</li><li>getElementByTagName 根据标签名获取 返回Element对象数组</li><li>getElementByClassName 根据class属性值获取 返回Element对象数组</li></ul></li></ul><h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><ul><li><p>事件 HTML事件是发生在HTML元素上的“事情” 例如</p><ul><li>按钮被点击</li><li>鼠标移动到元素上</li></ul></li><li><p>事件监听 JS可以在事件被侦测到时执行代码</p></li></ul><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><ul><li>方式一 通过HTML标签中的事件属性进行绑定<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">&quot;button&quot;</span> onclick = <span class="string">&#x27;on()&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">on</span><span class="params">()</span></span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;点击&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方式二 通过DOM元素属性绑定<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type<span class="operator">=</span><span class="string">&quot;button&quot;</span> id <span class="operator">=</span> <span class="string">&quot;btn&quot;</span>&gt;</span><br><span class="line">document.getElementById(<span class="string">&quot;btn&quot;</span>).onclick <span class="operator">=</span> function()&#123;</span><br><span class="line">  alert(<span class="string">&quot;点击&quot;</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h2><table><thead><tr><th>事件名</th><th>说明</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标点击事件</td></tr><tr><td>onblur</td><td>元素失去焦点</td></tr><tr><td>onfocus</td><td>元素获得焦点</td></tr><tr><td>onload</td><td>某个页面或图像被完成加载</td></tr><tr><td>onsubmit</td><td>当表单提交时触发该事件</td></tr><tr><td>onkeydown</td><td>某个键盘的键被按下</td></tr><tr><td>onmouseover</td><td>鼠标被移到某元素上</td></tr><tr><td>onmouseout</td><td>鼠标从某元素移开</td></tr></tbody></table><p><a href="https://www.w3school.com.cn/jsref/dom_obj_event.asp">DOM 事件</a></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2022/07/11/CSS/"/>
      <url>/2022/07/11/CSS/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>CSS(Cascading Style Sheet) 层叠样式表 用于控制网页表现</p></blockquote><span id="more"></span><h1 id="CSS-导入方式"><a href="#CSS-导入方式" class="headerlink" title="CSS 导入方式"></a>CSS 导入方式</h1><ul><li>内联样式 在标签内部使用style属性 属性值是css属性键值对<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> style = <span class="string">&quot;color:red&quot;</span>&gt; Hello World&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></li><li>内部样式 使用&lt;style&gt;标签 在标签内部定义css样式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span> = <span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  &lt;\style&gt;</span></span><br></pre></td></tr></table></figure></li><li>外部样式 定义link标签 引入外部的css文件<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel <span class="operator">=</span> <span class="string">&quot;stylesheet&quot;</span> href <span class="operator">=</span> <span class="string">&quot;demo.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h1></li><li>概念 选择器是选取需设置样式的元素（标签）</li><li>分类<ul><li>元素选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素名称&#123;<span class="attribute">color</span> : red;&#125;</span><br></pre></td></tr></table></figure></li><li>id 选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span>属性值&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure></li><li>类选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span>属性值&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><h1 id="CSS-属性"><a href="#CSS-属性" class="headerlink" title="CSS 属性"></a>CSS 属性</h1><a href="https://www.w3school.com.cn/cssref/index.asp">CSS参考手册</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2022/07/10/HTML/"/>
      <url>/2022/07/10/HTML/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>HTML(HyperText Markup Language) 超文本标记语言，除了文字信息还可以定义图片 音频 视频等内容，HTML 运行在浏览器上，其标签由浏览器来解析</p></blockquote><span id="more"></span><h1 id="HTML-快速入门"><a href="#HTML-快速入门" class="headerlink" title="HTML 快速入门"></a>HTML 快速入门</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        页面内容</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>HTML 文件以.html 或者 .htm为扩展名</li><li>HTML标签不区分大小写</li><li>HTML 标签属性值 单双引皆可</li><li>HTML 语法松散<h1 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;h1&gt; &lt;h6&gt;</td><td>定义标题，h1最大，h2最小</td></tr><tr><td>&lt;font&gt;</td><td>定义文本的字体 字体尺寸 字体颜色</td></tr><tr><td>&lt;b&gt;</td><td>定义粗体文本</td></tr><tr><td>&lt;i&gt;</td><td>定义斜体文本</td></tr><tr><td>&lt;u&gt;</td><td>定义文本下划线</td></tr><tr><td>&lt;center&gt;</td><td>定义文本居中</td></tr><tr><td>&lt;p&gt;</td><td>定义段落</td></tr><tr><td>&lt;br&gt;</td><td>定义折行</td></tr><tr><td>&lt;hr&gt;</td><td>定义水平线</td></tr></tbody></table></li></ul><h1 id="图片-视频-音频-标签"><a href="#图片-视频-音频-标签" class="headerlink" title="图片 视频 音频 标签"></a>图片 视频 音频 标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;img&gt;</td><td>定义图片</td></tr><tr><td>&lt;audio&gt;</td><td>定义音频</td></tr><tr><td>&lt;video&gt;</td><td>定义视频</td></tr></tbody></table><ul><li><p>img 定义图片</p><ul><li>src 规定显示图片的URL(统一资源定位符)</li><li>height 定义图像的高度 尺寸单位 px 和 %</li><li>width 定义图像的宽度 尺寸单位 px 和 %</li></ul></li><li><p>audio 定义音频 支持 MP3 WAV OGG</p><ul><li>src 规定音频的URL</li><li>controls 显示播放控件</li></ul></li><li><p>video 定义视频 支持 MP4 WebM OGG</p><ul><li>src 规定视频的URL</li><li>controls 显示播放控件<h1 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;a&gt;</td><td>定义超标签，用于链接到另一个资源</td></tr></tbody></table></li></ul></li><li><p>href 指定访问资源的URL</p></li><li><p>target 指定打开资源的方式</p><ul><li>_self 默认值  在当前也页面打开</li><li>_blank 在空白页打开<h1 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;ol&gt;</td><td>定义有序列表</td></tr><tr><td>&lt;ul&gt;</td><td>定义无序列表</td></tr><tr><td>&lt;li&gt;</td><td>定义列表项</td></tr></tbody></table></li></ul></li><li><p>type 设置项目符号 <strong>不建议使用 一般在css中设置</strong></p></li><li><p>有序列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.内容    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">2.内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容 <span class="tag">&lt;/<span class="name">li</span>&gt;</span>   </span><br><span class="line">3.内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span>          </span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;/<span class="name">ol</span>&gt;</span>       </span><br></pre></td></tr></table></figure></li><li><p>无序列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">· 内容    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">· 内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容 <span class="tag">&lt;/<span class="name">li</span>&gt;</span>   </span><br><span class="line">· 内容    <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span>          </span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">ol</span>&gt;</span>     </span><br></pre></td></tr></table></figure><h1 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;table&gt;</td><td>定义表格</td></tr><tr><td>&lt;tr&gt;</td><td>定义行</td></tr><tr><td>&lt;td&gt;</td><td>定义单元格</td></tr><tr><td>&lt;th&gt;</td><td>定义表头单元格</td></tr></tbody></table></li><li><p>table 定义表格</p><ul><li>border 规定表格边框的宽度</li><li>width 规定表格的宽度</li><li>cellspacing 规定单元格之间的空白</li></ul></li><li><p>tr 定义行</p><ul><li>align 定义表格行的内容对齐方式</li></ul></li><li><p>td 定义单元格</p><ul><li>rowspan 规定单元格可横跨的行数</li><li>colspan 规定单元格可横跨的列数</li></ul></li></ul><h1 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;div&gt;</td><td>定义HTML文档中的一个区域部分，经常与css一起使用，用来布局网页</td></tr><tr><td>&lt;span&gt;</td><td>用于组合行内元素</td></tr></tbody></table><p><strong>与CSS一起使用</strong></p><h1 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h1><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;form&gt;</td><td>定义表单</td></tr><tr><td>&lt;input&gt;</td><td>定义表单项，通过type属性控制输入形式</td></tr><tr><td>&lt;label&gt;</td><td>为表单项定义标注</td></tr><tr><td>&lt;select&gt;</td><td>定义下拉列表</td></tr><tr><td>&lt;option&gt;</td><td>定义下拉列表的列表项</td></tr><tr><td>&lt;textarea&gt;</td><td>定义文本域</td></tr></tbody></table><ul><li>表单 在网页中只要负责数据采集功能 使用&lt;form&gt;标签定义表单</li><li>表单项(元素)：不同类型的input元素，下拉列表，文本域等</li><li>form 定义表单<ul><li>action 规定当提交表单时向何处发送表单数据 URL</li><li>method 规定发送表单数据的方式<ul><li>get 浏览器会将数据直接附在表单的action URL之后，大小会有限制</li><li>post 浏览器会将数据放到http请求信息体中。大小无限制</li></ul></li></ul></li></ul><table><thead><tr><th>type取值</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>默认值 定义单行的输入字段</td></tr><tr><td>password</td><td>定义密码字段</td></tr><tr><td>radio</td><td>定义单选按钮</td></tr><tr><td>checkbox</td><td>定义复选框</td></tr><tr><td>file</td><td>定义文件上传按钮</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段</td></tr><tr><td>submit</td><td>定义提交按钮 提交按钮会把表单数据发送到服务器</td></tr><tr><td>reset</td><td>定义重置按钮 该按钮会清除表达中的所有数据</td></tr><tr><td>button</td><td>定义可点击按钮</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis---(1)</title>
      <link href="/2022/07/09/MyBatis-1/"/>
      <url>/2022/07/09/MyBatis-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>MyBatis 是一款优秀的持久层框架，用于简化JDBC开发</p></blockquote><span id="more"></span><ul><li><p>持久层</p><ul><li>负责将数据保存到数据库的那一层代码</li><li>JavaEE三层架构：表现层，业务层，持久层</li></ul></li><li><p>框架</p><ul><li>框架就是一个半成品软件，是一套可重用的，通用的 软件基础代码模型</li><li>在框架的基础之上构建软件编写更加高效 规范 通用 可扩展</li></ul></li></ul><h1 id="JDBC-缺点"><a href="#JDBC-缺点" class="headerlink" title="JDBC 缺点"></a>JDBC 缺点</h1><ul><li>硬编码        <ul><li>注册驱动，获取连接</li><li>SQL语句</li></ul></li><li>操作繁琐<ul><li>手动设置参数</li><li>手动封装结果集</li></ul></li></ul><p><strong>MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作，硬编码可通过配置文件的方式完成</strong></p><h1 id="MyBatis-快速入门"><a href="#MyBatis-快速入门" class="headerlink" title="MyBatis 快速入门"></a>MyBatis 快速入门</h1><h2 id="查询表中所有数据"><a href="#查询表中所有数据" class="headerlink" title="查询表中所有数据"></a>查询表中所有数据</h2><ul><li>创建表  添加数据</li><li>创建模块 导入坐标</li><li>编写MyBatis 核心配置文件 –&gt; 替换连接信息 解决硬编码问题</li><li>编写SQL映射文件 –&gt; 统一管理sql语句 解决硬编码问题</li><li>编码<ul><li>定义POJO类</li><li>加载核心配置文件，获取SqlSessionFactory 对象</li><li>获取SqlSession 对象，执行SQL语句</li><li>释放资源<h2 id="解决SQL映射文件的警告提示"><a href="#解决SQL映射文件的警告提示" class="headerlink" title="解决SQL映射文件的警告提示"></a>解决SQL映射文件的警告提示</h2></li></ul></li><li>产生原因：Idea和数据库没有建立连接 不识别表信息</li><li>解决方式；在Idea中配置MySQL数据库连接 <h1 id="Mapper-代理开发"><a href="#Mapper-代理开发" class="headerlink" title="Mapper 代理开发"></a>Mapper 代理开发</h1></li><li>目的<ul><li>解决原生方式的硬编码</li><li>简化后期执行SQL<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2></li></ul></li><li>定义与SQL映射文件同名的Mapper接口，并将Mapper接口的SQL映射文件放置在同一目录下</li><li>设置SQL映射文件的namespace属性为Mapper接口全限定名</li><li>在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致</li><li>编码<ul><li>通过SqlSession的getMapper方法获取Mapper接口的代理对象</li><li>通过对应方法完成sql的执行</li></ul></li></ul><p><strong>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载</strong></p><h1 id="Mybatis-核心配置文件"><a href="#Mybatis-核心配置文件" class="headerlink" title="Mybatis 核心配置文件"></a>Mybatis 核心配置文件</h1><p><a href="https://mybatis.net.cn/configuration.html">MyBatis官方文档</a></p><h1 id="配置文件完成增删改查"><a href="#配置文件完成增删改查" class="headerlink" title="配置文件完成增删改查"></a>配置文件完成增删改查</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kris.dao.AccountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.kris.domain.Account&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        select * from tb_account;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>id 执行sql的唯一标识  mybatis根据id 来找到需要执行的sql语句 可以自定义   建议使用接口中的方法名定义</li><li>resultType 表示结果类型 是sql 得到的ResultSet 遍历这个Result得到的java对象类型  写的是类型的全限定名称</li><li><a href="http://mybatis.org/dtd/mybatis-3-mapper.dtd">http://mybatis.org/dtd/mybatis-3-mapper.dtd</a>    约束文件</li><li>namespace 命名空间 dao接口的全限定名称</li></ul><h2 id="查询映射"><a href="#查询映射" class="headerlink" title="查询映射"></a>查询映射</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>resultMap id<span class="operator">=</span>&quot;无要求&quot; type<span class="operator">=</span>&quot;封装类名&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="comment">-- id 是主键字段的映射</span></span><br><span class="line">    <span class="comment">-- result 是其他字段的映射</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">result</span> <span class="keyword">column</span><span class="operator">=</span>&quot;列名&quot; property<span class="operator">=</span>&quot;别名&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">result</span> <span class="keyword">column</span><span class="operator">=</span>&quot;列名&quot; property<span class="operator">=</span>&quot;别名&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>resultMap<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;selectOne&quot; resultMap<span class="operator">=</span>&quot;无要求&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h2 id="MyBatisX插件"><a href="#MyBatisX插件" class="headerlink" title="MyBatisX插件"></a>MyBatisX插件</h2><blockquote><p>MyBatisX 是一款基于IDEA的快速开发插件 为效率而生</p></blockquote><ul><li>功能<ul><li>XML 和接口方法相互跳转</li><li>根据接口方法生成statement</li><li>安装<blockquote><p>在IDEA中的Plugin中搜索即可</p></blockquote></li></ul></li></ul><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ul><li>在定义的Mapper接口中写出需要实现的接口映射</li><li>利用插件的快捷方式在xml文件中编写对应的sql语句</li><li>id 需要与 接口名字相同</li><li>参数接收<ul><li>#{}   会将其替换为？，防止SQL注入</li><li>${}  拼sql 会有SQL注入问题</li></ul></li><li>转义<ul><li>CDATA 区  会将区域内的当作纯文本处理    CD提示</li><li>查询对应字符在xml的转义</li></ul></li><li>多个参数的接受<ul><li>散装参数：使用@Param(“SQL参数占位符名称”)</li><li>对象参数 对象的属性名称要和参数占位符名称一致</li><li>map map的key值要与参数占位符名称一致</li></ul></li><li>使用where 标签 并且 条件前都得加上and</li><li>默认开启事务 需要手动提交</li><li>获取主键id  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">useGeneratedKeys</span> <span class="operator">=</span> </span><br><span class="line">true<span class="string">&quot; keyProperty = &quot;</span>id<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li><li>删除 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delete <span class="keyword">from</span> 表名 <span class="keyword">where</span> <span class="built_in">id</span> <span class="keyword">in</span> (</span><br><span class="line">    &lt;foreach collection = <span class="string">&quot;arrays(或者用Param注解改变名称)&quot;</span> <span class="built_in">item</span> = <span class="string">&quot;id&quot;</span> separator=<span class="string">&quot;,&quot;</span>(分隔符)&gt;</span><br><span class="line">    <span class="comment">#&#123;id&#125;</span></span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h1 id="注解完成增删改查"><a href="#注解完成增删改查" class="headerlink" title="注解完成增删改查"></a>注解完成增删改查</h1><blockquote><p>注解用来完成简单的工作  配置文件用来完成复杂的工作</p></blockquote><ul><li>查询 @Select</li><li>添加 @Insert</li><li>修改 @Update</li><li>删除 @Delete<h1 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h1><a href="https://mybatis.net.cn/dynamic-sql.html">MyBatis官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven---(1)</title>
      <link href="/2022/07/08/Maven-1/"/>
      <url>/2022/07/08/Maven-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Apache Maven 是一个项目管理和构建工具，基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建，报告和文档</p></blockquote><span id="more"></span><ul><li>提供了一套标准的项目结构<blockquote><p>在不同的IDE中的项目结构并不相同，Maven提供了一套标准化的项目，以便在不同的IDE中通用</p></blockquote></li><li>提供了一套标准化的构建流程(编译，测试，打包，发布…)</li><li>提供了一套依赖管理机制<blockquote><p>依赖管理就是管理你项目所依赖的第三方资源(jar包。插件…)</p></blockquote></li></ul><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><ul><li><a href="http://maven.apache.org/">官网</a></li><li><a href="http://maven.apache.org/download.cgi">下载地址</a></li><li>解压 apache-maven-3.6.1.rar 即安装完成</li><li>配置环境变量 MAVEN_HOME 为安装路径的bin目录</li><li>配置本地仓库：修改conf&#x2F;settings.xml中的&lt;localRepository&gt;为一个指定目录</li><li>配置阿里云私服，修改conf&#x2F;settings.xml中的&lt;mirrors&gt;标签，为其添加如下子标签<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>compile 编译</li><li>clean 清理</li><li>test 测试</li><li>package 打包</li><li>install 安装<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2></li><li>Maven 构建项目生命周期描述是一次构建过程经历经历了多少个事件</li><li>Maven 对项目构建的生命周期划分为3套<ul><li>clean 清理工作</li><li>default 核心工作 例如编译 测试 打包 安装等</li><li>site 产生报告 发布站点</li></ul></li></ul><p><strong>同一生命周期内，执行后边的命令，前边的所有命令会自动执行</strong></p><h1 id="IDEA-配置Maven"><a href="#IDEA-配置Maven" class="headerlink" title="IDEA 配置Maven"></a>IDEA 配置Maven</h1><h2 id="IDEA-配置Maven-环境"><a href="#IDEA-配置Maven-环境" class="headerlink" title="IDEA 配置Maven 环境"></a>IDEA 配置Maven 环境</h2><ul><li>选择 IDEA 中 File –&gt; Settings</li><li>搜索 maven</li><li>设置 IDEA 使用本地安装的Maven，并修改配置文件路径<h2 id="Maven-坐标详解"><a href="#Maven-坐标详解" class="headerlink" title="Maven 坐标详解"></a>Maven 坐标详解</h2></li><li>什么是坐标 <ul><li>Maven 中的坐标是资源的唯一标识</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul></li><li>Maven 坐标主要组成<ul><li>groupId 定义当前Maven项目隶属组织名称(通常是域名反写 如: com.itheima)</li><li>artifactId 定义当前Maven项目名称(通常是模块名称 如 order-service goods-service)</li><li>version 定义当前项目版本号</li></ul></li></ul><h2 id="IDEA-创建-Maven-项目"><a href="#IDEA-创建-Maven-项目" class="headerlink" title="IDEA 创建 Maven 项目"></a>IDEA 创建 Maven 项目</h2><ul><li>创建模块 选择Maven 点击Next</li><li>填写模块名称 坐标信息 点击finish 创建完成</li><li>编写程序<h2 id="IDEA-导入-Maven-项目"><a href="#IDEA-导入-Maven-项目" class="headerlink" title="IDEA 导入 Maven 项目"></a>IDEA 导入 Maven 项目</h2></li><li>选择右侧Maven面板 点击 + 号</li><li>选中对应项目的pom.xml文件，双击即可</li><li>如果没有Maven面板 选择View -&gt; Appearance -&gt; Tool Window Bars</li></ul><h2 id="配置Maven-Helper-插件"><a href="#配置Maven-Helper-插件" class="headerlink" title="配置Maven-Helper 插件"></a>配置Maven-Helper 插件</h2><ul><li>选择IDEA 中 File -&gt; Settings</li><li>选择 Plugins</li><li>搜索 Maven</li><li>安装 Maven Helper </li><li>重启IDEA</li></ul><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><h2 id="使用坐标导入jar包"><a href="#使用坐标导入jar包" class="headerlink" title="使用坐标导入jar包"></a>使用坐标导入jar包</h2><ul><li>在pom.xml 中编写&lt;dependencies&gt;标签</li><li>在&lt;dependencies&gt; 标签中使用&lt;dependency&gt;引入坐标</li><li>定义坐标的 groupId artifactId version</li><li>点击刷新按钮 使坐标生效<h2 id="使用坐标导入jar包-快捷方式"><a href="#使用坐标导入jar包-快捷方式" class="headerlink" title="使用坐标导入jar包 -快捷方式"></a>使用坐标导入jar包 -快捷方式</h2></li><li>在pom.xml 中按alt + insert，选择Dependency</li><li>在弹出的面板中搜索对应坐标，双击选中</li><li>点击刷新按钮 使坐标生效</li></ul><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><ul><li><p>通过设置坐标的依赖范围(scope)，可以设置对jar包的作用范围：编译环境 测试环境 运行环境</p><table><thead><tr><th>依赖范围</th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例子</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td>system</td><td>Y</td><td>Y</td><td>-</td><td>存储在本地的jar包</td></tr></tbody></table></li><li><p>&lt;scope&gt; 默认值  compile</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2022/07/07/JDBC-1/"/>
      <url>/2022/07/07/JDBC-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>JDBC (Java DataBase Connectivity) 就是使用Java语言操作数据库的一套API</p></blockquote><span id="more"></span><h1 id="JDBC-快速入门"><a href="#JDBC-快速入门" class="headerlink" title="JDBC 快速入门"></a>JDBC 快速入门</h1><ul><li>创建工程，导入jar包</li><li>注册驱动<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获取连接<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = <span class="module-access"><span class="module"><span class="identifier">DriverManager</span>.</span></span>get<span class="constructor">Connection(<span class="params">url</span>,<span class="params">usename</span>,<span class="params">password</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>定义SQL语句<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql <span class="operator">=</span> <span class="string">&quot;update...&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>获取执行SQL对象<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt conn.createStatement()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li>执行SQL<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt.execute<span class="constructor">Update(<span class="params">sql</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>处理返回结果</li><li>释放资源</li></ul><h1 id="API-详解"><a href="#API-详解" class="headerlink" title="API 详解"></a>API 详解</h1><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><ul><li>作用<ul><li>注册驱动<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">-- Driver 类源码</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="type">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var1)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>MYSQL 5之后的驱动包，可以省略注册驱动的步骤，会自动加载jar包中META-INF&#x2F;services&#x2F;java.sql.Driver文件中的驱动类</strong></li><li>获取数据库连接<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Connection   <span class="title">getConnection</span><span class="params">(<span class="type">String</span> url,<span class="type">String</span> user,<span class="type">String</span> password)</span></span></span><br></pre></td></tr></table></figure><ul><li>url : 连接路径<blockquote><p>语法：jdba:mysql:&#x2F;&#x2F;ip地址（域名）:端口号&#x2F;数据库名称？参数键值对1&amp;参数键值对2…<br><br>示例:jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;kris<br><br>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称？键值对<br>配置useSSL &#x3D; false 参数，禁用安全连接方式，解决警告提示</p></blockquote></li><li>user ：用户名</li><li>password ：密码</li></ul></li></ul></li></ul><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><ul><li>作用<ul><li>获取执行SQL的对象<ul><li>执行普通SQL对象  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Statement</span> <span class="function"><span class="title">createStatement</span>()</span></span><br></pre></td></tr></table></figure></li><li>预编译SQL的执行SQL对象：防治SQL注入  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">PreparedStatement</span> <span class="function"><span class="title">prepareStatement</span>(<span class="variable">sql</span>)</span></span><br></pre></td></tr></table></figure></li><li>执行存储过程的对象  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">CallableStatement</span> <span class="function"><span class="title">prepareCall</span>(<span class="variable">sql</span>)</span></span><br></pre></td></tr></table></figure></li></ul></li><li>管理事务<ul><li>MYSQL 事务管理  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启事务：begin<span class="comment">;</span></span><br><span class="line">提交事务：commit<span class="comment">;</span></span><br><span class="line">回滚事务：rollback<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">MYSQL自动提交事务</span><br></pre></td></tr></table></figure></li><li>JDBC 事务管理  <figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启事务：<span class="function"><span class="title">setAutoCommit</span>(<span class="variable">boolean</span> <span class="variable">autoCommit</span>):<span class="variable"><span class="literal">true</span></span>为自动提交，<span class="variable"><span class="literal">false</span></span>为手动提交，即为开始事务</span></span><br><span class="line"><span class="function">提交事务：<span class="title">commit</span>()</span></span><br><span class="line">回滚事务：<span class="function"><span class="title">rollback</span>()</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><ul><li>作用<ul><li>执行SQL语句<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> execute<span class="constructor">Update(<span class="params">sql</span>)</span>; <span class="comment">//执行DML DDL语句</span></span><br><span class="line">返回值：<span class="number">1</span> DML语句影响的行数 <span class="number">2</span> DDL语句执行后，执行成功也可能返回<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ResultSet</span> executeQuery(sql): 执行DQL语句</span><br><span class="line">返回值：<span class="keyword">ResultSet</span> 结果集对象</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><ul><li>作用<ul><li>封装了DQL查询语句的结果<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet stmt.execute<span class="constructor">Query(<span class="params">sql</span>)</span>; <span class="comment">//执行DQL语句，返回ResultSet对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li>获取查询结果<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">boolean</span> <span class="keyword">next</span>(): <span class="number">1</span> 将光标从当前位置向前移动一行 <span class="number">2</span> 判断当前行是否为有效行</span><br><span class="line">返回值</span><br><span class="line">  <span class="literal">true</span> ：有效行，当前行有数据</span><br><span class="line">  <span class="literal">false</span> ： 无效行，当前行没有数据</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xxx getXxx(参数)  <span class="comment">//获取数据</span></span><br><span class="line">  xxx 数据类型 如<span class="built_in">int</span> getInt（参数）</span><br><span class="line">  参数  </span><br><span class="line">      <span class="built_in">int</span> 列的编号 从<span class="number">1</span>开始</span><br><span class="line">      <span class="built_in">String</span> 列的名称</span><br></pre></td></tr></table></figure></li></ul><h2 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h2><ul><li><p>作用</p><ul><li>预编译SQL语句并执行：预防SQL注入问题</li></ul></li><li><p>SQL注入</p><ul><li>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</li></ul></li><li><p>获取 PreparedStatement 对象</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">SQL</span> 语句中的参数值，使用？占位符替代</span><br><span class="line">String <span class="keyword">sql</span> = &quot;select * from username = ? and password = ?&quot;;</span><br><span class="line"></span><br><span class="line">//通过<span class="keyword">Connection</span> 对象获取，并传入对应的<span class="keyword">SQL</span>语句</span><br><span class="line">PreparedStatement pstmt = conn.prepareStatement(<span class="keyword">sql</span>);</span><br></pre></td></tr></table></figure></li><li><p>设置参数值</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement对象：<span class="keyword">set</span>Xxx（参数1，参数2）：给 ？ 赋值</span><br><span class="line">Xxx：数据类型</span><br><span class="line">参数：</span><br><span class="line">  参数1：？的位置编号，从1开始</span><br><span class="line">  参数2：？的值</span><br></pre></td></tr></table></figure></li><li><p>执行SQL</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executeUpdate<span class="comment">()</span>;/executeQuery<span class="comment">()</span>; : 不需要再传递SQL</span><br></pre></td></tr></table></figure></li><li><p>好处</p><ul><li>预编译SQL 性能更高</li><li>防止SQL注入，将敏感字符转义</li></ul></li><li><p>原理</p><ul><li>在获取PreparedStatement对象时，将SQL语句发送给MYSQL服务器进行检查，编译</li><li>执行时就不用再进行这些步骤，速度更快</li><li>如果SQL模板一样，则只需要进行一次检查，编译</li></ul></li></ul><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul><li>数据库连接池是个容器，负责分配，管理数据库连接</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</li><li>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</li><li>好处<ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li></ul><h2 id="数据库连接池实现"><a href="#数据库连接池实现" class="headerlink" title="数据库连接池实现"></a>数据库连接池实现</h2><ul><li>标准接口 ：DataSource<ul><li>官方(SUN)提供的数据库连接池标准接口，由第三方组织实现此接口。</li><li>功能： 获取连接<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Connection</span> <span class="function"><span class="title">getConnection</span>()</span></span><br></pre></td></tr></table></figure></li></ul></li><li>常见的数据库连接池：<ul><li>D8CP</li><li>C3P0</li><li>Druid</li></ul></li><li>Druid(德鲁伊)<ul><li>Druid连接池是阿里巴巴开源的数据库连接池项目</li><li>功能强大，性能优秀，是Java语言最好的数据库连接池之一</li></ul></li></ul><h2 id="Druid-使用步骤"><a href="#Druid-使用步骤" class="headerlink" title="Druid 使用步骤"></a>Druid 使用步骤</h2><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//druid.properties</span><br><span class="line"><span class="attribute">driverClassName</span> <span class="operator">=</span> com.mysql.jdbc.Driver</span><br><span class="line"><span class="attribute">url</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="attribute">username</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="attribute">password</span> <span class="operator">=</span> ...</span><br><span class="line">//初始话连接数量</span><br><span class="line"><span class="attribute">initialSize</span> <span class="operator">=</span> ...</span><br><span class="line">//最大连接数量</span><br><span class="line"><span class="attribute">maxActive</span> <span class="operator">=</span> ...</span><br><span class="line">// 最大等待时间</span><br><span class="line"><span class="attribute">maxWait</span> <span class="operator">=</span> ...</span><br></pre></td></tr></table></figure></li><li>加载配置文件<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;文件路径&quot;</span>));</span><br></pre></td></tr></table></figure></li><li>获取数据库连接池对象<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = <span class="module-access"><span class="module"><span class="identifier">DruidDataSourceFactory</span>.</span></span>create<span class="constructor">DataSource(<span class="params">prop</span>)</span>;</span><br></pre></td></tr></table></figure></li><li>获取连接<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection <span class="operator">=</span> dataSource.getConnection()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL---(3)</title>
      <link href="/2022/07/06/MYSQL-3/"/>
      <url>/2022/07/06/MYSQL-3/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>  SQL（Structured Query Language）,结构化查询语言，一门操作关系型数据库的编程语言，定义操作所有<a href="https://cn.bing.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&qs=SC&pq=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&sk=SC1&sc=8-6&cvid=959A8ABF9CB1416DB320362EC1B3BA5A&FORM=QBRE&sp=2">关系型数据库</a>的统一标准。不同数据库操作的方式可能存在一些不一样的地方</p><span id="more"></span><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>约束是作用于表中列上的规则，用于限制加入表的数据</li><li>约束的存在保证了数据库中数据的正确性，有效性和完整性</li></ul><h2 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h2><table><thead><tr><th>约束名称</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>保证列中数据不能有null值</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证列中所有数据各不相同</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>检查约束</td><td>保证列中的值满足某一条件</td><td>CHECK</td></tr><tr><td>默认约束</td><td>保存数据时，未指定值则采用默认值</td><td>DEFAULT</td></tr><tr><td>外键约束</td><td>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>MYSQL不支持检查约束</li><li>多个约束并排写中间空格</li><li>auto_increment 自增长 (当列是数字并且唯一约束)</li></ul><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3></li><li>添加约束  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加外键约束</span></span><br><span class="line">creat <span class="keyword">table</span> 表名(</span><br><span class="line">列名 数据类型;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key(外键列名) refereinces 主表(主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表后添加外键约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 外键名称 <span class="keyword">foreign</span> key （外键字段名称） <span class="keyword">references</span> 主表名称（主表列名称）;</span><br></pre></td></tr></table></figure></li><li>删除约束  <figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> 外键名称;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h3><ul><li>先建主表后建从表才能添加外键</li><li>外键名称一般为fk开头链接两关联主表的字段名称</li></ul><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ul><li>根据业务系统的具体需求，结合所选用的DBMS，为这个业务系统构造出最优的数据存储模型。</li><li>建立数据库中的表结构以及表与表之间的关联关系的过程。</li></ul><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h2><ul><li>需求分析 </li><li>逻辑分析</li><li>物理设计</li><li>维护设计</li></ul><h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h2><ul><li>一对一<ul><li>用户和用户详情</li><li>用于表拆分和提升查询性能</li><li><strong>实现方式</strong>：唯一外键</li></ul></li><li>一对多<ul><li>部门和员工</li><li><strong>实现方式</strong> ： 在多的一方建立外键，指向一的一方的主键</li></ul></li><li>多对多<ul><li>商品和订单</li><li><strong>实现方式</strong> ： 建立第三张中间表，中间表至少包含两个外键，分别对应两方主键</li></ul></li></ul><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><pre><code>相当于查询A B表交集数据</code></pre><ul><li><p>语法</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式内连接</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>，表<span class="number">2.</span>.. <span class="keyword">where</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示外连接</span></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> [<span class="keyword">inner</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3></li><li><p>语法</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 左外连接</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件;</span><br><span class="line"></span><br><span class="line">-- 右外连接</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件;</span><br></pre></td></tr></table></figure></li><li><p>左外连接</p><blockquote><p>相当于查询A表所有数据和交集部分数据</p></blockquote></li><li><p>右外连接</p><blockquote><p>相当于查询B表所有数据和交集部分数据</p></blockquote><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2></li><li><p>概念</p><blockquote><p>查询中嵌套查询 称为子查询</p></blockquote></li><li><p>根据查询结果不同，作用不同</p><ul><li>单行单列  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表 <span class="keyword">where</span> 字段名 = （子查询）;</span><br></pre></td></tr></table></figure></li><li>多行单列  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表 <span class="keyword">where</span> 字段名 <span class="keyword">in</span> （子查询）;</span><br></pre></td></tr></table></figure></li><li>多行多列 ： 作为虚拟表  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> （子查询） <span class="keyword">where</span> 条件;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>数据库的事务(Transaction) 是一种机制 一个操作序列，包含了一组数据库操作命令</li><li>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败</li><li>事务是一个不可分割的工作逻辑单元</li></ul><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 回滚事务 </span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h2 id="事务的四大特征"><a href="#事务的四大特征" class="headerlink" title="事务的四大特征"></a>事务的四大特征</h2><ul><li>原子性(Atomictity): 事务是不可分割的最小操作单位，要么同时成功，要么同时失败</li><li>一致性(Consistency): 事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性(Isolation): 多个事务之间，操作的可见性</li><li>持久性(Durability): 事务一但提交或回滚，它对数据库中的数据的该表就是永久的</li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL---(2)</title>
      <link href="/2022/07/05/MYSQL-2/"/>
      <url>/2022/07/05/MYSQL-2/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>  SQL（Structured Query Language）,结构化查询语言，一门操作关系型数据库的编程语言，定义操作所有<a href="https://cn.bing.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&qs=SC&pq=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&sk=SC1&sc=8-6&cvid=959A8ABF9CB1416DB320362EC1B3BA5A&FORM=QBRE&sp=2">关系型数据库</a>的统一标准。不同数据库操作的方式可能存在一些不一样的地方</p><span id="more"></span><h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><blockquote><p>Data Query Language 数据查询语言，用于查询数据库中表的数据</p></blockquote><h2 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  字段列表</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">  表名列表</span><br><span class="line"><span class="keyword">where</span>      <span class="comment">-- 条件查询 </span></span><br><span class="line">  条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>   <span class="comment">--分组查询</span></span><br><span class="line">  分组字段</span><br><span class="line"><span class="keyword">having</span> </span><br><span class="line">  分组后条件</span><br><span class="line">orded <span class="keyword">by</span>   <span class="comment">--排序查询</span></span><br><span class="line">  排序字段</span><br><span class="line"><span class="keyword">limit</span>      <span class="comment">--分页查询</span></span><br><span class="line">  分页限定</span><br></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><ul><li>去除重复记录<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> distinct <span class="params">...</span> from <span class="params">...</span></span><br></pre></td></tr></table></figure></li><li>起别名<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 <span class="keyword">as</span> （可省略用空格隔开） 别名</span><br></pre></td></tr></table></figure></li></ul><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ul><li><p>语法</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">where</span>条件列表;</span><br></pre></td></tr></table></figure></li><li><p>条件</p><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>between…and…</td><td>在某个范围之间</td></tr><tr><td>in(…)</td><td>多选一</td></tr><tr><td>like 占位符</td><td>模糊查询，_表示任意单个字符，%表示多个任意字符</td></tr><tr><td>is NULL</td><td>是NULL</td></tr><tr><td>is not NULL</td><td>不是NULL</td></tr><tr><td>and</td><td>并且</td></tr><tr><td>or</td><td>或者</td></tr><tr><td>nor</td><td>非</td></tr></tbody></table></li></ul><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><ul><li><p>语法</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 排序字段名<span class="number">1</span> 排序方式<span class="number">1</span>，...;</span><br></pre></td></tr></table></figure></li><li><p>排序方式</p><ul><li>ASC : 升序排列 （默认）</li><li>DESC : 降序排列</li></ul><p><em><strong>如果有多个排序条件，当前边条件值一样时，才根据第二条件进行排序</strong></em></p></li></ul><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ul><li>语法<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 分组前条件限定] <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名 [<span class="keyword">having</span> 分组后条件过滤];</span><br></pre></td></tr></table></figure><strong>分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</strong></li></ul><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><blockquote><p>将一列数据作为一个整体，进行纵向计算</p></blockquote><ul><li><p>分类</p><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>count(列名)</td><td>统计数量(一般选用不为null的列)</td></tr><tr><td>max(列名)</td><td>最大值</td></tr><tr><td>min(列名)</td><td>最小值</td></tr><tr><td>sum(列名)</td><td>求和</td></tr><tr><td>avg(列名)</td><td>平均值</td></tr></tbody></table></li><li><p>语法</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 聚合函数名（列名） <span class="keyword">from</span> 表;</span><br></pre></td></tr></table></figure></li></ul><p><em><strong>null值不参与所有聚合函数运算</strong></em></p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ul><li>语法<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">limit</span> 起始索引，查询条目数;</span><br></pre></td></tr></table></figure><strong>起始索引从0开始</strong><br><strong>计算公式：起始索引 &#x3D; （当前页码-1）* 每页显示的条数</strong></li><li>tips<ul><li>分页查询limit是MYSQL数据库特有</li><li>Oracle 分页查询使用 rownumber</li><li>SQL Sever 使用top</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL---(1)</title>
      <link href="/2022/07/04/MYSQL-1/"/>
      <url>/2022/07/04/MYSQL-1/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h1><p>  SQL（Structured Query Language）,结构化查询语言，一门操作关系型数据库的编程语言，定义操作所有<a href="https://cn.bing.com/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&qs=SC&pq=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&sk=SC1&sc=8-6&cvid=959A8ABF9CB1416DB320362EC1B3BA5A&FORM=QBRE&sp=2">关系型数据库</a>的统一标准。不同数据库操作的方式可能存在一些不一样的地方</p><span id="more"></span><h1 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h1><ul><li><p>SQL语句可以多行或者单行书写，以分号结尾。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">database</span>;   </span><br></pre></td></tr></table></figure></li><li><p>MySQL 数据库的SQL语句不区分大小写，关键字建议大写</p></li><li><p>注释</p><ul><li>单行注释： – 注释内容 或者 #注释内容（MYSQL特有）</li><li>多行注释：&#x2F;* 注释 *&#x2F;</li></ul></li></ul><h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><blockquote><p>Data Definition Language  数据定义语言，用来定义数据库对象；数据库，表，列等</p></blockquote><h2 id="操作库"><a href="#操作库" class="headerlink" title="操作库"></a>操作库</h2><ul><li><p>查询</p>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据库</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>创建数据库（判断，如果不存在则创建）</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>删除数据库</p>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>查看当前使用的数据库</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">database</span>()</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用数据库</p>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名称<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><ul><li>查询表<ul><li>查询当前数据库下所有表名称  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure></li><li>查询表结构  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名称</span><br></pre></td></tr></table></figure></li></ul></li><li>创建表  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    字段名<span class="number">1</span> 数据类型<span class="number">1</span>，</span><br><span class="line">    字段名<span class="number">2</span> 数据类型<span class="number">2</span>，</span><br><span class="line">    <span class="comment">----</span></span><br><span class="line">    字段名n 数据类型n  <span class="comment">/*最后不加逗号*/</span></span><br><span class="line">)；</span><br></pre></td></tr></table></figure></li><li>删除表  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> 表名称;</span><br></pre></td></tr></table></figure></li><li>修改表<ul><li>修改表名  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">rename</span> <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure></li><li>添加一列  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 数据类型;</span><br></pre></td></tr></table></figure></li><li>修改数据类型  <figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">modify</span> 列名 新数据类型;</span><br></pre></td></tr></table></figure></li><li>修改列名和数据类型  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter <span class="keyword">table</span> 表名 change 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure></li><li>删除列  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><blockquote><p>Data Manipulation Language 数据操作语言，是指在SQL语言中，负责对数据库对象运行数据访问工作的指令集。</p></blockquote><ul><li>添加数据<ul><li>给指定列表添加数据  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">insert</span> into 表名（列名<span class="number">1</span>，列名<span class="number">2</span>，...） values(值<span class="number">1</span>，值<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li>给全部列添加数据  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>，值<span class="number">2</span> ...);<span class="comment">-- 按照列的顺序添加值;</span></span><br></pre></td></tr></table></figure></li><li>批量添加数据  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">insert</span> into 表名(列<span class="number">1</span>，列<span class="number">2</span>，...) values(值<span class="number">1</span>，值<span class="number">2</span>，...),(值<span class="number">1</span>，值<span class="number">2</span>，...)...;</span><br><span class="line"></span><br><span class="line"><span class="attribute">insert</span> into 表名 values(值<span class="number">1</span>，值<span class="number">2</span>...),(值<span class="number">1</span>，值<span class="number">2</span>...);</span><br></pre></td></tr></table></figure></li></ul></li><li>修改数据  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 <span class="keyword">set</span> 列名<span class="number">1</span> = 值<span class="number">1</span>，列名<span class="number">2</span> = 值<span class="number">2</span>，...[<span class="keyword">where</span> 条件]<span class="punctuation">;</span><span class="comment">(***不加条件，所有数据都会修改！***)</span></span><br></pre></td></tr></table></figure></li><li>删除数据  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]<span class="punctuation">;</span><span class="comment">(***不加则所有数据都会被删除***)</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 注解</title>
      <link href="/2022/05/07/Java-%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/05/07/Java-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是注解-Annotation"><a href="#什么是注解-Annotation" class="headerlink" title="什么是注解(Annotation)"></a>什么是注解(Annotation)</h1><blockquote><p>代码的特殊标识，可以在编译，类加载，运行时被读取，并执行相对应的处理，以便于其他工具补充信息或者进行部署</p></blockquote><span id="more"></span><h1 id="内注解"><a href="#内注解" class="headerlink" title="内注解"></a>内注解</h1><ul><li><p>@Override - 检查该方法是否是重写方法，如果发现其父类，或者是应用的接口中并没有该方法时，会报编译错误</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//将会报编译错误</span></span><br><span class="line">    void say()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Deprecated - 标记过时方法。如果使用该方法，将会报编译警告</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">     son s = <span class="keyword">new</span> <span class="title function_">son</span>();</span><br><span class="line">     <span class="comment">//使用时会显示已废弃 </span></span><br><span class="line">     s.<span class="title function_">say</span>();</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@SuppressWarnings - 指示编译器忽略注解中声明的警告 该注解需要传入参数</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">    deprecation:</span> 使用了不赞成使用的类或方法时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    unchecked:</span> 执行了未检查的转换时的警告，例如当使用了集合时没有用泛型(Generics)来指定集合保存的类型</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    fallthrough:</span> 当switch程序块直接通往下一种情况而没有使用break时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    path:</span> 在类路径 源文件路径等中有不存在的路径时的警告</span><br><span class="line"><span class="symbol">   </span></span><br><span class="line"><span class="symbol">    serial:</span> 当在可序列化的类上缺少serialVersionUID定义时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    finally:</span> 任何finally子句不能正常完成时的警告</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    all:</span> 关于以上所有情况的警告</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">// 消除了age没有使用的警告</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">son</span>();</span><br><span class="line">    s.say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><blockquote><p>作用在其他注解的注解</p></blockquote><ul><li><p>@Retention - 标识这个注解如何保存，是在代码中，还是编译进class中，或者实在运行时可以通过反射访问</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation</span><br><span class="line"><span class="keyword">public</span> enum RetentionPolicy &#123;</span><br><span class="line">   <span class="comment">//Annotation信息仅存在于编译器处理期间</span></span><br><span class="line">   <span class="comment">//编译器处理完之后就没有该Annotation信息</span></span><br><span class="line">    <span class="keyword">SOURCE</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Annotation信息存储于类对应的class文件之中 (默认)</span></span><br><span class="line">    <span class="keyword">CLASS</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">//Annotation信息存储于class文件中，并且可由JVM读入</span></span><br><span class="line">    <span class="keyword">RUNTIME</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Documented - 标记这个注解是否包含在用户文档中</p></li><li><p>Target - 标记这个注解一个是哪种java成员</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package java.lang.annotation</span><br><span class="line">public enum ElementType &#123;</span><br><span class="line">      <span class="regexp">//</span>类，接口(包括注释类型) 枚举 </span><br><span class="line">      TYPE,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>字段声明(包括枚举变量)</span><br><span class="line">      FIELD,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>方法声明</span><br><span class="line">      METHOD,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>参数声明</span><br><span class="line">      PARAMETER,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>构造方法声明</span><br><span class="line">      CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>局部变量声明</span><br><span class="line">      LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>注释类型声明</span><br><span class="line">      ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">      <span class="regexp">//</span>包声明</span><br><span class="line">      PACKAGE,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>@Inherited - 标记这个注解是继承于哪个注解类(默认注解并没有继承于任何子类)</p></li></ul><h1 id="Annotation的通用定义"><a href="#Annotation的通用定义" class="headerlink" title="Annotation的通用定义"></a>Annotation的通用定义</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Target</span>(ElementType TYPE)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> MyAnnotation&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@interface 使用@interface 定义注解时，意味着它实现了java.lang.annotation.Annotation 接口，即该注解就是一个Anonotation<br></li><li>定义注解时，@interface 时必须的</li><li>Annotation 接口的实现细节都由编译器完成 通过@interface 定义注解后，该注解不能继承其他注解或接口</li></ul><h1 id="新增接口-java-7-后"><a href="#新增接口-java-7-后" class="headerlink" title="新增接口(java 7 后)"></a>新增接口(java 7 后)</h1><ul><li>SafeVarargs - 忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告</li><li>FunctionalInterface - 标识一个匿名函数或者函数式接口</li><li>Repeatable - 标识某注解可以在同一个声明上使用多次</li></ul><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://www.runoob.com/w3cnote/java-annotation.html">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射</title>
      <link href="/2022/05/04/Java-%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/05/04/Java-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射概述（Reflection）"><a href="#反射概述（Reflection）" class="headerlink" title="反射概述（Reflection）"></a>反射概述（Reflection）</h1><blockquote><p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。</p></blockquote><span id="more"></span><h1 id="反射机制的作用"><a href="#反射机制的作用" class="headerlink" title="反射机制的作用"></a>反射机制的作用</h1><blockquote><ul><li>在运行程序时构造任意一个已知类名称的对象</li><li>在运行时获取或调用类的属性和方法</li><li>生成动态代理</li></ul></blockquote><h2 id="获取类名的三种方式"><a href="#获取类名的三种方式" class="headerlink" title="获取类名的三种方式"></a>获取类名的三种方式</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">package</span> test01;</span><br><span class="line">    <span class="keyword">class</span> test&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">//第一种 通过对象的getClass()方法        Person p1 = new Person();</span></span><br><span class="line">        <span class="keyword">Class</span> c1 = p1.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种 通过类名.class的方式得到，最安全，性能最高，说明每个类都有一个隐藏的静态成员变量class</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">Class</span> c2 = Person.<span class="keyword">class</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种 通过Class对象的forName()静态方法获取，最常用，需要抛出ClassNotFound 异常</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">Class</span> c3 = <span class="keyword">Class</span>.forName(<span class="string">&quot;test01.Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>注意</strong></em>：一个类在JVM中只存在一个Class实例，所以以上c1&#x3D;c2&#x3D;c3</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个Person类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//共有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    Person()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    Person(String name,<span class="built_in">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;say&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class中的各种方法"><a href="#Class中的各种方法" class="headerlink" title="Class中的各种方法"></a>Class中的各种方法</h2><p><img src="/../../themes/next/source/images/ClassFunction.png"><br></p><ul><li>getName()：获得类的完整名字。</li><li>getFields()：获得类的public类型的属性。</li><li>getDeclaredFields()：获得类的所有属性。包括private 声明的和继承类</li><li>getMethods()：获得类的public类型的方法。</li><li>getDeclaredMethods()：获得类的所有方法。包括private 声明的和继承类</li><li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。</li><li>getConstructors()：获得类的public类型的构造方法。</li><li>getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。</li><li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</li></ul><h2 id="所获取的方法激活以及属性的修改"><a href="#所获取的方法激活以及属性的修改" class="headerlink" title="所获取的方法激活以及属性的修改"></a>所获取的方法激活以及属性的修改</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Class c1 = <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="string">&quot;Person&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">//通过构造方法实例化对象</span></span><br><span class="line">    Person p1 = (Person)(c1.get<span class="constructor">Constructor()</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取方法 第二个参数为形参的类 比如String.class</span></span><br><span class="line">    Method <span class="keyword">method</span> = c1.get<span class="constructor">Method(<span class="string">&quot;say&quot;</span>, <span class="params">null</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数激活，第一个参数为对象，第二个参数为传入的形参</span></span><br><span class="line">    <span class="keyword">method</span>.invoke(p1, null);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//通过构造方法实例化对象</span></span><br><span class="line">    Person p2 = (Person)(c1.get<span class="constructor">Constructor()</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取属性</span></span><br><span class="line">    Field name = c1.get<span class="constructor">DeclaredField(<span class="string">&quot;name&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置是否自检 true为取消访问检查 私有类型的修改不关闭检查则会报错</span></span><br><span class="line">    name.set<span class="constructor">Accessible(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置属性 第一个参数为对象，第二个参数为值</span></span><br><span class="line">    name.set(p2,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h1><pre><code>待续</code></pre><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://www.cnblogs.com/mikechenshare/p/15796381.html">mikechen</a><br><br><a href="https://www.w3cschool.cn/java/java-reflex.html">W3Cschool</a><br><br><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">敬业小码哥</a><br><br><a href="https://www.cnblogs.com/ysocean/p/6516248.html">IT可乐</a><br><br><a href="https://www.bilibili.com/video/BV1p4411P7V3?p=17">狂神说Java(视频)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java I/O</title>
      <link href="/2022/05/02/Java-I-O/"/>
      <url>/2022/05/02/Java-I-O/</url>
      
        <content type="html"><![CDATA[<h1 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h1><p>流：代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象</p><p>流的本质:数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p><p>作用：为数据源和目的地建立一个输送通道</p><span id="more"></span><h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ul><li><p>流向不同 分为输入输出流<br></p><ul><li><p><strong>输出</strong>：把程序(内存)中的内容输出到磁盘、光盘等存储设备中</p></li><li><p><strong>输入</strong>：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中</p></li></ul></li><li><p>处理的数据类型不同 分为字节流和字符流<br></p><ul><li><strong>字节流</strong>： 可以用于读写二进制文件及任意类型文件（如图片 等），读取时一字节为单位（8 bit），同时字节流在操作时不会将数据读取到缓冲区，而是对文件本身进行直接操作，通常情况下采取这种方式</li><li><strong>字符流</strong>： 可以用于读取文本文件。在java中，字符采取Unicode标准，一个字符为16位，所以字符流通常用于处理字符类型的数据，字符流操作时会将数据先读取到缓冲区，只有在流关闭时或者使用flush才能对文件进行操作，一般只在处理纯文本数据时使用。</li></ul></li><li><p>根据功能不同 分为节点流和处理流<br></p><ul><li><strong>节点流</strong>： 可以从或向一个特定的地方(节点)读写数据。如FileInputStream，FileReader，节点流是直接作用在文件上的流，可以理解为一个管道，文件在管道中传输。</li><li><strong>处理流</strong>：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接，处理流是作用在已有的节点流基础上，是包在节点流的外面的管道(可多层)，其目的是让管道内的流可以更快的传输</li></ul></li></ul><h1 id="IO流的五类一接口"><a href="#IO流的五类一接口" class="headerlink" title="IO流的五类一接口"></a>IO流的五类一接口</h1><ul><li>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等</li><li>InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征</li><li>OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征</li><li>Reader（文件格式操作）：抽象类，基于字符的输入操作</li><li>Writer（文件格式操作）：抽象类，基于字符的输出操作</li><li>RandomAccessFile（p随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作</li><li>Serializable： 一个空接口，为对象提供标准的序列化与反序列化操作</li></ul><h1 id="IO流整体框架"><a href="#IO流整体框架" class="headerlink" title="IO流整体框架"></a>IO流整体框架</h1><p><a href="https://img-blog.csdnimg.cn/img_convert/ff708c54547127a831997b01789f07ea.png">javaIO</a><br><br><a href="https://img-blog.csdnimg.cn/img_convert/9092b53635a76155b8189d96e2f866be.png">javaIO</a></p><h1 id="Java-IO流对象介绍"><a href="#Java-IO流对象介绍" class="headerlink" title="Java IO流对象介绍"></a>Java IO流对象介绍</h1><h2 id="字节输入流InputStream"><a href="#字节输入流InputStream" class="headerlink" title="字节输入流InputStream"></a>字节输入流InputStream</h2><ul><li><p>InputStream：字节输入流基类，是所有的字节输入流的父类，它是一个抽象类。</p></li><li><p>FileInputSream：文件输入流。它通常用于对文件进行读取操作。</p></li><li><p>FilterInputStream ：过滤流。作用是为基础流提供一些额外的功能。装饰者模式中处于装饰者，具体的装饰者都要继承它，所以在该类的子类下都是用来装饰别的流的，也就是处理类。</p></li><li><p>BufferedInputStream：缓冲流。对处理流进行装饰，增强，内部会有一个缓存区，用来存放字节，每次都是将缓存区存满然后发送，而不是一个字节或两个字节这样发送。效率更高。</p></li><li><p>DataInputStream：数据输入流。它是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。</p></li><li><p>PushbakInputStream：回退输入流。java中读取数据的方式是顺序读取,如果某个数据不需要读取，需要程序处理。PushBackInputStream就可以将某些不需要的数据回退到缓冲中。</p></li><li><p>ObjectInputStream：对象输入流。用来提供对“基本数据或对象”的持久存储。通俗点讲，也就是能直接传输对象(反序列化中使用)。</p></li><li><p>PipedInputStream：管道字节输入流。它和PipedOutputStream一起使用，能实现多线程间的管道通信。</p></li><li><p>SequenceInputStream:合并输入流。依次将多个源合并成一个源。</p></li><li><p>StringBufferInputStream:字符相关流。已经过时。</p></li><li><p>ByteArrayInputStream：字节数组输入流，该类的功能就是从字节数组(byte[])中进行以字节为单位的读取，也就是将资源文件都以字节的形式存入到该类中的字节数组中去，我们拿也是从这个字节数组中拿。</p></li></ul><h2 id="字节输出流OutputStream"><a href="#字节输出流OutputStream" class="headerlink" title="字节输出流OutputStream"></a>字节输出流OutputStream</h2><ul><li><p>OutputStream：字节输出流基类，是所有的字节输出流的父类，它是一个抽象类。</p></li><li><p>FileOutputStream：文件输出流。该类实现了一个输出流，将数据输出到文件。</p></li><li><p>FilterOutputStream ：过滤流。用来封装其它的输出流，并为它们提供额外的功能(序列化中使用)。它主要包括BufferedOutputStream, DataOutputStream和PrintStream。</p></li><li><p>BufferedOutputStream：缓冲输出流。给输出流提供缓冲功能。</p></li><li><p>DataOutputStream：是用来装饰其它输出流，将DataOutputStream和DataInputStream输入流配合使用，“允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型”。</p></li><li><p>PrintStream：是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p></li><li><p>ObjectOutputStream：对象输出流。该类将实现了序列化的对象序列化后写入指定地方。</p></li><li><p>PipedOutputStream：管道字节输出流。它和PipedInputStream一起使用，能实现多线程间的管道通信，是管道的发送端。</p></li><li><p>ByteArrayOutputStream：字节数组输出流。该类实现了一个输出流，其数据被写入由byte数组充当的缓冲区，缓冲区会随着数据的不断写入而自动增长</p></li></ul><h2 id="字符输入流Reader"><a href="#字符输入流Reader" class="headerlink" title="字符输入流Reader"></a>字符输入流Reader</h2><ul><li><p>Reader：是所有的输入字符流的父类，它是一个抽象类。</p></li><li><p>CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。</p></li><li><p>PipedReader 是从与其它线程共用的管道中读取数据。</p></li><li><p>BufferedReader是一个装饰器，它和其子类LineNumberReader负责装饰其它Reader对象。</p></li><li><p>InputStreamReader：是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。</p></li><li><p>FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader对象进行装饰，会增加一个行号</p></li></ul><h2 id="字符输出流Writer"><a href="#字符输出流Writer" class="headerlink" title="字符输出流Writer"></a>字符输出流Writer</h2><ul><li><p>Writer：是所有的输出字符流的父类，它是一个抽象类。</p></li><li><p>CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据，</p></li><li><p>BufferedWriter 是一个装饰器为Writer 提供缓冲功能。</p></li><li><p>PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。</p></li><li><p>OutputStreamWriter：是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类(具体可以研究一SourceCode)。功能和使用和OutputStream 极其类似。</p></li></ul><h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><p><a href="https://blog.csdn.net/weixin_33602738/article/details/114146995">塔塔君Minkun</a><br><br><a href="https://blog.csdn.net/i6223671/article/details/89041879">Junieson</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的ArrayList</title>
      <link href="/2022/04/15/java%E4%B8%AD%E7%9A%84ArrayList/"/>
      <url>/2022/04/15/java%E4%B8%AD%E7%9A%84ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的ArrayList"><a href="#Java中的ArrayList" class="headerlink" title="Java中的ArrayList"></a>Java中的ArrayList</h1><blockquote><p>ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。<br>ArrayList 继承了 AbstractList ，并实现了 List 接口。</p></blockquote><span id="more"></span><h2 id="引入以及初始化"><a href="#引入以及初始化" class="headerlink" title="引入以及初始化"></a>引入以及初始化</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">ArrayList</span>; <span class="comment">//引入</span></span><br><span class="line">    <span class="built_in">ArrayList</span>&lt;E&gt; objectName = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;&gt;(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">ArrayList</span>&lt;E&gt; objectName = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;&gt;(<span class="type">int</span> initalCapacity); <span class="comment">// 初始化容量</span></span><br><span class="line">    <span class="built_in">ArrayList</span>&lt;E&gt; objectName = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;&gt;(Collection c);</span><br><span class="line">    <span class="comment">//使用集合类的对象进行初始化（set, list,map）等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-ArrayList常用方法"><a href="#Java-ArrayList常用方法" class="headerlink" title="Java  ArrayList常用方法"></a>Java  ArrayList常用方法</h2><ul><li><p>add(int index, E element)<br></p><blockquote><p>将指定元素插入到指定位置,如果无参则默认从末尾插入</p></blockquote><hr></li><li><p>addAll(int index,Collection<E> c)</E></p><blockquote><p>将集合类对象全部插入到指定位置，如果无参则默认从末尾插入</p></blockquote><hr></li><li><p>clear()</p><blockquote><p>清空链表</p></blockquote><hr></li><li><p>clone()</p><blockquote><p>克隆链表 用链表接收返回值</p></blockquote><hr></li><li><p>contains(Object o)</p><blockquote><p>判断链表中是否包含某一元素 返回一个boolean 类型的值</p></blockquote><hr></li><li><p>containsAll(Collection&lt;&gt; o)</p><blockquote><p>判断是否全部包含Collection中的元素</p></blockquote><hr></li><li><p>get(int index)</p><blockquote><p>获得该下标的元素</p></blockquote><hr></li><li><p>indexOf(Object o)</p><blockquote><p>获得在链表中该元素的下标位置</p></blockquote><hr></li><li><p>remove(int index || Object o)</p><blockquote><p>去除链表中该下标位置的元素或与o相同的元素</p></blockquote></li><li><p>subList(int fromIndex,int toIndex)</p><blockquote><p>截取从fromIndex到toIndex的元素 返回值为list</p></blockquote><hr></li><li><p>set(int index,Object element)</p><blockquote><p>替换 arraylist 中指定索引的元素</p></blockquote><hr></li><li><p>sort(Comparator c)</p><blockquote><p>对 arraylist 元素进行排序<br><br>  Comparator 顺序方式 <br><br>  Comparator.naturalOrder() 升序<br>  Comparator.reverseOrder() 降序</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://www.runoob.com/java/java-arraylist.html">菜鸟教程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql语句的执行顺序以及流程</title>
      <link href="/2022/04/02/sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/04/02/sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="sql语句的执行顺序以及流程"><a href="#sql语句的执行顺序以及流程" class="headerlink" title="sql语句的执行顺序以及流程"></a>sql语句的执行顺序以及流程</h1><blockquote><p>程序员对sql语句的执行顺序的透彻掌握，是避免编程中各种bug和错误，歧义语句的不二法则。</p></blockquote><span id="more"></span><h1 id="SQL-Select-语句完整的执行顺序："><a href="#SQL-Select-语句完整的执行顺序：" class="headerlink" title="SQL Select 语句完整的执行顺序："></a>SQL Select 语句完整的执行顺序：</h1><p>1、from 子句组装来自不同数据源的数据；<br><br>2、where 子句基于指定的条件对记录行进行筛选； <br><br>3、group by 子句将数据划分为多个分组； <br><br>4、使用聚集函数进行计算； <br><br>5、使用 having 子句筛选分组；<br><br>6、计算所有的表达式；<br>7、select 的字段；<br><br>8、使用 order by 对结果集进行排序。<br></p><p>SQL 语言不同于其他编程语言的最明显特征是处理代码的顺序。 在大多数据库语言中，代码按编码顺序被处理。但在 SQL 语句中，第一个被处理的子句式 FROM，而不是第一出现的 SELECT。</p><h1 id="SQL-查询处理的步骤序号："><a href="#SQL-查询处理的步骤序号：" class="headerlink" title="SQL 查询处理的步骤序号："></a>SQL 查询处理的步骤序号：</h1><p>(1) FROM <left_table> <br><br>(2) <join_type> JOIN <right_table> <br><br>(3) ON <join_condition> <br><br>(4) WHERE <where_condition> <br><br>(5) GROUP BY <group_by_list><br><br>(6) WITH {CUBE | ROLLUP} <br><br>(7) HAVING <having_condition> <br><br>(8) SELECT (9) DISTINCT <br><br>(9) ORDER BY <order_by_list> <br><br>(10) <TOP_specification> <select_list><br></select_list></TOP_specification></order_by_list></having_condition></group_by_list></where_condition></join_condition></right_table></join_type></left_table></p><p>以上每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者(客户端应 用程序或者外部查询)不可用。只有最后一步生成的表才会会给调用者。如果没有在查询中指定某一个子句， 将跳过相应的步骤。</p><h1 id="逻辑查询处理阶段简介："><a href="#逻辑查询处理阶段简介：" class="headerlink" title="逻辑查询处理阶段简介："></a>逻辑查询处理阶段简介：</h1><p>1、 FROM：对 FROM 子句中的前两个表执行笛卡尔积(交叉联接)，生成虚拟表 VT1。</p><p>2、 ON：对 VT1 应用 ON 筛选器，只有那些使为真才被插入到 TV2。 </p><p>3、 OUTER (JOIN):如果指定了 OUTER JOIN(相对于 CROSS JOIN 或 INNER JOIN)，保留表中未找到 匹配的行将作为外部行添加到 VT2，生成 TV3。如果 FROM 子句包含两个以上的表，则对上一个联接生成的 结果表和下一个表重复执行步骤 1 到步骤 3，直到处理完所有的表位置。</p><p>4、 WHERE：对 TV3 应用 WHERE 筛选器，只有使为 true 的行才插入 TV4。 </p><p>5、 GROUP BY：按 GROUP BY 子句中的列列表对 TV4 中的行进行分组，生成 TV5。 </p><p>6、 CUTE|ROLLUP：把超组插入 VT5，生成 VT6。 </p><p>7、 HAVING：对 VT6 应用 HAVING 筛选器，只有使为 true 的组插入到 VT7。 </p><p>8、 SELECT：处理 SELECT 列表，产生 VT8。 </p><p>9、 DISTINCT：将重复的行从 VT8 中删除，产品 VT9。</p><p>10、 ORDER BY：将 VT9 中的行按 ORDER BY 子句中的列列表顺序，生成一个游标(VC10)。 </p><p>11、 TOP：从 VC10 的开始处选择指定数量或比例的行，生成表 TV11，并返回给调用者。 where 子句中的条件书写顺序</p><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="https://cloud.tencent.com/developer/article/1600323">小马哥</a></p><p>侵权联系删除 email：<a href="mailto:&#x32;&#x36;&#54;&#x38;&#x33;&#x38;&#x30;&#48;&#x36;&#x34;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d;">&#x32;&#x36;&#54;&#x38;&#x33;&#x38;&#x30;&#48;&#x36;&#x34;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d;</a></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Morris 中序遍历</title>
      <link href="/2022/04/01/Morris-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2022/04/01/Morris-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote><p>morris遍历是二叉树遍历算法的超强进阶算法，跟递归、非递归（栈实现）的空间复杂度，morris遍历可以将非递归遍历中的空间复杂度降为O(1),并且避免了对栈的依赖。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。</p></blockquote><span id="more"></span><h1 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h1><p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 x）：</p><ul><li>如果 x 无左孩子，先将 x 的值加入答案数组，再访问 x 的右孩子，即 x &#x3D; x..right。</li><li>如果 x 有左孩子，则找到 x 左子树上最右的节点（即左子树中序遍历的最后一个节点，x 在中序遍历中的前驱节点），我们记为 predecessor。根据 predecessor 的右孩子是否为空，进行如下操作。</li><li>如果 predecessor 的右孩子为空，则将其右孩子指向 x，然后访问 x 的左孩子，即 x &#x3D; x.left。</li><li>如果 predecessor 的右孩子不为空，则此时其右孩子指向 x，说明我们已经遍历完 x 的左子树，我们将predecessor 的右孩子置空，将 x 的值加入答案数组，然后访问 x 的右孩子，即 x &#x3D; x.right。</li><li>重复上述操作，直至访问完整棵树。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        TreeNode *predecessor = nullptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != nullptr) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (root-&gt;</span>left != nullptr) &#123;</span><br><span class="line">                <span class="comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                <span class="function"><span class="title">predecessor</span> = root-&gt;</span>left;</span><br><span class="line">                <span class="function"><span class="title">while</span> (predecessor-&gt;</span><span class="function"><span class="title">right</span> != nullptr &amp;&amp; predecessor-&gt;</span>right != root) &#123;</span><br><span class="line">                    <span class="function"><span class="title">predecessor</span> = predecessor-&gt;</span>right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="function"><span class="title">if</span> (predecessor-&gt;</span>right == nullptr) &#123;</span><br><span class="line">                    <span class="function"><span class="title">predecessor</span>-&gt;</span>right = root;</span><br><span class="line">                    <span class="function"><span class="title">root</span> = root-&gt;</span>left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 说明左子树已经访问完了，我们需要断开链接</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="function"><span class="title">res</span>.push_back(root-&gt;</span>val);</span><br><span class="line">                    <span class="function"><span class="title">predecessor</span>-&gt;</span>right = nullptr;</span><br><span class="line">                    <span class="function"><span class="title">root</span> = root-&gt;</span>right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">res</span>.push_back(root-&gt;</span>val);</span><br><span class="line">                <span class="function"><span class="title">root</span> = root-&gt;</span>right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">LeetCode-Solution</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析hexo的原理</title>
      <link href="/2022/03/30/%E6%B5%85%E6%9E%90hexo%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/30/%E6%B5%85%E6%9E%90hexo%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析hexo的原理"><a href="#浅析hexo的原理" class="headerlink" title="浅析hexo的原理"></a>浅析hexo的原理</h1><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><span id="more"></span><h2 id="github的pages服务"><a href="#github的pages服务" class="headerlink" title="github的pages服务"></a>github的pages服务</h2><ul><li><p>github pages 支持静态页面的解析</p></li><li><p>Hexo 用来生成HTML，生成的HTML上传到服务器进行解析</p></li></ul><h2 id="如何用-hexo-生成HTML"><a href="#如何用-hexo-生成HTML" class="headerlink" title="如何用 hexo 生成HTML"></a>如何用 hexo 生成HTML</h2><h3 id="Hexo的工作原理"><a href="#Hexo的工作原理" class="headerlink" title="Hexo的工作原理"></a>Hexo的工作原理</h3><ul><li><p>hexo g : 生成静态文件。将我们的数据和界面相结合生成静态文件的过程。会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 publid 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。</p></li><li><p>hexo d：部署文件。部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 public 文件上传至 github 或者 coding 中。然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 public 文件上传至你自己的服务器上。</p></li></ul><h3 id="hexo的模板引擎"><a href="#hexo的模板引擎" class="headerlink" title="hexo的模板引擎"></a>hexo的模板引擎</h3><ul><li>source 文件夹理解为数据库，而主题文件夹相当于 界面。然后我们 hexo g 就将我们的数据和界面相结合生成静态文件 public。</li></ul><br><ul><li><p>Hexo 的模板引擎是默认使用 ejs 编写的。hexo首先会解析 md 文件，然后根据 layout 判断布局类型，再调用其他的文件，这样每一块的内容都是独立的，提高代码的复用性。最终会生成一个 html 页面。</p></li><li><p>hexo new [layout] &lt;title&gt;就会使用对应的模板。</p><br>其中 _layout.swig 是通用模板，里面引入了 head、footer 等公共组件，然后在其他的模板中会引入这个 _layout.swig 通用模板，比如 post.swig 模板</li></ul><h3 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h3><ul><li>数据填充主要是 hexo -g 的时候将数据传递给swig 模板，然后由swig模板填充到HTML中</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><br>    非要说 Hexo 是什么的话，我觉得就是生成静态页面的工具，可以将我们使用 markdown 编写的内容与主题模板相结合，生成 HTML 静态文件。并且可以和 github 的 pages 或者其他可以将静态页面展现出来的服务（例如 coding 的 pages 服务）相结合，一键部署。<p>再深入一点讲 Hexo 的原理的话，那就应该是使用 yaml 语言 做配置文件，使用 ejs 或者 swig 作为主题模板，与使用 markdown 书写的内容结合，生成静态 HTML 文件。</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><h3 id="如何使用git工具对hexo文章进行版本控制"><a href="#如何使用git工具对hexo文章进行版本控制" class="headerlink" title="如何使用git工具对hexo文章进行版本控制"></a>如何使用git工具对hexo文章进行版本控制</h3><blockquote><p>1.在github或gitee上创建一个私有仓<br><br>2.在hexo文件夹下执行git init <br><br>3.添加远程仓库地址，git remote add github repository_path(github是远程仓库别名，可以另取，repository_path是远程仓库地址)<br><br>4.先拉一下远程仓库的代码，git fetch github<br><br>5.将自己主题的配置复制一份，重命名放到hexo&#x2F;下<br><br>6.填写.gitignore忽略一些不需要进行管理的文件或文件夹，下面是我的配置<br><br>7.将自己的代码提交并push到github上即可<br></p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="meta">    .DS_Store</span></span><br><span class="line">    Thumbs<span class="number">.</span><span class="built_in">db</span></span><br><span class="line">    <span class="built_in">db</span><span class="number">.</span>json</span><br><span class="line">    *.log</span><br><span class="line">    node_modules/</span><br><span class="line">    <span class="meta">public</span>/</span><br><span class="line"><span class="meta">    .deploy</span>*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考  ：<br><br> <a href="https://juejin.cn/post/6844903490930622471">sunshine小小倩</a><br><br> <a href="https://blog.wangx.me/2019/01/12/git-upload-subfolder/">Wangx</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2022/03/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/03/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><strong>正则表达式</strong>：又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</p><span id="more"></span><hr><h2 id="常用字符"><a href="#常用字符" class="headerlink" title="常用字符"></a>常用字符</h2><ul><li><p>\</p><p>  将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</p></li></ul><hr><ul><li><p>^</p><p>  匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</p></li></ul><hr><ul><li><p>$    </p><p>  匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</p></li></ul><hr><ul><li><p>*    </p><p>  匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</p></li></ul><hr><ul><li><p>+</p><p>  匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</p></li></ul><hr><ul><li><p>?</p><p>  匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</p></li></ul><hr><ul><li><p>{n}</p><p>  n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</p></li></ul><hr><ul><li><p>{n,}    </p><p>  n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</p></li></ul><hr><ul><li><p>{n,m}    </p><p>  m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</p></li></ul><hr><ul><li><p>?    </p><p>  当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</p></li></ul><hr><ul><li><p>.    </p><p>  匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.|\n)”的模式。</p></li></ul><hr><ul><li><p>[xyz]    </p><p>  字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</p></li></ul><hr><ul><li><p>[^xyz]</p><p>  负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</p></li></ul><hr><ul><li><p>[a-z]    </p><p>  字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</p></li></ul><hr><ul><li><p>[^a-z]</p><p>  负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</p></li></ul><hr><ul><li><p>\b    </p><p>  匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</p></li></ul><hr><ul><li><p>\B    </p><p>  匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</p></li></ul><hr><ul><li><p>\d</p><p>  匹配一个数字字符。等价于 [0-9]。</p></li></ul><hr><ul><li><p>\D</p><p>  匹配一个非数字字符。等价于 [^0-9]。</p></li></ul><hr><ul><li><p>\r</p><p>  匹配一个回车符。等价于 \x0d 和 \cM。</p></li></ul><hr><ul><li><p>\s</p><p>  匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</p></li></ul><hr><ul><li><p>\S    </p><p>  匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</p></li></ul><hr><ul><li><p>\w    </p><p>  匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</p></li></ul><hr><ul><li><p>\W    </p><p>  匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</p></li></ul><hr><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul><li><p>i</p><p>不区分大小写</p></li><li><p>g</p><p>全局匹配  查找所有的匹配项</p></li><li><p>m</p><p>多行匹配</p></li></ul><br><p>参考   <a href="https://www.runoob.com/regexp/regexp-flags.html">菜鸟教程-正则表达式</a></p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/08/hello-world/"/>
      <url>/2022/03/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
